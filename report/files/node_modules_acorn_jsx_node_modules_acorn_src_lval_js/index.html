<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/acorn-jsx/node_modules/acorn/src/lval.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/acorn-jsx/node_modules/acorn/src/lval.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">54.39</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">216</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">74.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.29</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import {types as tt} from &quot;./tokentype&quot;
import {Parser} from &quot;./state&quot;
import {has} from &quot;./util&quot;

const pp = Parser.prototype

// Convert existing expression atom to assignable pattern
// if possible.

pp.toAssignable = function(node, isBinding) {
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; node) {
    switch (node.type) {
    case &quot;Identifier&quot;:
    case &quot;ObjectPattern&quot;:
    case &quot;ArrayPattern&quot;:
      break

    case &quot;ObjectExpression&quot;:
      node.type = &quot;ObjectPattern&quot;
      for (let i = 0; i &lt; node.properties.length; i++) {
        let prop = node.properties[i]
        if (prop.kind !== &quot;init&quot;) this.raise(prop.key.start, &quot;Object pattern can&#039;t contain getter or setter&quot;)
        this.toAssignable(prop.value, isBinding)
      }
      break

    case &quot;ArrayExpression&quot;:
      node.type = &quot;ArrayPattern&quot;
      this.toAssignableList(node.elements, isBinding)
      break

    case &quot;AssignmentExpression&quot;:
      if (node.operator === &quot;=&quot;) {
        node.type = &quot;AssignmentPattern&quot;
        delete node.operator
        // falls through to AssignmentPattern
      } else {
        this.raise(node.left.end, &quot;Only &#039;=&#039; operator can be used for specifying default value.&quot;)
        break
      }

    case &quot;AssignmentPattern&quot;:
      if (node.right.type === &quot;YieldExpression&quot;)
        this.raise(node.right.start, &quot;Yield expression cannot be a default value&quot;)
      break

    case &quot;ParenthesizedExpression&quot;:
      node.expression = this.toAssignable(node.expression, isBinding)
      break

    case &quot;MemberExpression&quot;:
      if (!isBinding) break

    default:
      this.raise(node.start, &quot;Assigning to rvalue&quot;)
    }
  }
  return node
}

// Convert list of expression atoms to binding list.

pp.toAssignableList = function(exprList, isBinding) {
  let end = exprList.length
  if (end) {
    let last = exprList[end - 1]
    if (last &amp;&amp; last.type == &quot;RestElement&quot;) {
      --end
    } else if (last &amp;&amp; last.type == &quot;SpreadElement&quot;) {
      last.type = &quot;RestElement&quot;
      let arg = last.argument
      this.toAssignable(arg, isBinding)
      if (arg.type !== &quot;Identifier&quot; &amp;&amp; arg.type !== &quot;MemberExpression&quot; &amp;&amp; arg.type !== &quot;ArrayPattern&quot;)
        this.unexpected(arg.start)
      --end
    }

    if (isBinding &amp;&amp; last &amp;&amp; last.type === &quot;RestElement&quot; &amp;&amp; last.argument.type !== &quot;Identifier&quot;)
      this.unexpected(last.argument.start)
  }
  for (let i = 0; i &lt; end; i++) {
    let elt = exprList[i]
    if (elt) this.toAssignable(elt, isBinding)
  }
  return exprList
}

// Parses spread element.

pp.parseSpread = function(refDestructuringErrors) {
  let node = this.startNode()
  this.next()
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors)
  return this.finishNode(node, &quot;SpreadElement&quot;)
}

pp.parseRest = function(allowNonIdent) {
  let node = this.startNode()
  this.next()

  // RestElement inside of a function parameter must be an identifier
  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()
  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()

  return this.finishNode(node, &quot;RestElement&quot;)
}

// Parses lvalue (assignable) atom.

pp.parseBindingAtom = function() {
  if (this.options.ecmaVersion &lt; 6) return this.parseIdent()
  switch (this.type) {
  case tt.name:
    return this.parseIdent()

  case tt.bracketL:
    let node = this.startNode()
    this.next()
    node.elements = this.parseBindingList(tt.bracketR, true, true)
    return this.finishNode(node, &quot;ArrayPattern&quot;)

  case tt.braceL:
    return this.parseObj(true)

  default:
    this.unexpected()
  }
}

pp.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {
  let elts = [], first = true
  while (!this.eat(close)) {
    if (first) first = false
    else this.expect(tt.comma)
    if (allowEmpty &amp;&amp; this.type === tt.comma) {
      elts.push(null)
    } else if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) {
      break
    } else if (this.type === tt.ellipsis) {
      let rest = this.parseRest(allowNonIdent)
      this.parseBindingListItem(rest)
      elts.push(rest)
      if (this.type === tt.comma) this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;)
      this.expect(close)
      break
    } else {
      let elem = this.parseMaybeDefault(this.start, this.startLoc)
      this.parseBindingListItem(elem)
      elts.push(elem)
    }
  }
  return elts
}

pp.parseBindingListItem = function(param) {
  return param
}

// Parses assignment pattern around given atom if possible.

pp.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom()
  if (this.options.ecmaVersion &lt; 6 || !this.eat(tt.eq)) return left
  let node = this.startNodeAt(startPos, startLoc)
  node.left = left
  node.right = this.parseMaybeAssign()
  return this.finishNode(node, &quot;AssignmentPattern&quot;)
}

// Verify that a node is an lval â€” something that can be assigned
// to.

pp.checkLVal = function(expr, isBinding, checkClashes) {
  switch (expr.type) {
  case &quot;Identifier&quot;:
    if (this.strict &amp;&amp; this.reservedWordsStrictBind.test(expr.name))
      this.raiseRecoverable(expr.start, (isBinding ? &quot;Binding &quot; : &quot;Assigning to &quot;) + expr.name + &quot; in strict mode&quot;)
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        this.raiseRecoverable(expr.start, &quot;Argument name clash&quot;)
      checkClashes[expr.name] = true
    }
    break

  case &quot;MemberExpression&quot;:
    if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? &quot;Binding&quot; : &quot;Assigning to&quot;) + &quot; member expression&quot;)
    break

  case &quot;ObjectPattern&quot;:
    for (let i = 0; i &lt; expr.properties.length; i++)
      this.checkLVal(expr.properties[i].value, isBinding, checkClashes)
    break

  case &quot;ArrayPattern&quot;:
    for (let i = 0; i &lt; expr.elements.length; i++) {
      let elem = expr.elements[i]
      if (elem) this.checkLVal(elem, isBinding, checkClashes)
    }
    break

  case &quot;AssignmentPattern&quot;:
    this.checkLVal(expr.left, isBinding, checkClashes)
    break

  case &quot;RestElement&quot;:
    this.checkLVal(expr.argument, isBinding, checkClashes)
    break

  case &quot;ParenthesizedExpression&quot;:
    this.checkLVal(expr.expression, isBinding, checkClashes)
    break

  default:
    this.raise(expr.start, (isBinding ? &quot;Binding&quot; : &quot;Assigning to&quot;) + &quot; rvalue&quot;)
  }
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
