<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/acorn/src/tokenize.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/acorn/src/tokenize.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">56.59</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">682</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">162.97</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.54</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import {isIdentifierStart, isIdentifierChar} from &quot;./identifier&quot;
import {types as tt, keywords as keywordTypes} from &quot;./tokentype&quot;
import {Parser} from &quot;./state&quot;
import {SourceLocation} from &quot;./locutil&quot;
import {lineBreak, lineBreakG, isNewLine, nonASCIIwhitespace} from &quot;./whitespace&quot;

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

export class Token {
  constructor(p) {
    this.type = p.type
    this.value = p.value
    this.start = p.start
    this.end = p.end
    if (p.options.locations)
      this.loc = new SourceLocation(p, p.startLoc, p.endLoc)
    if (p.options.ranges)
      this.range = [p.start, p.end]
  }
}

// ## Tokenizer

const pp = Parser.prototype

// Are we running under Rhino?
const isRhino = typeof Packages == &quot;object&quot; &amp;&amp; Object.prototype.toString.call(Packages) == &quot;[object JavaPackage]&quot;

// Move to the next token

pp.next = function() {
  if (this.options.onToken)
    this.options.onToken(new Token(this))

  this.lastTokEnd = this.end
  this.lastTokStart = this.start
  this.lastTokEndLoc = this.endLoc
  this.lastTokStartLoc = this.startLoc
  this.nextToken()
}

pp.getToken = function() {
  this.next()
  return new Token(this)
}

// If we&#039;re in an ES6 environment, make parsers iterable
if (typeof Symbol !== &quot;undefined&quot;)
  pp[Symbol.iterator] = function () {
    let self = this
    return {next: function () {
      let token = self.getToken()
      return {
        done: token.type === tt.eof,
        value: token
      }
    }}
  }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`&quot;use strict&quot;; 010;` should fail).

pp.setStrict = function(strict) {
  this.strict = strict
  if (this.type !== tt.num &amp;&amp; this.type !== tt.string) return
  this.pos = this.start
  if (this.options.locations) {
    while (this.pos &lt; this.lineStart) {
      this.lineStart = this.input.lastIndexOf(&quot;\n&quot;, this.lineStart - 2) + 1
      --this.curLine
    }
  }
  this.nextToken()
}

pp.curContext = function() {
  return this.context[this.context.length - 1]
}

// Read a single token, updating the parser object&#039;s token-related
// properties.

pp.nextToken = function() {
  let curContext = this.curContext()
  if (!curContext || !curContext.preserveSpace) this.skipSpace()

  this.start = this.pos
  if (this.options.locations) this.startLoc = this.curPosition()
  if (this.pos &gt;= this.input.length) return this.finishToken(tt.eof)

  if (curContext.override) return curContext.override(this)
  else this.readToken(this.fullCharCodeAtPos())
}

pp.readToken = function(code) {
  // Identifier or keyword. &#039;\uXXXX&#039; sequences are allowed in
  // identifiers, so &#039;\&#039; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &#039;\&#039; */)
    return this.readWord()

  return this.getTokenFromCode(code)
}

pp.fullCharCodeAtPos = function() {
  let code = this.input.charCodeAt(this.pos)
  if (code &lt;= 0xd7ff || code &gt;= 0xe000) return code
  let next = this.input.charCodeAt(this.pos + 1)
  return (code &lt;&lt; 10) + next - 0x35fdc00
}

pp.skipBlockComment = function() {
  let startLoc = this.options.onComment &amp;&amp; this.curPosition()
  let start = this.pos, end = this.input.indexOf(&quot;*/&quot;, this.pos += 2)
  if (end === -1) this.raise(this.pos - 2, &quot;Unterminated comment&quot;)
  this.pos = end + 2
  if (this.options.locations) {
    lineBreakG.lastIndex = start
    let match
    while ((match = lineBreakG.exec(this.input)) &amp;&amp; match.index &lt; this.pos) {
      ++this.curLine
      this.lineStart = match.index + match[0].length
    }
  }
  if (this.options.onComment)
    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition())
}

pp.skipLineComment = function(startSkip) {
  let start = this.pos
  let startLoc = this.options.onComment &amp;&amp; this.curPosition()
  let ch = this.input.charCodeAt(this.pos+=startSkip)
  while (this.pos &lt; this.input.length &amp;&amp; ch !== 10 &amp;&amp; ch !== 13 &amp;&amp; ch !== 8232 &amp;&amp; ch !== 8233) {
    ++this.pos
    ch = this.input.charCodeAt(this.pos)
  }
  if (this.options.onComment)
    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition())
}

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp.skipSpace = function() {
  loop: while (this.pos &lt; this.input.length) {
    let ch = this.input.charCodeAt(this.pos)
    switch (ch) {
      case 32: case 160: // &#039; &#039;
        ++this.pos
        break
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos
        }
      case 10: case 8232: case 8233:
        ++this.pos
        if (this.options.locations) {
          ++this.curLine
          this.lineStart = this.pos
        }
        break
      case 47: // &#039;/&#039;
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42: // &#039;*&#039;
            this.skipBlockComment()
            break
          case 47:
            this.skipLineComment(2)
            break
          default:
            break loop
        }
        break
      default:
        if (ch &gt; 8 &amp;&amp; ch &lt; 14 || ch &gt;= 5760 &amp;&amp; nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos
        } else {
          break loop
        }
    }
  }
}

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one&#039;s `start` will point at the
// right position.

pp.finishToken = function(type, val) {
  this.end = this.pos
  if (this.options.locations) this.endLoc = this.curPosition()
  let prevType = this.type
  this.type = type
  this.value = val

  this.updateContext(prevType)
}

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp.readToken_dot = function() {
  let next = this.input.charCodeAt(this.pos + 1)
  if (next &gt;= 48 &amp;&amp; next &lt;= 57) return this.readNumber(true)
  let next2 = this.input.charCodeAt(this.pos + 2)
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; next === 46 &amp;&amp; next2 === 46) { // 46 = dot &#039;.&#039;
    this.pos += 3
    return this.finishToken(tt.ellipsis)
  } else {
    ++this.pos
    return this.finishToken(tt.dot)
  }
}

pp.readToken_slash = function() { // &#039;/&#039;
  let next = this.input.charCodeAt(this.pos + 1)
  if (this.exprAllowed) {++this.pos; return this.readRegexp();}
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(tt.slash, 1)
}

pp.readToken_mult_modulo = function(code) { // &#039;%*&#039;
  let next = this.input.charCodeAt(this.pos + 1)
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(code === 42 ? tt.star : tt.modulo, 1)
}

pp.readToken_pipe_amp = function(code) { // &#039;|&amp;&#039;
  let next = this.input.charCodeAt(this.pos + 1)
  if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2)
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1)
}

pp.readToken_caret = function() { // &#039;^&#039;
  let next = this.input.charCodeAt(this.pos + 1)
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(tt.bitwiseXOR, 1)
}

pp.readToken_plus_min = function(code) { // &#039;+-&#039;
  let next = this.input.charCodeAt(this.pos + 1)
  if (next === code) {
    if (next == 45 &amp;&amp; this.input.charCodeAt(this.pos + 2) == 62 &amp;&amp;
        lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
      // A `--&gt;` line comment
      this.skipLineComment(3)
      this.skipSpace()
      return this.nextToken()
    }
    return this.finishOp(tt.incDec, 2)
  }
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(tt.plusMin, 1)
}

pp.readToken_lt_gt = function(code) { // &#039;&lt;&gt;&#039;
  let next = this.input.charCodeAt(this.pos + 1)
  let size = 1
  if (next === code) {
    size = code === 62 &amp;&amp; this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2
    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1)
    return this.finishOp(tt.bitShift, size)
  }
  if (next == 33 &amp;&amp; code == 60 &amp;&amp; this.input.charCodeAt(this.pos + 2) == 45 &amp;&amp;
      this.input.charCodeAt(this.pos + 3) == 45) {
    if (this.inModule) this.unexpected()
    // `&lt;!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4)
    this.skipSpace()
    return this.nextToken()
  }
  if (next === 61)
    size = this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2
  return this.finishOp(tt.relational, size)
}

pp.readToken_eq_excl = function(code) { // &#039;=!&#039;
  let next = this.input.charCodeAt(this.pos + 1)
  if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)
  if (code === 61 &amp;&amp; next === 62 &amp;&amp; this.options.ecmaVersion &gt;= 6) { // &#039;=&gt;&#039;
    this.pos += 2
    return this.finishToken(tt.arrow)
  }
  return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)
}

pp.getTokenFromCode = function(code) {
  switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
  case 46: // &#039;.&#039;
    return this.readToken_dot()

    // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(tt.parenL)
  case 41: ++this.pos; return this.finishToken(tt.parenR)
  case 59: ++this.pos; return this.finishToken(tt.semi)
  case 44: ++this.pos; return this.finishToken(tt.comma)
  case 91: ++this.pos; return this.finishToken(tt.bracketL)
  case 93: ++this.pos; return this.finishToken(tt.bracketR)
  case 123: ++this.pos; return this.finishToken(tt.braceL)
  case 125: ++this.pos; return this.finishToken(tt.braceR)
  case 58: ++this.pos; return this.finishToken(tt.colon)
  case 63: ++this.pos; return this.finishToken(tt.question)

  case 96: // &#039;`&#039;
    if (this.options.ecmaVersion &lt; 6) break
    ++this.pos
    return this.finishToken(tt.backQuote)

  case 48: // &#039;0&#039;
    let next = this.input.charCodeAt(this.pos + 1)
    if (next === 120 || next === 88) return this.readRadixNumber(16); // &#039;0x&#039;, &#039;0X&#039; - hex number
    if (this.options.ecmaVersion &gt;= 6) {
      if (next === 111 || next === 79) return this.readRadixNumber(8); // &#039;0o&#039;, &#039;0O&#039; - octal number
      if (next === 98 || next === 66) return this.readRadixNumber(2); // &#039;0b&#039;, &#039;0B&#039; - binary number
    }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

    // Quotes produce strings.
  case 34: case 39: // &#039;&quot;&#039;, &quot;&#039;&quot;
    return this.readString(code)

    // Operators are parsed inline in tiny state machines. &#039;=&#039; (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

  case 47: // &#039;/&#039;
    return this.readToken_slash()

  case 37: case 42: // &#039;%*&#039;
    return this.readToken_mult_modulo(code)

  case 124: case 38: // &#039;|&amp;&#039;
    return this.readToken_pipe_amp(code)

  case 94: // &#039;^&#039;
    return this.readToken_caret()

  case 43: case 45: // &#039;+-&#039;
    return this.readToken_plus_min(code)

  case 60: case 62: // &#039;&lt;&gt;&#039;
    return this.readToken_lt_gt(code)

  case 61: case 33: // &#039;=!&#039;
    return this.readToken_eq_excl(code)

  case 126: // &#039;~&#039;
    return this.finishOp(tt.prefix, 1)
  }

  this.raise(this.pos, &quot;Unexpected character &#039;&quot; + codePointToString(code) + &quot;&#039;&quot;)
}

pp.finishOp = function(type, size) {
  let str = this.input.slice(this.pos, this.pos + size)
  this.pos += size
  return this.finishToken(type, str)
}

// Parse a regular expression. Some context-awareness is necessary,
// since a &#039;/&#039; inside a &#039;[]&#039; set does not end the expression.

function tryCreateRegexp(src, flags, throwErrorAt, parser) {
  try {
    return new RegExp(src, flags);
  } catch (e) {
    if (throwErrorAt !== undefined) {
      if (e instanceof SyntaxError) parser.raise(throwErrorAt, &quot;Error parsing regular expression: &quot; + e.message)
      throw e
    }
  }
}

var regexpUnicodeSupport = !!tryCreateRegexp(&quot;\uffff&quot;, &quot;u&quot;);

pp.readRegexp = function() {
  let escaped, inClass, start = this.pos
  for (;;) {
    if (this.pos &gt;= this.input.length) this.raise(start, &quot;Unterminated regular expression&quot;)
    let ch = this.input.charAt(this.pos)
    if (lineBreak.test(ch)) this.raise(start, &quot;Unterminated regular expression&quot;)
    if (!escaped) {
      if (ch === &quot;[&quot;) inClass = true
      else if (ch === &quot;]&quot; &amp;&amp; inClass) inClass = false
      else if (ch === &quot;/&quot; &amp;&amp; !inClass) break
      escaped = ch === &quot;\\&quot;
    } else escaped = false
    ++this.pos
  }
  let content = this.input.slice(start, this.pos)
  ++this.pos
  // Need to use `readWord1` because &#039;\uXXXX&#039; sequences are allowed
  // here (don&#039;t ask).
  let mods = this.readWord1()
  let tmp = content
  if (mods) {
    let validFlags = /^[gim]*$/
    if (this.options.ecmaVersion &gt;= 6) validFlags = /^[gimuy]*$/
    if (!validFlags.test(mods)) this.raise(start, &quot;Invalid regular expression flag&quot;)
    if (mods.indexOf(&#039;u&#039;) &gt;= 0 &amp;&amp; !regexpUnicodeSupport) {
      // Replace each astral symbol and every Unicode escape sequence that
      // possibly represents an astral symbol or a paired surrogate with a
      // single ASCII symbol to avoid throwing on regular expressions that
      // are only valid in combination with the `/u` flag.
      // Note: replacing with the ASCII symbol `x` might cause false
      // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
      // perfectly valid pattern that is equivalent to `[a-b]`, but it would
      // be replaced by `[x-b]` which throws an error.
      tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, (_match, code, offset) =&gt; {
        code = Number(&quot;0x&quot; + code)
        if (code &gt; 0x10FFFF) this.raise(start + offset + 3, &quot;Code point out of bounds&quot;)
        return &quot;x&quot;
      });
      tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, &quot;x&quot;)
    }
  }
  // Detect invalid regular expressions.
  let value = null
  // Rhino&#039;s regular expression parser is flaky and throws uncatchable exceptions,
  // so don&#039;t do detection if we are running under Rhino
  if (!isRhino) {
    tryCreateRegexp(tmp, undefined, start, this);
    // Get a regular expression object for this pattern-flag pair, or `null` in
    // case the current environment doesn&#039;t support the flags it uses.
    value = tryCreateRegexp(content, mods)
  }
  return this.finishToken(tt.regexp, {pattern: content, flags: mods, value: value})
}

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp.readInt = function(radix, len) {
  let start = this.pos, total = 0
  for (let i = 0, e = len == null ? Infinity : len; i &lt; e; ++i) {
    let code = this.input.charCodeAt(this.pos), val
    if (code &gt;= 97) val = code - 97 + 10; // a
    else if (code &gt;= 65) val = code - 65 + 10; // A
    else if (code &gt;= 48 &amp;&amp; code &lt;= 57) val = code - 48; // 0-9
    else val = Infinity
    if (val &gt;= radix) break
    ++this.pos
    total = total * radix + val
  }
  if (this.pos === start || len != null &amp;&amp; this.pos - start !== len) return null

  return total
}

pp.readRadixNumber = function(radix) {
  this.pos += 2; // 0x
  let val = this.readInt(radix)
  if (val == null) this.raise(this.start + 2, &quot;Expected number in radix &quot; + radix)
  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, &quot;Identifier directly after number&quot;)
  return this.finishToken(tt.num, val)
}

// Read an integer, octal integer, or floating-point number.

pp.readNumber = function(startsWithDot) {
  let start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48
  if (!startsWithDot &amp;&amp; this.readInt(10) === null) this.raise(start, &quot;Invalid number&quot;)
  let next = this.input.charCodeAt(this.pos)
  if (next === 46) { // &#039;.&#039;
    ++this.pos
    this.readInt(10)
    isFloat = true
    next = this.input.charCodeAt(this.pos)
  }
  if (next === 69 || next === 101) { // &#039;eE&#039;
    next = this.input.charCodeAt(++this.pos)
    if (next === 43 || next === 45) ++this.pos; // &#039;+-&#039;
    if (this.readInt(10) === null) this.raise(start, &quot;Invalid number&quot;)
    isFloat = true
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, &quot;Identifier directly after number&quot;)

  let str = this.input.slice(start, this.pos), val
  if (isFloat) val = parseFloat(str)
  else if (!octal || str.length === 1) val = parseInt(str, 10)
  else if (/[89]/.test(str) || this.strict) this.raise(start, &quot;Invalid number&quot;)
  else val = parseInt(str, 8)
  return this.finishToken(tt.num, val)
}

// Read a string value, interpreting backslash-escapes.

pp.readCodePoint = function() {
  let ch = this.input.charCodeAt(this.pos), code

  if (ch === 123) {
    if (this.options.ecmaVersion &lt; 6) this.unexpected()
    let codePos = ++this.pos
    code = this.readHexChar(this.input.indexOf(&#039;}&#039;, this.pos) - this.pos)
    ++this.pos
    if (code &gt; 0x10FFFF) this.raise(codePos, &quot;Code point out of bounds&quot;)
  } else {
    code = this.readHexChar(4)
  }
  return code
}

function codePointToString(code) {
  // UTF-16 Decoding
  if (code &lt;= 0xFFFF) return String.fromCharCode(code)
  code -= 0x10000
  return String.fromCharCode((code &gt;&gt; 10) + 0xD800, (code &amp; 1023) + 0xDC00)
}

pp.readString = function(quote) {
  let out = &quot;&quot;, chunkStart = ++this.pos
  for (;;) {
    if (this.pos &gt;= this.input.length) this.raise(this.start, &quot;Unterminated string constant&quot;)
    let ch = this.input.charCodeAt(this.pos)
    if (ch === quote) break
    if (ch === 92) { // &#039;\&#039;
      out += this.input.slice(chunkStart, this.pos)
      out += this.readEscapedChar(false)
      chunkStart = this.pos
    } else {
      if (isNewLine(ch)) this.raise(this.start, &quot;Unterminated string constant&quot;)
      ++this.pos
    }
  }
  out += this.input.slice(chunkStart, this.pos++)
  return this.finishToken(tt.string, out)
}

// Reads template string tokens.

pp.readTmplToken = function() {
  let out = &quot;&quot;, chunkStart = this.pos
  for (;;) {
    if (this.pos &gt;= this.input.length) this.raise(this.start, &quot;Unterminated template&quot;)
    let ch = this.input.charCodeAt(this.pos)
    if (ch === 96 || ch === 36 &amp;&amp; this.input.charCodeAt(this.pos + 1) === 123) { // &#039;`&#039;, &#039;${&#039;
      if (this.pos === this.start &amp;&amp; this.type === tt.template) {
        if (ch === 36) {
          this.pos += 2
          return this.finishToken(tt.dollarBraceL)
        } else {
          ++this.pos
          return this.finishToken(tt.backQuote)
        }
      }
      out += this.input.slice(chunkStart, this.pos)
      return this.finishToken(tt.template, out)
    }
    if (ch === 92) { // &#039;\&#039;
      out += this.input.slice(chunkStart, this.pos)
      out += this.readEscapedChar(true)
      chunkStart = this.pos
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos)
      ++this.pos
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
        case 10:
          out += &quot;\n&quot;;
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine
        this.lineStart = this.pos
      }
      chunkStart = this.pos
    } else {
      ++this.pos
    }
  }
}

// Used to read escaped characters

pp.readEscapedChar = function(inTemplate) {
  let ch = this.input.charCodeAt(++this.pos)
  ++this.pos
  switch (ch) {
  case 110: return &quot;\n&quot;; // &#039;n&#039; -&gt; &#039;\n&#039;
  case 114: return &quot;\r&quot;; // &#039;r&#039; -&gt; &#039;\r&#039;
  case 120: return String.fromCharCode(this.readHexChar(2)); // &#039;x&#039;
  case 117: return codePointToString(this.readCodePoint()); // &#039;u&#039;
  case 116: return &quot;\t&quot;; // &#039;t&#039; -&gt; &#039;\t&#039;
  case 98: return &quot;\b&quot;; // &#039;b&#039; -&gt; &#039;\b&#039;
  case 118: return &quot;\u000b&quot;; // &#039;v&#039; -&gt; &#039;\u000b&#039;
  case 102: return &quot;\f&quot;; // &#039;f&#039; -&gt; &#039;\f&#039;
  case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // &#039;\r\n&#039;
  case 10: // &#039; \n&#039;
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine }
    return &quot;&quot;
  default:
    if (ch &gt;= 48 &amp;&amp; ch &lt;= 55) {
      let octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]
      let octal = parseInt(octalStr, 8)
      if (octal &gt; 255) {
        octalStr = octalStr.slice(0, -1)
        octal = parseInt(octalStr, 8)
      }
      if (octalStr !== &quot;0&quot; &amp;&amp; (this.strict || inTemplate)) {
        this.raise(this.pos - 2, &quot;Octal literal in strict mode&quot;)
      }
      this.pos += octalStr.length - 1
      return String.fromCharCode(octal)
    }
    return String.fromCharCode(ch)
  }
}

// Used to read character escape sequences (&#039;\x&#039;, &#039;\u&#039;, &#039;\U&#039;).

pp.readHexChar = function(len) {
  let codePos = this.pos
  let n = this.readInt(16, len)
  if (n === null) this.raise(codePos, &quot;Bad character escape sequence&quot;)
  return n
}

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a &#039;\u&#039; escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp.readWord1 = function() {
  this.containsEsc = false
  let word = &quot;&quot;, first = true, chunkStart = this.pos
  let astral = this.options.ecmaVersion &gt;= 6
  while (this.pos &lt; this.input.length) {
    let ch = this.fullCharCodeAtPos()
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch &lt;= 0xffff ? 1 : 2
    } else if (ch === 92) { // &quot;\&quot;
      this.containsEsc = true
      word += this.input.slice(chunkStart, this.pos)
      let escStart = this.pos
      if (this.input.charCodeAt(++this.pos) != 117) // &quot;u&quot;
        this.raise(this.pos, &quot;Expecting Unicode escape sequence \\uXXXX&quot;)
      ++this.pos
      let esc = this.readCodePoint()
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        this.raise(escStart, &quot;Invalid Unicode escape&quot;)
      word += codePointToString(esc)
      chunkStart = this.pos
    } else {
      break
    }
    first = false
  }
  return word + this.input.slice(chunkStart, this.pos)
}

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp.readWord = function() {
  let word = this.readWord1()
  let type = tt.name
  if ((this.options.ecmaVersion &gt;= 6 || !this.containsEsc) &amp;&amp; this.keywords.test(word))
    type = keywordTypes[word]
  return this.finishToken(type, word)
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
