<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/bson/lib/bson/parser/serializer.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/bson/lib/bson/parser/serializer.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">47.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">912</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">169.09</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.46</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;

var writeIEEE754 = require(&#039;../float_parser&#039;).writeIEEE754,
  readIEEE754 = require(&#039;../float_parser&#039;).readIEEE754,
  Long = require(&#039;../long&#039;).Long,
  Map = require(&#039;../map&#039;),
  Double = require(&#039;../double&#039;).Double,
  Timestamp = require(&#039;../timestamp&#039;).Timestamp,
  ObjectID = require(&#039;../objectid&#039;).ObjectID,
  Symbol = require(&#039;../symbol&#039;).Symbol,
  Code = require(&#039;../code&#039;).Code,
  BSONRegExp = require(&#039;../regexp&#039;).BSONRegExp,
  MinKey = require(&#039;../min_key&#039;).MinKey,
  MaxKey = require(&#039;../max_key&#039;).MaxKey,
  DBRef = require(&#039;../db_ref&#039;).DBRef,
  Binary = require(&#039;../binary&#039;).Binary;

var regexp = /\x00/

// To ensure that 0.4 of node works correctly
var isDate = function isDate(d) {
  return typeof d === &#039;object&#039; &amp;&amp; Object.prototype.toString.call(d) === &#039;[object Date]&#039;;
}

var isRegExp = function isRegExp(d) {
  return Object.prototype.toString.call(d) === &#039;[object RegExp]&#039;;
}

var serializeString = function(buffer, key, value, index) {
  // Encode String type
  buffer[index++] = BSON.BSON_DATA_STRING;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
  // Encode the name
  index = index + numberOfWrittenBytes + 1;
  buffer[index - 1] = 0;
  // Write the string
  var size = buffer.write(value, index + 4, &#039;utf8&#039;);
  // Write the size of the string to buffer
  buffer[index + 3] = (size + 1 &gt;&gt; 24) &amp; 0xff;
  buffer[index + 2] = (size + 1 &gt;&gt; 16) &amp; 0xff;
  buffer[index + 1] = (size + 1 &gt;&gt; 8) &amp; 0xff;
  buffer[index] = size + 1 &amp; 0xff;
  // Update index
  index = index + 4 + size;
  // Write zero
  buffer[index++] = 0;
  return index;
}

var serializeNumber = function(buffer, key, value, index) {
  // We have an integer value
  if(Math.floor(value) === value &amp;&amp; value &gt;= BSON.JS_INT_MIN &amp;&amp; value &lt;= BSON.JS_INT_MAX) {
    // If the value fits in 32 bits encode as int, if it fits in a double
    // encode it as a double, otherwise long
    if(value &gt;= BSON.BSON_INT32_MIN &amp;&amp; value &lt;= BSON.BSON_INT32_MAX) {
      // Set int type 32 bits or less
      buffer[index++] = BSON.BSON_DATA_INT;
      // Number of written bytes
      var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
      // Encode the name
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      // Write the int value
      buffer[index++] = value &amp; 0xff;
      buffer[index++] = (value &gt;&gt; 8) &amp; 0xff;
      buffer[index++] = (value &gt;&gt; 16) &amp; 0xff;
      buffer[index++] = (value &gt;&gt; 24) &amp; 0xff;
    } else if(value &gt;= BSON.JS_INT_MIN &amp;&amp; value &lt;= BSON.JS_INT_MAX) {
      // Encode as double
      buffer[index++] = BSON.BSON_DATA_NUMBER;
      // Number of written bytes
      var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
      // Encode the name
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      // Write float
      writeIEEE754(buffer, value, index, &#039;little&#039;, 52, 8);
      // Ajust index
      index = index + 8;
    } else {
      // Set long type
      buffer[index++] = BSON.BSON_DATA_LONG;
      // Number of written bytes
      var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
      // Encode the name
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var longVal = Long.fromNumber(value);
      var lowBits = longVal.getLowBits();
      var highBits = longVal.getHighBits();
      // Encode low bits
      buffer[index++] = lowBits &amp; 0xff;
      buffer[index++] = (lowBits &gt;&gt; 8) &amp; 0xff;
      buffer[index++] = (lowBits &gt;&gt; 16) &amp; 0xff;
      buffer[index++] = (lowBits &gt;&gt; 24) &amp; 0xff;
      // Encode high bits
      buffer[index++] = highBits &amp; 0xff;
      buffer[index++] = (highBits &gt;&gt; 8) &amp; 0xff;
      buffer[index++] = (highBits &gt;&gt; 16) &amp; 0xff;
      buffer[index++] = (highBits &gt;&gt; 24) &amp; 0xff;
    }
  } else {
    // Encode as double
    buffer[index++] = BSON.BSON_DATA_NUMBER;
    // Number of written bytes
    var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
    // Encode the name
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    // Write float
    writeIEEE754(buffer, value, index, &#039;little&#039;, 52, 8);
    // Ajust index
    index = index + 8;
  }

  return index;
}

var serializeUndefined = function(buffer, key, value, index) {
  // Set long type
  buffer[index++] = BSON.BSON_DATA_NULL;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  return index;
}

var serializeBoolean = function(buffer, key, value, index) {
  // Write the type
  buffer[index++] = BSON.BSON_DATA_BOOLEAN;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Encode the boolean value
  buffer[index++] = value ? 1 : 0;
  return index;
}

var serializeDate = function(buffer, key, value, index) {
  // Write the type
  buffer[index++] = BSON.BSON_DATA_DATE;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;

  // Write the date
  var dateInMilis = Long.fromNumber(value.getTime());
  var lowBits = dateInMilis.getLowBits();
  var highBits = dateInMilis.getHighBits();
  // Encode low bits
  buffer[index++] = lowBits &amp; 0xff;
  buffer[index++] = (lowBits &gt;&gt; 8) &amp; 0xff;
  buffer[index++] = (lowBits &gt;&gt; 16) &amp; 0xff;
  buffer[index++] = (lowBits &gt;&gt; 24) &amp; 0xff;
  // Encode high bits
  buffer[index++] = highBits &amp; 0xff;
  buffer[index++] = (highBits &gt;&gt; 8) &amp; 0xff;
  buffer[index++] = (highBits &gt;&gt; 16) &amp; 0xff;
  buffer[index++] = (highBits &gt;&gt; 24) &amp; 0xff;
  return index;
}

var serializeRegExp = function(buffer, key, value, index) {
  // Write the type
  buffer[index++] = BSON.BSON_DATA_REGEXP;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  if (value.source &amp;&amp; value.source.match(regexp) != null) {
    throw Error(&quot;value &quot; + value.source + &quot; must not contain null bytes&quot;);
  }
  // Adjust the index
  index = index + buffer.write(value.source, index, &#039;utf8&#039;);
  // Write zero
  buffer[index++] = 0x00;
  // Write the parameters
  if(value.global) buffer[index++] = 0x73; // s
  if(value.ignoreCase) buffer[index++] = 0x69; // i
  if(value.multiline) buffer[index++] = 0x6d; // m
  // Add ending zero
  buffer[index++] = 0x00;
  return index;
}

var serializeBSONRegExp = function(buffer, key, value, index) {
  // Write the type
  buffer[index++] = BSON.BSON_DATA_REGEXP;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Adjust the index
  index = index + buffer.write(value.pattern, index, &#039;utf8&#039;);
  // Write zero
  buffer[index++] = 0x00;
  // Write the options
  index = index + buffer.write(value.options, index, &#039;utf8&#039;);
  // Add ending zero
  buffer[index++] = 0x00;
  return index;
}

var serializeMinMax = function(buffer, key, value, index) {
  // Write the type of either min or max key
  if(value === null) {
    buffer[index++] = BSON.BSON_DATA_NULL;
  } else if(value instanceof MinKey) {
    buffer[index++] = BSON.BSON_DATA_MIN_KEY;
  } else {
    buffer[index++] = BSON.BSON_DATA_MAX_KEY;
  }

  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  return index;
}

var serializeObjectId = function(buffer, key, value, index) {
  // Write the type
  buffer[index++] = BSON.BSON_DATA_OID;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);

  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;

  // Write the objectId into the shared buffer
  buffer.write(value.id, index, &#039;binary&#039;)

  // Ajust index
  return index + 12;
}

var serializeBuffer = function(buffer, key, value, index) {
  // Write the type
  buffer[index++] = BSON.BSON_DATA_BINARY;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Get size of the buffer (current write point)
  var size = value.length;
  // Write the size of the string to buffer
  buffer[index++] = size &amp; 0xff;
  buffer[index++] = (size &gt;&gt; 8) &amp; 0xff;
  buffer[index++] = (size &gt;&gt; 16) &amp; 0xff;
  buffer[index++] = (size &gt;&gt; 24) &amp; 0xff;
  // Write the default subtype
  buffer[index++] = BSON.BSON_BINARY_SUBTYPE_DEFAULT;
  // Copy the content form the binary field to the buffer
  value.copy(buffer, index, 0, size);
  // Adjust the index
  index = index + size;
  return index;
}

var serializeObject = function(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined) {
  // Write the type
  buffer[index++] = Array.isArray(value) ? BSON.BSON_DATA_ARRAY : BSON.BSON_DATA_OBJECT;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined);
  // Write size
  var size = endIndex - index;
  return endIndex;
}

var serializeLong = function(buffer, key, value, index) {
  // Write the type
  buffer[index++] = value._bsontype == &#039;Long&#039; ? BSON.BSON_DATA_LONG : BSON.BSON_DATA_TIMESTAMP;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Write the date
  var lowBits = value.getLowBits();
  var highBits = value.getHighBits();
  // Encode low bits
  buffer[index++] = lowBits &amp; 0xff;
  buffer[index++] = (lowBits &gt;&gt; 8) &amp; 0xff;
  buffer[index++] = (lowBits &gt;&gt; 16) &amp; 0xff;
  buffer[index++] = (lowBits &gt;&gt; 24) &amp; 0xff;
  // Encode high bits
  buffer[index++] = highBits &amp; 0xff;
  buffer[index++] = (highBits &gt;&gt; 8) &amp; 0xff;
  buffer[index++] = (highBits &gt;&gt; 16) &amp; 0xff;
  buffer[index++] = (highBits &gt;&gt; 24) &amp; 0xff;
  return index;
}

var serializeDouble = function(buffer, key, value, index) {
  // Encode as double
  buffer[index++] = BSON.BSON_DATA_NUMBER;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Write float
  writeIEEE754(buffer, value, index, &#039;little&#039;, 52, 8);
  // Ajust index
  index = index + 8;
  return index;
}

var serializeFunction = function(buffer, key, value, index, checkKeys, depth) {
  buffer[index++] = BSON.BSON_DATA_CODE;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Function string
  var functionString = value.toString();
  // Write the string
  var size = buffer.write(functionString, index + 4, &#039;utf8&#039;) + 1;
  // Write the size of the string to buffer
  buffer[index] = size &amp; 0xff;
  buffer[index + 1] = (size &gt;&gt; 8) &amp; 0xff;
  buffer[index + 2] = (size &gt;&gt; 16) &amp; 0xff;
  buffer[index + 3] = (size &gt;&gt; 24) &amp; 0xff;
  // Update index
  index = index + 4 + size - 1;
  // Write zero
  buffer[index++] = 0;
  return index;
}

var serializeCode = function(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined) {
  if(value.scope != null &amp;&amp; Object.keys(value.scope).length &gt; 0) {
    // Write the type
    buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
    // Number of written bytes
    var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
    // Encode the name
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;

    // Starting index
    var startIndex = index;

    // Serialize the function
    // Get the function string
    var functionString = typeof value.code == &#039;string&#039; ? value.code : value.code.toString();
    // Index adjustment
    index = index + 4;
    // Write string into buffer
    var codeSize = buffer.write(functionString, index + 4, &#039;utf8&#039;) + 1;
    // Write the size of the string to buffer
    buffer[index] = codeSize &amp; 0xff;
    buffer[index + 1] = (codeSize &gt;&gt; 8) &amp; 0xff;
    buffer[index + 2] = (codeSize &gt;&gt; 16) &amp; 0xff;
    buffer[index + 3] = (codeSize &gt;&gt; 24) &amp; 0xff;
    // Write end 0
    buffer[index + 4 + codeSize - 1] = 0;
    // Write the
    index = index + codeSize + 4;

    //
    // Serialize the scope value
    var endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined)
    index = endIndex - 1;

    // Writ the total
    var totalSize = endIndex - startIndex;

    // Write the total size of the object
    buffer[startIndex++] = totalSize &amp; 0xff;
    buffer[startIndex++] = (totalSize &gt;&gt; 8) &amp; 0xff;
    buffer[startIndex++] = (totalSize &gt;&gt; 16) &amp; 0xff;
    buffer[startIndex++] = (totalSize &gt;&gt; 24) &amp; 0xff;
    // Write trailing zero
    buffer[index++] = 0;
  } else {
    buffer[index++] = BSON.BSON_DATA_CODE;
    // Number of written bytes
    var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
    // Encode the name
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    // Function string
    var functionString = value.code.toString();
    // Write the string
    var size = buffer.write(functionString, index + 4, &#039;utf8&#039;) + 1;
    // Write the size of the string to buffer
    buffer[index] = size &amp; 0xff;
    buffer[index + 1] = (size &gt;&gt; 8) &amp; 0xff;
    buffer[index + 2] = (size &gt;&gt; 16) &amp; 0xff;
    buffer[index + 3] = (size &gt;&gt; 24) &amp; 0xff;
    // Update index
    index = index + 4 + size - 1;
    // Write zero
    buffer[index++] = 0;
  }

  return index;
}

var serializeBinary = function(buffer, key, value, index) {
  // Write the type
  buffer[index++] = BSON.BSON_DATA_BINARY;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Extract the buffer
  var data = value.value(true);
  // Calculate size
  var size = value.position;
  // Write the size of the string to buffer
  buffer[index++] = size &amp; 0xff;
  buffer[index++] = (size &gt;&gt; 8) &amp; 0xff;
  buffer[index++] = (size &gt;&gt; 16) &amp; 0xff;
  buffer[index++] = (size &gt;&gt; 24) &amp; 0xff;
  // Write the subtype to the buffer
  buffer[index++] = value.sub_type;

  // If we have binary type 2 the 4 first bytes are the size
  if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) {
    buffer[index++] = size &amp; 0xff;
    buffer[index++] = (size &gt;&gt; 8) &amp; 0xff;
    buffer[index++] = (size &gt;&gt; 16) &amp; 0xff;
    buffer[index++] = (size &gt;&gt; 24) &amp; 0xff;
  }

  // Write the data to the object
  data.copy(buffer, index, 0, value.position);
  // Adjust the index
  index = index + value.position;
  return index;
}

var serializeSymbol = function(buffer, key, value, index) {
  // Write the type
  buffer[index++] = BSON.BSON_DATA_SYMBOL;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Write the string
  var size = buffer.write(value.value, index + 4, &#039;utf8&#039;) + 1;
  // Write the size of the string to buffer
  buffer[index] = size &amp; 0xff;
  buffer[index + 1] = (size &gt;&gt; 8) &amp; 0xff;
  buffer[index + 2] = (size &gt;&gt; 16) &amp; 0xff;
  buffer[index + 3] = (size &gt;&gt; 24) &amp; 0xff;
  // Update index
  index = index + 4 + size - 1;
  // Write zero
  buffer[index++] = 0x00;
  return index;
}

var serializeDBRef = function(buffer, key, value, index, depth, serializeFunctions) {
  // Write the type
  buffer[index++] = BSON.BSON_DATA_OBJECT;
  // Number of written bytes
  var numberOfWrittenBytes = buffer.write(key, index, &#039;utf8&#039;);

  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;

  var startIndex = index;
  var endIndex;

  // Serialize object
  if(null != value.db) {
    endIndex = serializeInto(buffer, {
        &#039;$ref&#039;: value.namespace
      , &#039;$id&#039; : value.oid
      , &#039;$db&#039; : value.db
    }, false, index, depth + 1, serializeFunctions);
  } else {
    endIndex = serializeInto(buffer, {
        &#039;$ref&#039;: value.namespace
      , &#039;$id&#039; : value.oid
    }, false, index, depth + 1, serializeFunctions);
  }

  // Calculate object size
  var size = endIndex - startIndex;
  // Write the size
  buffer[startIndex++] = size &amp; 0xff;
  buffer[startIndex++] = (size &gt;&gt; 8) &amp; 0xff;
  buffer[startIndex++] = (size &gt;&gt; 16) &amp; 0xff;
  buffer[startIndex++] = (size &gt;&gt; 24) &amp; 0xff;
  // Set index
  return endIndex;
}

var serializeInto = function serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined) {
  startingIndex = startingIndex || 0;

  // Start place to serialize into
  var index = startingIndex + 4;
  var self = this;

  // Special case isArray
  if(Array.isArray(object)) {
    // Get object keys
    for(var i = 0; i &lt; object.length; i++) {
      var key = &quot;&quot; + i;
      var value = object[i];

      // Is there an override value
      if(value &amp;&amp; value.toBSON) {
        if(typeof value.toBSON != &#039;function&#039;) throw new Error(&quot;toBSON is not a function&quot;);
        value = value.toBSON();
      }

      var type = typeof value;
      if(type == &#039;string&#039;) {
        index = serializeString(buffer, key, value, index);
      } else if(type == &#039;number&#039;) {
        index = serializeNumber(buffer, key, value, index);
      } else if(type == &#039;boolean&#039;) {
        index = serializeBoolean(buffer, key, value, index);
      } else if(value instanceof Date || isDate(value)) {
        index = serializeDate(buffer, key, value, index);
      } else if(type == &#039;undefined&#039; || value == null) {
        index = serializeUndefined(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;ObjectID&#039;) {
        index = serializeObjectId(buffer, key, value, index);
      } else if(Buffer.isBuffer(value)) {
        index = serializeBuffer(buffer, key, value, index);
      } else if(value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer, key, value, index);
      } else if(type == &#039;object&#039; &amp;&amp; value[&#039;_bsontype&#039;] == null) {
        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
      } else if(value[&#039;_bsontype&#039;] == &#039;Long&#039; || value[&#039;_bsontype&#039;] == &#039;Timestamp&#039;) {
        index = serializeLong(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;Double&#039;) {
        index = serializeDouble(buffer, key, value, index);
      } else if(typeof value == &#039;function&#039; &amp;&amp; serializeFunctions) {
        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
      } else if(value[&#039;_bsontype&#039;] == &#039;Code&#039;) {
        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
      } else if(value[&#039;_bsontype&#039;] == &#039;Binary&#039;) {
        index = serializeBinary(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;Symbol&#039;) {
        index = serializeSymbol(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;DBRef&#039;) {
        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
      } else if(value[&#039;_bsontype&#039;] == &#039;BSONRegExp&#039;) {
        index = serializeBSONRegExp(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;MinKey&#039; || value[&#039;_bsontype&#039;] == &#039;MaxKey&#039;) {
        index = serializeMinMax(buffer, key, value, index);
      }
    }
  } else if(object instanceof Map) {
    var iterator = object.entries();
    var done = false;

    while(!done) {
      // Unpack the next entry
      var entry = iterator.next();
      done = entry.done;
      // Are we done, then skip and terminate
      if(done) continue;

      // Get the entry values
      var key = entry.value[0];
      var value = entry.value[1];

      // Check the type of the value
      var type = typeof value;

      // Check the key and throw error if it&#039;s illegal
      if(key != &#039;$db&#039; &amp;&amp; key != &#039;$ref&#039; &amp;&amp; key != &#039;$id&#039;) {
        if (key.match(regexp) != null) {
          // The BSON spec doesn&#039;t allow keys with null bytes because keys are
          // null-terminated.
          throw Error(&quot;key &quot; + key + &quot; must not contain null bytes&quot;);
        }

        if (checkKeys) {
          if(&#039;$&#039; == key[0]) {
            throw Error(&quot;key &quot; + key + &quot; must not start with &#039;$&#039;&quot;);
          } else if (!!~key.indexOf(&#039;.&#039;)) {
            throw Error(&quot;key &quot; + key + &quot; must not contain &#039;.&#039;&quot;);
          }
        }
      }

      // console.log(&quot;---------------------------------------------------&quot;)
      // console.dir(&quot;key = &quot; + key)
      // console.dir(&quot;value = &quot; + value)

      if(type == &#039;string&#039;) {
        index = serializeString(buffer, key, value, index);
      } else if(type == &#039;number&#039;) {
        index = serializeNumber(buffer, key, value, index);
      } else if(type == &#039;boolean&#039;) {
        index = serializeBoolean(buffer, key, value, index);
      } else if(value instanceof Date || isDate(value)) {
        index = serializeDate(buffer, key, value, index);
      } else if(value === undefined &amp;&amp; ignoreUndefined == true) {
      } else if(value === null || value === undefined) {
        index = serializeUndefined(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;ObjectID&#039;) {
        index = serializeObjectId(buffer, key, value, index);
      } else if(Buffer.isBuffer(value)) {
        index = serializeBuffer(buffer, key, value, index);
      } else if(value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer, key, value, index);
      } else if(type == &#039;object&#039; &amp;&amp; value[&#039;_bsontype&#039;] == null) {
        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
      } else if(value[&#039;_bsontype&#039;] == &#039;Long&#039; || value[&#039;_bsontype&#039;] == &#039;Timestamp&#039;) {
        index = serializeLong(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;Double&#039;) {
        index = serializeDouble(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;Code&#039;) {
        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
      } else if(typeof value == &#039;function&#039; &amp;&amp; serializeFunctions) {
        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
      } else if(value[&#039;_bsontype&#039;] == &#039;Binary&#039;) {
        index = serializeBinary(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;Symbol&#039;) {
        index = serializeSymbol(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;DBRef&#039;) {
        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
      } else if(value[&#039;_bsontype&#039;] == &#039;BSONRegExp&#039;) {
        index = serializeBSONRegExp(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;MinKey&#039; || value[&#039;_bsontype&#039;] == &#039;MaxKey&#039;) {
        index = serializeMinMax(buffer, key, value, index);
      }
    }
  } else {
    // Did we provide a custom serialization method
    if(object.toBSON) {
      if(typeof object.toBSON != &#039;function&#039;) throw new Error(&quot;toBSON is not a function&quot;);
      object = object.toBSON();
      if(object != null &amp;&amp; typeof object != &#039;object&#039;) throw new Error(&quot;toBSON function did not return an object&quot;);
    }

    // Iterate over all the keys
    for(var key in object) {
      var value = object[key];
      // Is there an override value
      if(value &amp;&amp; value.toBSON) {
        if(typeof value.toBSON != &#039;function&#039;) throw new Error(&quot;toBSON is not a function&quot;);
        value = value.toBSON();
      }

      // Check the type of the value
      var type = typeof value;

      // Check the key and throw error if it&#039;s illegal
      if(key != &#039;$db&#039; &amp;&amp; key != &#039;$ref&#039; &amp;&amp; key != &#039;$id&#039;) {
        if (key.match(regexp) != null) {
          // The BSON spec doesn&#039;t allow keys with null bytes because keys are
          // null-terminated.
          throw Error(&quot;key &quot; + key + &quot; must not contain null bytes&quot;);
        }

        if (checkKeys) {
          if(&#039;$&#039; == key[0]) {
            throw Error(&quot;key &quot; + key + &quot; must not start with &#039;$&#039;&quot;);
          } else if (!!~key.indexOf(&#039;.&#039;)) {
            throw Error(&quot;key &quot; + key + &quot; must not contain &#039;.&#039;&quot;);
          }
        }
      }

      if(type == &#039;string&#039;) {
        index = serializeString(buffer, key, value, index);
      } else if(type == &#039;number&#039;) {
        index = serializeNumber(buffer, key, value, index);
      } else if(type == &#039;boolean&#039;) {
        index = serializeBoolean(buffer, key, value, index);
      } else if(value instanceof Date || isDate(value)) {
        index = serializeDate(buffer, key, value, index);
      } else if(value === undefined &amp;&amp; ignoreUndefined == true) {
      } else if(value === null || value === undefined) {
        index = serializeUndefined(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;ObjectID&#039;) {
        index = serializeObjectId(buffer, key, value, index);
      } else if(Buffer.isBuffer(value)) {
        index = serializeBuffer(buffer, key, value, index);
      } else if(value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer, key, value, index);
      } else if(type == &#039;object&#039; &amp;&amp; value[&#039;_bsontype&#039;] == null) {
        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
      } else if(value[&#039;_bsontype&#039;] == &#039;Long&#039; || value[&#039;_bsontype&#039;] == &#039;Timestamp&#039;) {
        index = serializeLong(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;Double&#039;) {
        index = serializeDouble(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;Code&#039;) {
        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
      } else if(typeof value == &#039;function&#039; &amp;&amp; serializeFunctions) {
        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
      } else if(value[&#039;_bsontype&#039;] == &#039;Binary&#039;) {
        index = serializeBinary(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;Symbol&#039;) {
        index = serializeSymbol(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;DBRef&#039;) {
        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
      } else if(value[&#039;_bsontype&#039;] == &#039;BSONRegExp&#039;) {
        index = serializeBSONRegExp(buffer, key, value, index);
      } else if(value[&#039;_bsontype&#039;] == &#039;MinKey&#039; || value[&#039;_bsontype&#039;] == &#039;MaxKey&#039;) {
        index = serializeMinMax(buffer, key, value, index);
      }
    }
  }

  // Final padding byte for object
  buffer[index++] = 0x00;

  // Final size
  var size = index - startingIndex;
  // Write the size of the object
  buffer[startingIndex++] = size &amp; 0xff;
  buffer[startingIndex++] = (size &gt;&gt; 8) &amp; 0xff;
  buffer[startingIndex++] = (size &gt;&gt; 16) &amp; 0xff;
  buffer[startingIndex++] = (size &gt;&gt; 24) &amp; 0xff;
  return index;
}

var BSON = {};

/**
 * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5
 *
 * @ignore
 * @api private
 */
var functionCache = BSON.functionCache = {};

/**
 * Number BSON Type
 *
 * @classconstant BSON_DATA_NUMBER
 **/
BSON.BSON_DATA_NUMBER = 1;
/**
 * String BSON Type
 *
 * @classconstant BSON_DATA_STRING
 **/
BSON.BSON_DATA_STRING = 2;
/**
 * Object BSON Type
 *
 * @classconstant BSON_DATA_OBJECT
 **/
BSON.BSON_DATA_OBJECT = 3;
/**
 * Array BSON Type
 *
 * @classconstant BSON_DATA_ARRAY
 **/
BSON.BSON_DATA_ARRAY = 4;
/**
 * Binary BSON Type
 *
 * @classconstant BSON_DATA_BINARY
 **/
BSON.BSON_DATA_BINARY = 5;
/**
 * ObjectID BSON Type
 *
 * @classconstant BSON_DATA_OID
 **/
BSON.BSON_DATA_OID = 7;
/**
 * Boolean BSON Type
 *
 * @classconstant BSON_DATA_BOOLEAN
 **/
BSON.BSON_DATA_BOOLEAN = 8;
/**
 * Date BSON Type
 *
 * @classconstant BSON_DATA_DATE
 **/
BSON.BSON_DATA_DATE = 9;
/**
 * null BSON Type
 *
 * @classconstant BSON_DATA_NULL
 **/
BSON.BSON_DATA_NULL = 10;
/**
 * RegExp BSON Type
 *
 * @classconstant BSON_DATA_REGEXP
 **/
BSON.BSON_DATA_REGEXP = 11;
/**
 * Code BSON Type
 *
 * @classconstant BSON_DATA_CODE
 **/
BSON.BSON_DATA_CODE = 13;
/**
 * Symbol BSON Type
 *
 * @classconstant BSON_DATA_SYMBOL
 **/
BSON.BSON_DATA_SYMBOL = 14;
/**
 * Code with Scope BSON Type
 *
 * @classconstant BSON_DATA_CODE_W_SCOPE
 **/
BSON.BSON_DATA_CODE_W_SCOPE = 15;
/**
 * 32 bit Integer BSON Type
 *
 * @classconstant BSON_DATA_INT
 **/
BSON.BSON_DATA_INT = 16;
/**
 * Timestamp BSON Type
 *
 * @classconstant BSON_DATA_TIMESTAMP
 **/
BSON.BSON_DATA_TIMESTAMP = 17;
/**
 * Long BSON Type
 *
 * @classconstant BSON_DATA_LONG
 **/
BSON.BSON_DATA_LONG = 18;
/**
 * MinKey BSON Type
 *
 * @classconstant BSON_DATA_MIN_KEY
 **/
BSON.BSON_DATA_MIN_KEY = 0xff;
/**
 * MaxKey BSON Type
 *
 * @classconstant BSON_DATA_MAX_KEY
 **/
BSON.BSON_DATA_MAX_KEY = 0x7f;

/**
 * Binary Default Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
 **/
BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
/**
 * Binary Function Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
 **/
BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
/**
 * Binary Byte Array Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
 **/
BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
/**
 * Binary UUID Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_UUID
 **/
BSON.BSON_BINARY_SUBTYPE_UUID = 3;
/**
 * Binary MD5 Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_MD5
 **/
BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
/**
 * Binary User Defined Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
 **/
BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;

// BSON MAX VALUES
BSON.BSON_INT32_MAX = 0x7FFFFFFF;
BSON.BSON_INT32_MIN = -0x80000000;

BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
BSON.BSON_INT64_MIN = -Math.pow(2, 63);

// JS MAX PRECISE VALUES
BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.

// Internal long versions
var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);  // Any integer up to 2^53 can be precisely represented by a double.
var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);  // Any integer down to -2^53 can be precisely represented by a double.

module.exports = serializeInto;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
