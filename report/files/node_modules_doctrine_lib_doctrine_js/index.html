<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/doctrine/lib/doctrine.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/doctrine/lib/doctrine.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.28</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">897</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">99.95</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.96</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * @fileoverview Main Doctrine object
 * @author Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;
 * @author Dan Tao &lt;daniel.tao@gmail.com&gt;
 * @author Andrew Eisenberg &lt;andrew@eisenberg.as&gt;
 */

(function () {
    &#039;use strict&#039;;

    var typed,
        utility,
        isArray,
        jsdoc,
        esutils,
        hasOwnProperty;

    esutils = require(&#039;esutils&#039;);
    isArray = require(&#039;isarray&#039;);
    typed = require(&#039;./typed&#039;);
    utility = require(&#039;./utility&#039;);

    function sliceSource(source, index, last) {
        return source.slice(index, last);
    }

    hasOwnProperty = (function () {
        var func = Object.prototype.hasOwnProperty;
        return function hasOwnProperty(obj, name) {
            return func.call(obj, name);
        };
    }());

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }

    function isASCIIAlphanumeric(ch) {
        return (ch &gt;= 0x61  /* &#039;a&#039; */ &amp;&amp; ch &lt;= 0x7A  /* &#039;z&#039; */) ||
            (ch &gt;= 0x41  /* &#039;A&#039; */ &amp;&amp; ch &lt;= 0x5A  /* &#039;Z&#039; */) ||
            (ch &gt;= 0x30  /* &#039;0&#039; */ &amp;&amp; ch &lt;= 0x39  /* &#039;9&#039; */);
    }

    function isParamTitle(title) {
        return title === &#039;param&#039; || title === &#039;argument&#039; || title === &#039;arg&#039;;
    }

    function isReturnTitle(title) {
        return title === &#039;return&#039; || title === &#039;returns&#039;;
    }

    function isProperty(title) {
        return title === &#039;property&#039; || title === &#039;prop&#039;;
    }

    function isNameParameterRequired(title) {
        return isParamTitle(title) || isProperty(title) ||
            title === &#039;alias&#039; || title === &#039;this&#039; || title === &#039;mixes&#039; || title === &#039;requires&#039;;
    }

    function isAllowedName(title) {
        return isNameParameterRequired(title) || title === &#039;const&#039; || title === &#039;constant&#039;;
    }

    function isAllowedNested(title) {
        return isProperty(title) || isParamTitle(title);
    }

    function isAllowedOptional(title) {
        return isProperty(title) || isParamTitle(title);
    }

    function isTypeParameterRequired(title) {
        return isParamTitle(title) || isReturnTitle(title) ||
            title === &#039;define&#039; || title === &#039;enum&#039; ||
            title === &#039;implements&#039; || title === &#039;this&#039; ||
            title === &#039;type&#039; || title === &#039;typedef&#039; || isProperty(title);
    }

    // Consider deprecation instead using &#039;isTypeParameterRequired&#039; and &#039;Rules&#039; declaration to pick when a type is optional/required
    // This would require changes to &#039;parseType&#039;
    function isAllowedType(title) {
        return isTypeParameterRequired(title) || title === &#039;throws&#039; || title === &#039;const&#039; || title === &#039;constant&#039; ||
            title === &#039;namespace&#039; || title === &#039;member&#039; || title === &#039;var&#039; || title === &#039;module&#039; ||
            title === &#039;constructor&#039; || title === &#039;class&#039; || title === &#039;extends&#039; || title === &#039;augments&#039; ||
            title === &#039;public&#039; || title === &#039;private&#039; || title === &#039;protected&#039;;
    }

    function trim(str) {
        return str.replace(/^\s+/, &#039;&#039;).replace(/\s+$/, &#039;&#039;);
    }

    function unwrapComment(doc) {
        // JSDoc comment is following form
        //   /**
        //    * .......
        //    */
        // remove /**, */ and *
        var BEFORE_STAR = 0,
            STAR = 1,
            AFTER_STAR = 2,
            index,
            len,
            mode,
            result,
            ch;

        doc = doc.replace(/^\/\*\*?/, &#039;&#039;).replace(/\*\/$/, &#039;&#039;);
        index = 0;
        len = doc.length;
        mode = BEFORE_STAR;
        result = &#039;&#039;;

        while (index &lt; len) {
            ch = doc.charCodeAt(index);
            switch (mode) {
            case BEFORE_STAR:
                if (esutils.code.isLineTerminator(ch)) {
                    result += String.fromCharCode(ch);
                } else if (ch === 0x2A  /* &#039;*&#039; */) {
                    mode = STAR;
                } else if (!esutils.code.isWhiteSpace(ch)) {
                    result += String.fromCharCode(ch);
                    mode = AFTER_STAR;
                }
                break;

            case STAR:
                if (!esutils.code.isWhiteSpace(ch)) {
                    result += String.fromCharCode(ch);
                }
                mode = esutils.code.isLineTerminator(ch) ? BEFORE_STAR : AFTER_STAR;
                break;

            case AFTER_STAR:
                result += String.fromCharCode(ch);
                if (esutils.code.isLineTerminator(ch)) {
                    mode = BEFORE_STAR;
                }
                break;
            }
            index += 1;
        }

        return result.replace(/\s+$/, &#039;&#039;);
    }

    // JSDoc Tag Parser

    (function (exports) {
        var Rules,
            index,
            lineNumber,
            length,
            source,
            recoverable,
            sloppy,
            strict;

        function advance() {
            var ch = source.charCodeAt(index);
            index += 1;
            if (esutils.code.isLineTerminator(ch) &amp;&amp; !(ch === 0x0D  /* &#039;\r&#039; */ &amp;&amp; source.charCodeAt(index) === 0x0A  /* &#039;\n&#039; */)) {
                lineNumber += 1;
            }
            return String.fromCharCode(ch);
        }

        function scanTitle() {
            var title = &#039;&#039;;
            // waste &#039;@&#039;
            advance();

            while (index &lt; length &amp;&amp; isASCIIAlphanumeric(source.charCodeAt(index))) {
                title += advance();
            }

            return title;
        }

        function seekContent() {
            var ch, waiting, last = index;

            waiting = false;
            while (last &lt; length) {
                ch = source.charCodeAt(last);
                if (esutils.code.isLineTerminator(ch) &amp;&amp; !(ch === 0x0D  /* &#039;\r&#039; */ &amp;&amp; source.charCodeAt(last + 1) === 0x0A  /* &#039;\n&#039; */)) {
                    waiting = true;
                } else if (waiting) {
                    if (ch === 0x40  /* &#039;@&#039; */) {
                        break;
                    }
                    if (!esutils.code.isWhiteSpace(ch)) {
                        waiting = false;
                    }
                }
                last += 1;
            }
            return last;
        }

        // type expression may have nest brace, such as,
        // { { ok: string } }
        //
        // therefore, scanning type expression with balancing braces.
        function parseType(title, last) {
            var ch, brace, type, direct = false;


            // search &#039;{&#039;
            while (index &lt; last) {
                ch = source.charCodeAt(index);
                if (esutils.code.isWhiteSpace(ch)) {
                    advance();
                } else if (ch === 0x7B  /* &#039;{&#039; */) {
                    advance();
                    break;
                } else {
                    // this is direct pattern
                    direct = true;
                    break;
                }
            }


            if (direct) {
                return null;
            }

            // type expression { is found
            brace = 1;
            type = &#039;&#039;;
            while (index &lt; last) {
                ch = source.charCodeAt(index);
                if (esutils.code.isLineTerminator(ch)) {
                    advance();
                } else {
                    if (ch === 0x7D  /* &#039;}&#039; */) {
                        brace -= 1;
                        if (brace === 0) {
                            advance();
                            break;
                        }
                    } else if (ch === 0x7B  /* &#039;{&#039; */) {
                        brace += 1;
                    }
                    type += advance();
                }
            }

            if (brace !== 0) {
                // braces is not balanced
                return utility.throwError(&#039;Braces are not balanced&#039;);
            }

            if (isAllowedOptional(title)) {
                return typed.parseParamType(type);
            }

            return typed.parseType(type);
        }

        function scanIdentifier(last) {
            var identifier;
            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index))) {
                return null;
            }
            identifier = advance();
            while (index &lt; last &amp;&amp; esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {
                identifier += advance();
            }
            return identifier;
        }

        function skipWhiteSpace(last) {
            while (index &lt; last &amp;&amp; (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {
                advance();
            }
        }

        function parseName(last, allowBrackets, allowNestedParams) {
            var name = &#039;&#039;,
                useBrackets,
                insideString;


            skipWhiteSpace(last);

            if (index &gt;= last) {
                return null;
            }

            if (allowBrackets &amp;&amp; source.charCodeAt(index) === 0x5B  /* &#039;[&#039; */) {
                useBrackets = true;
                name = advance();
            }

            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index))) {
                return null;
            }

            name += scanIdentifier(last);

            if (allowNestedParams) {
                if (source.charCodeAt(index) === 0x3A /* &#039;:&#039; */ &amp;&amp; (
                        name === &#039;module&#039; ||
                        name === &#039;external&#039; ||
                        name === &#039;event&#039;)) {
                    name += advance();
                    name += scanIdentifier(last);

                }
                if(source.charCodeAt(index) === 0x5B  /* &#039;[&#039; */ &amp;&amp; source.charCodeAt(index + 1) === 0x5D  /* &#039;]&#039; */){
                    name += advance();
                    name += advance();
                }
                while (source.charCodeAt(index) === 0x2E  /* &#039;.&#039; */ ||
                        source.charCodeAt(index) === 0x2F  /* &#039;/&#039; */ ||
                        source.charCodeAt(index) === 0x23  /* &#039;#&#039; */ ||
                        source.charCodeAt(index) === 0x2D  /* &#039;-&#039; */ ||
                        source.charCodeAt(index) === 0x7E  /* &#039;~&#039; */) {
                    name += advance();
                    name += scanIdentifier(last);
                }
            }

            if (useBrackets) {
                skipWhiteSpace(last);
                // do we have a default value for this?
                if (source.charCodeAt(index) === 0x3D  /* &#039;=&#039; */) {
                    // consume the &#039;=&#039;&#039; symbol
                    name += advance();
                    skipWhiteSpace(last);

                    var ch;
                    var bracketDepth = 1;

                    // scan in the default value
                    while (index &lt; last) {
                        ch = source.charCodeAt(index);

                        if (esutils.code.isWhiteSpace(ch)) {
                            if (!insideString) {
                                skipWhiteSpace(last);
                                ch = source.charCodeAt(index);
                            }
                        }

                        if (ch === 0x27 /* &#039;&#039;&#039; */) {
                            if (!insideString) {
                                insideString = &#039;\&#039;&#039;;
                            } else {
                                if (insideString === &#039;\&#039;&#039;) {
                                    insideString = &#039;&#039;;
                                }
                            }
                        }

                        if (ch === 0x22 /* &#039;&quot;&#039; */) {
                            if (!insideString) {
                                insideString = &#039;&quot;&#039;;
                            } else {
                                if (insideString === &#039;&quot;&#039;) {
                                    insideString = &#039;&#039;;
                                }
                            }
                        }

                        if (ch === 0x5B /* &#039;[&#039; */) {
                            bracketDepth++;
                        } else if (ch === 0x5D  /* &#039;]&#039; */ &amp;&amp;
                            --bracketDepth === 0) {
                            break;
                        }

                        name += advance();
                    }
                }

                skipWhiteSpace(last);

                if (index &gt;= last || source.charCodeAt(index) !== 0x5D  /* &#039;]&#039; */) {
                    // we never found a closing &#039;]&#039;
                    return null;
                }

                // collect the last &#039;]&#039;
                name += advance();
            }

            return name;
        }

        function skipToTag() {
            while (index &lt; length &amp;&amp; source.charCodeAt(index) !== 0x40  /* &#039;@&#039; */) {
                advance();
            }
            if (index &gt;= length) {
                return false;
            }
            utility.assert(source.charCodeAt(index) === 0x40  /* &#039;@&#039; */);
            return true;
        }

        function TagParser(options, title) {
            this._options = options;
            this._title = title.toLowerCase();
            this._tag = {
                title: title,
                description: null
            };
            if (this._options.lineNumbers) {
                this._tag.lineNumber = lineNumber;
            }
            this._last = 0;
            // space to save special information for title parsers.
            this._extra = { };
        }

        // addError(err, ...)
        TagParser.prototype.addError = function addError(errorText) {
            var args = Array.prototype.slice.call(arguments, 1),
                msg = errorText.replace(
                    /%(\d)/g,
                    function (whole, index) {
                        utility.assert(index &lt; args.length, &#039;Message reference must be in range&#039;);
                        return args[index];
                    }
                );

            if (!this._tag.errors) {
                this._tag.errors = [];
            }
            if (strict) {
                utility.throwError(msg);
            }
            this._tag.errors.push(msg);
            return recoverable;
        };

        TagParser.prototype.parseType = function () {
            // type required titles
            if (isTypeParameterRequired(this._title)) {
                try {
                    this._tag.type = parseType(this._title, this._last);
                    if (!this._tag.type) {
                        if (!isParamTitle(this._title) &amp;&amp; !isReturnTitle(this._title)) {
                            if (!this.addError(&#039;Missing or invalid tag type&#039;)) {
                                return false;
                            }
                        }
                    }
                } catch (error) {
                    this._tag.type = null;
                    if (!this.addError(error.message)) {
                        return false;
                    }
                }
            } else if (isAllowedType(this._title)) {
                // optional types
                try {
                    this._tag.type = parseType(this._title, this._last);
                } catch (e) {
                    //For optional types, lets drop the thrown error when we hit the end of the file
                }
            }
            return true;
        };

        TagParser.prototype._parseNamePath = function (optional) {
            var name;
            name = parseName(this._last, sloppy &amp;&amp; isAllowedOptional(this._title), true);
            if (!name) {
                if (!optional) {
                    if (!this.addError(&#039;Missing or invalid tag name&#039;)) {
                        return false;
                    }
                }
            }
            this._tag.name = name;
            return true;
        };

        TagParser.prototype.parseNamePath = function () {
            return this._parseNamePath(false);
        };

        TagParser.prototype.parseNamePathOptional = function () {
            return this._parseNamePath(true);
        };


        TagParser.prototype.parseName = function () {
            var assign, name;

            // param, property requires name
            if (isAllowedName(this._title)) {
                this._tag.name = parseName(this._last, sloppy &amp;&amp; isAllowedOptional(this._title), isAllowedNested(this._title));
                if (!this._tag.name) {
                    if (!isNameParameterRequired(this._title)) {
                        return true;
                    }

                    // it&#039;s possible the name has already been parsed but interpreted as a type
                    // it&#039;s also possible this is a sloppy declaration, in which case it will be
                    // fixed at the end
                    if (isParamTitle(this._title) &amp;&amp; this._tag.type &amp;&amp; this._tag.type.name) {
                        this._extra.name = this._tag.type;
                        this._tag.name = this._tag.type.name;
                        this._tag.type = null;
                    } else {
                        if (!this.addError(&#039;Missing or invalid tag name&#039;)) {
                            return false;
                        }
                    }
                } else {
                    name = this._tag.name;
                    if (name.charAt(0) === &#039;[&#039; &amp;&amp; name.charAt(name.length - 1) === &#039;]&#039;) {
                        // extract the default value if there is one
                        // example: @param {string} [somebody=John Doe] description
                        assign = name.substring(1, name.length - 1).split(&#039;=&#039;);
                        if (assign[1]) {
                            this._tag[&#039;default&#039;] = assign[1];
                        }
                        this._tag.name = assign[0];

                        // convert to an optional type
                        if (this._tag.type &amp;&amp; this._tag.type.type !== &#039;OptionalType&#039;) {
                            this._tag.type = {
                                type: &#039;OptionalType&#039;,
                                expression: this._tag.type
                            };
                        }
                    }
                }
            }


            return true;
        };

        TagParser.prototype.parseDescription = function parseDescription() {
            var description = trim(sliceSource(source, index, this._last));
            if (description) {
                if ((/^-\s+/).test(description)) {
                    description = description.substring(2);
                }
                this._tag.description = description;
            }
            return true;
        };

        TagParser.prototype.parseCaption = function parseDescription() {
            var description = trim(sliceSource(source, index, this._last));
            var captionStartTag = &#039;&lt;caption&gt;&#039;;
            var captionEndTag = &#039;&lt;/caption&gt;&#039;;
            var captionStart = description.indexOf(captionStartTag);
            var captionEnd = description.indexOf(captionEndTag);
            if (captionStart &gt;= 0 &amp;&amp; captionEnd &gt;= 0) {
                this._tag.caption = trim(description.substring(
                    captionStart + captionStartTag.length, captionEnd));
                this._tag.description = trim(description.substring(captionEnd + captionEndTag.length));
            } else {
                this._tag.description = description;
            }
            return true;
        };

        TagParser.prototype.parseKind = function parseKind() {
            var kind, kinds;
            kinds = {
                &#039;class&#039;: true,
                &#039;constant&#039;: true,
                &#039;event&#039;: true,
                &#039;external&#039;: true,
                &#039;file&#039;: true,
                &#039;function&#039;: true,
                &#039;member&#039;: true,
                &#039;mixin&#039;: true,
                &#039;module&#039;: true,
                &#039;namespace&#039;: true,
                &#039;typedef&#039;: true
            };
            kind = trim(sliceSource(source, index, this._last));
            this._tag.kind = kind;
            if (!hasOwnProperty(kinds, kind)) {
                if (!this.addError(&#039;Invalid kind name \&#039;%0\&#039;&#039;, kind)) {
                    return false;
                }
            }
            return true;
        };

        TagParser.prototype.parseAccess = function parseAccess() {
            var access;
            access = trim(sliceSource(source, index, this._last));
            this._tag.access = access;
            if (access !== &#039;private&#039; &amp;&amp; access !== &#039;protected&#039; &amp;&amp; access !== &#039;public&#039;) {
                if (!this.addError(&#039;Invalid access name \&#039;%0\&#039;&#039;, access)) {
                    return false;
                }
            }
            return true;
        };

        TagParser.prototype.parseThis = function parseAccess() {
            // this name may be a name expression (e.g. {foo.bar})
            // or a name path (e.g. foo.bar)
            var value = trim(sliceSource(source, index, this._last));
            if (value &amp;&amp; value.charAt(0) === &#039;{&#039;) {
                var gotType = this.parseType();
                if (gotType &amp;&amp; this._tag.type.type === &#039;NameExpression&#039;) {
                    this._tag.name = this._tag.type.name;
                    return true;
                } else {
                    return this.addError(&#039;Invalid name for this&#039;);
                }
            } else {
                return this.parseNamePath();
            }
        };

        TagParser.prototype.parseVariation = function parseVariation() {
            var variation, text;
            text = trim(sliceSource(source, index, this._last));
            variation = parseFloat(text, 10);
            this._tag.variation = variation;
            if (isNaN(variation)) {
                if (!this.addError(&#039;Invalid variation \&#039;%0\&#039;&#039;, text)) {
                    return false;
                }
            }
            return true;
        };

        TagParser.prototype.ensureEnd = function () {
            var shouldBeEmpty = trim(sliceSource(source, index, this._last));
            if (shouldBeEmpty) {
                if (!this.addError(&#039;Unknown content \&#039;%0\&#039;&#039;, shouldBeEmpty)) {
                    return false;
                }
            }
            return true;
        };

        TagParser.prototype.epilogue = function epilogue() {
            var description;

            description = this._tag.description;
            // un-fix potentially sloppy declaration
            if (isAllowedOptional(this._title) &amp;&amp; !this._tag.type &amp;&amp; description &amp;&amp; description.charAt(0) === &#039;[&#039;) {
                this._tag.type = this._extra.name;
                if (!this._tag.name) {
                    this._tag.name = undefined;
                }

                if (!sloppy) {
                    if (!this.addError(&#039;Missing or invalid tag name&#039;)) {
                        return false;
                    }
                }
            }

            return true;
        };

        Rules = {
            // http://usejsdoc.org/tags-access.html
            &#039;access&#039;: [&#039;parseAccess&#039;],
            // http://usejsdoc.org/tags-alias.html
            &#039;alias&#039;: [&#039;parseNamePath&#039;, &#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-augments.html
            &#039;augments&#039;: [&#039;parseType&#039;, &#039;parseNamePathOptional&#039;, &#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-constructor.html
            &#039;constructor&#039;: [&#039;parseType&#039;, &#039;parseNamePathOptional&#039;, &#039;ensureEnd&#039;],
            // Synonym: http://usejsdoc.org/tags-constructor.html
            &#039;class&#039;: [&#039;parseType&#039;, &#039;parseNamePathOptional&#039;, &#039;ensureEnd&#039;],
            // Synonym: http://usejsdoc.org/tags-extends.html
            &#039;extends&#039;: [&#039;parseType&#039;, &#039;parseNamePathOptional&#039;, &#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-example.html
            &#039;example&#039;: [&#039;parseCaption&#039;],
            // http://usejsdoc.org/tags-deprecated.html
            &#039;deprecated&#039;: [&#039;parseDescription&#039;],
            // http://usejsdoc.org/tags-global.html
            &#039;global&#039;: [&#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-inner.html
            &#039;inner&#039;: [&#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-instance.html
            &#039;instance&#039;: [&#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-kind.html
            &#039;kind&#039;: [&#039;parseKind&#039;],
            // http://usejsdoc.org/tags-mixes.html
            &#039;mixes&#039;: [&#039;parseNamePath&#039;, &#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-mixin.html
            &#039;mixin&#039;: [&#039;parseNamePathOptional&#039;, &#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-member.html
            &#039;member&#039;: [&#039;parseType&#039;, &#039;parseNamePathOptional&#039;, &#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-method.html
            &#039;method&#039;: [&#039;parseNamePathOptional&#039;, &#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-module.html
            &#039;module&#039;: [&#039;parseType&#039;, &#039;parseNamePathOptional&#039;, &#039;ensureEnd&#039;],
            // Synonym: http://usejsdoc.org/tags-method.html
            &#039;func&#039;: [&#039;parseNamePathOptional&#039;, &#039;ensureEnd&#039;],
            // Synonym: http://usejsdoc.org/tags-method.html
            &#039;function&#039;: [&#039;parseNamePathOptional&#039;, &#039;ensureEnd&#039;],
            // Synonym: http://usejsdoc.org/tags-member.html
            &#039;var&#039;: [&#039;parseType&#039;, &#039;parseNamePathOptional&#039;, &#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-name.html
            &#039;name&#039;: [&#039;parseNamePath&#039;, &#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-namespace.html
            &#039;namespace&#039;: [&#039;parseType&#039;, &#039;parseNamePathOptional&#039;, &#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-private.html
            &#039;private&#039;: [&#039;parseType&#039;, &#039;parseDescription&#039;],
            // http://usejsdoc.org/tags-protected.html
            &#039;protected&#039;: [&#039;parseType&#039;, &#039;parseDescription&#039;],
            // http://usejsdoc.org/tags-public.html
            &#039;public&#039;: [&#039;parseType&#039;, &#039;parseDescription&#039;],
            // http://usejsdoc.org/tags-readonly.html
            &#039;readonly&#039;: [&#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-requires.html
            &#039;requires&#039;: [&#039;parseNamePath&#039;, &#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-since.html
            &#039;since&#039;: [&#039;parseDescription&#039;],
            // http://usejsdoc.org/tags-static.html
            &#039;static&#039;: [&#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-summary.html
            &#039;summary&#039;: [&#039;parseDescription&#039;],
            // http://usejsdoc.org/tags-this.html
            &#039;this&#039;: [&#039;parseThis&#039;, &#039;ensureEnd&#039;],
            // http://usejsdoc.org/tags-todo.html
            &#039;todo&#039;: [&#039;parseDescription&#039;],
            // http://usejsdoc.org/tags-typedef.html
            &#039;typedef&#039;: [&#039;parseType&#039;, &#039;parseNamePathOptional&#039;],
            // http://usejsdoc.org/tags-variation.html
            &#039;variation&#039;: [&#039;parseVariation&#039;],
            // http://usejsdoc.org/tags-version.html
            &#039;version&#039;: [&#039;parseDescription&#039;]
        };

        TagParser.prototype.parse = function parse() {
            var i, iz, sequences, method;


            // empty title
            if (!this._title) {
                if (!this.addError(&#039;Missing or invalid title&#039;)) {
                    return null;
                }
            }

            // Seek to content last index.
            this._last = seekContent(this._title);

            if (hasOwnProperty(Rules, this._title)) {
                sequences = Rules[this._title];
            } else {
                // default sequences
                sequences = [&#039;parseType&#039;, &#039;parseName&#039;, &#039;parseDescription&#039;, &#039;epilogue&#039;];
            }

            for (i = 0, iz = sequences.length; i &lt; iz; ++i) {
                method = sequences[i];
                if (!this[method]()) {
                    return null;
                }
            }

            return this._tag;
        };

        function parseTag(options) {
            var title, parser, tag;

            // skip to tag
            if (!skipToTag()) {
                return null;
            }

            // scan title
            title = scanTitle();

            // construct tag parser
            parser = new TagParser(options, title);
            tag = parser.parse();

            // Seek global index to end of this tag.
            while (index &lt; parser._last) {
                advance();
            }

            return tag;
        }

        //
        // Parse JSDoc
        //

        function scanJSDocDescription(preserveWhitespace) {
            var description = &#039;&#039;, ch, atAllowed;

            atAllowed = true;
            while (index &lt; length) {
                ch = source.charCodeAt(index);

                if (atAllowed &amp;&amp; ch === 0x40  /* &#039;@&#039; */) {
                    break;
                }

                if (esutils.code.isLineTerminator(ch)) {
                    atAllowed = true;
                } else if (atAllowed &amp;&amp; !esutils.code.isWhiteSpace(ch)) {
                    atAllowed = false;
                }

                description += advance();
            }

            return preserveWhitespace ? description : trim(description);
        }

        function parse(comment, options) {
            var tags = [], tag, description, interestingTags, i, iz;

            if (options === undefined) {
                options = {};
            }

            if (typeof options.unwrap === &#039;boolean&#039; &amp;&amp; options.unwrap) {
                source = unwrapComment(comment);
            } else {
                source = comment;
            }

            // array of relevant tags
            if (options.tags) {
                if (isArray(options.tags)) {
                    interestingTags = { };
                    for (i = 0, iz = options.tags.length; i &lt; iz; i++) {
                        if (typeof options.tags[i] === &#039;string&#039;) {
                            interestingTags[options.tags[i]] = true;
                        } else {
                            utility.throwError(&#039;Invalid &quot;tags&quot; parameter: &#039; + options.tags);
                        }
                    }
                } else {
                    utility.throwError(&#039;Invalid &quot;tags&quot; parameter: &#039; + options.tags);
                }
            }

            length = source.length;
            index = 0;
            lineNumber = 0;
            recoverable = options.recoverable;
            sloppy = options.sloppy;
            strict = options.strict;

            description = scanJSDocDescription(options.preserveWhitespace);

            while (true) {
                tag = parseTag(options);
                if (!tag) {
                    break;
                }
                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {
                    tags.push(tag);
                }
            }

            return {
                description: description,
                tags: tags
            };
        }
        exports.parse = parse;
    }(jsdoc = {}));

    exports.version = utility.VERSION;
    exports.parse = jsdoc.parse;
    exports.parseType = typed.parseType;
    exports.parseParamType = typed.parseParamType;
    exports.unwrapComment = unwrapComment;
    exports.Syntax = shallowCopy(typed.Syntax);
    exports.Error = utility.DoctrineError;
    exports.type = {
        Syntax: exports.Syntax,
        parseType: typed.parseType,
        parseParamType: typed.parseParamType,
        stringify: typed.stringify
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
