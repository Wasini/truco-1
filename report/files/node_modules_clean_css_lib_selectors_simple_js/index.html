<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/clean-css/lib/selectors/simple.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/clean-css/lib/selectors/simple.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.23</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">444</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">86.81</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.42</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var cleanUpSelectors = require(&#039;./clean-up&#039;).selectors;
var cleanUpBlock = require(&#039;./clean-up&#039;).block;
var cleanUpAtRule = require(&#039;./clean-up&#039;).atRule;
var split = require(&#039;../utils/split&#039;);

var RGB = require(&#039;../colors/rgb&#039;);
var HSL = require(&#039;../colors/hsl&#039;);
var HexNameShortener = require(&#039;../colors/hex-name-shortener&#039;);

var wrapForOptimizing = require(&#039;../properties/wrap-for-optimizing&#039;).all;
var restoreFromOptimizing = require(&#039;../properties/restore-from-optimizing&#039;);
var removeUnused = require(&#039;../properties/remove-unused&#039;);

var DEFAULT_ROUNDING_PRECISION = 2;
var CHARSET_TOKEN = &#039;@charset&#039;;
var CHARSET_REGEXP = new RegExp(&#039;^&#039; + CHARSET_TOKEN, &#039;i&#039;);

var FONT_NUMERAL_WEIGHTS = [&#039;100&#039;, &#039;200&#039;, &#039;300&#039;, &#039;400&#039;, &#039;500&#039;, &#039;600&#039;, &#039;700&#039;, &#039;800&#039;, &#039;900&#039;];
var FONT_NAME_WEIGHTS = [&#039;normal&#039;, &#039;bold&#039;, &#039;bolder&#039;, &#039;lighter&#039;];
var FONT_NAME_WEIGHTS_WITHOUT_NORMAL = [&#039;bold&#039;, &#039;bolder&#039;, &#039;lighter&#039;];

var WHOLE_PIXEL_VALUE = /(?:^|\s|\()(-?\d+)px/;
var TIME_VALUE = /^(\-?[\d\.]+)(m?s)$/;

var valueMinifiers = {
  &#039;background&#039;: function (value, index, total) {
    return index === 0 &amp;&amp; total == 1 &amp;&amp; (value == &#039;none&#039; || value == &#039;transparent&#039;) ? &#039;0 0&#039; : value;
  },
  &#039;font-weight&#039;: function (value) {
    if (value == &#039;normal&#039;)
      return &#039;400&#039;;
    else if (value == &#039;bold&#039;)
      return &#039;700&#039;;
    else
      return value;
  },
  &#039;outline&#039;: function (value, index, total) {
    return index === 0 &amp;&amp; total == 1 &amp;&amp; value == &#039;none&#039; ? &#039;0&#039; : value;
  }
};

function isNegative(property, idx) {
  return property.value[idx] &amp;&amp; property.value[idx][0][0] == &#039;-&#039; &amp;&amp; parseFloat(property.value[idx][0]) &lt; 0;
}

function zeroMinifier(name, value) {
  if (value.indexOf(&#039;0&#039;) == -1)
    return value;

  if (value.indexOf(&#039;-&#039;) &gt; -1) {
    value = value
      .replace(/([^\w\d\-]|^)\-0([^\.]|$)/g, &#039;$10$2&#039;)
      .replace(/([^\w\d\-]|^)\-0([^\.]|$)/g, &#039;$10$2&#039;);
  }

  return value
    .replace(/(^|\s)0+([1-9])/g, &#039;$1$2&#039;)
    .replace(/(^|\D)\.0+(\D|$)/g, &#039;$10$2&#039;)
    .replace(/(^|\D)\.0+(\D|$)/g, &#039;$10$2&#039;)
    .replace(/\.([1-9]*)0+(\D|$)/g, function (match, nonZeroPart, suffix) {
      return (nonZeroPart.length &gt; 0 ? &#039;.&#039; : &#039;&#039;) + nonZeroPart + suffix;
    })
    .replace(/(^|\D)0\.(\d)/g, &#039;$1.$2&#039;);
}

function zeroDegMinifier(_, value) {
  if (value.indexOf(&#039;0deg&#039;) == -1)
    return value;

  return value.replace(/\(0deg\)/g, &#039;(0)&#039;);
}

function whitespaceMinifier(name, value) {
  if (name.indexOf(&#039;filter&#039;) &gt; -1 || value.indexOf(&#039; &#039;) == -1)
    return value;

  value = value.replace(/\s+/g, &#039; &#039;);

  if (value.indexOf(&#039;calc&#039;) &gt; -1)
    value = value.replace(/\) ?\/ ?/g, &#039;)/ &#039;);

  return value
    .replace(/\( /g, &#039;(&#039;)
    .replace(/ \)/g, &#039;)&#039;)
    .replace(/, /g, &#039;,&#039;);
}

function precisionMinifier(_, value, precisionOptions) {
  if (precisionOptions.value === -1 || value.indexOf(&#039;.&#039;) === -1)
    return value;

  return value
    .replace(precisionOptions.regexp, function (match, number) {
      return Math.round(parseFloat(number) * precisionOptions.multiplier) / precisionOptions.multiplier + &#039;px&#039;;
    })
    .replace(/(\d)\.($|\D)/g, &#039;$1$2&#039;);
}

function unitMinifier(name, value, unitsRegexp) {
  if (/^(?:\-moz\-calc|\-webkit\-calc|calc)\(/.test(value))
    return value;

  if (name == &#039;flex&#039; || name == &#039;-ms-flex&#039; || name == &#039;-webkit-flex&#039; || name == &#039;flex-basis&#039; || name == &#039;-webkit-flex-basis&#039;)
    return value;

  if (value.indexOf(&#039;%&#039;) &gt; 0 &amp;&amp; (name == &#039;height&#039; || name == &#039;max-height&#039;))
    return value;

  return value
    .replace(unitsRegexp, &#039;$1&#039; + &#039;0&#039; + &#039;$2&#039;)
    .replace(unitsRegexp, &#039;$1&#039; + &#039;0&#039; + &#039;$2&#039;);
}

function multipleZerosMinifier(property) {
  var values = property.value;
  var spliceAt;

  if (values.length == 4 &amp;&amp; values[0][0] === &#039;0&#039; &amp;&amp; values[1][0] === &#039;0&#039; &amp;&amp; values[2][0] === &#039;0&#039; &amp;&amp; values[3][0] === &#039;0&#039;) {
    if (property.name.indexOf(&#039;box-shadow&#039;) &gt; -1)
      spliceAt = 2;
    else
      spliceAt = 1;
  }

  if (spliceAt) {
    property.value.splice(spliceAt);
    property.dirty = true;
  }
}

function colorMininifier(name, value, compatibility) {
  if (value.indexOf(&#039;#&#039;) === -1 &amp;&amp; value.indexOf(&#039;rgb&#039;) == -1 &amp;&amp; value.indexOf(&#039;hsl&#039;) == -1)
    return HexNameShortener.shorten(value);

  value = value
    .replace(/rgb\((\-?\d+),(\-?\d+),(\-?\d+)\)/g, function (match, red, green, blue) {
      return new RGB(red, green, blue).toHex();
    })
    .replace(/hsl\((-?\d+),(-?\d+)%?,(-?\d+)%?\)/g, function (match, hue, saturation, lightness) {
      return new HSL(hue, saturation, lightness).toHex();
    })
    .replace(/(^|[^=&#039;&quot;])#([0-9a-f]{6})/gi, function (match, prefix, color) {
      if (color[0] == color[1] &amp;&amp; color[2] == color[3] &amp;&amp; color[4] == color[5])
        return prefix + &#039;#&#039; + color[0] + color[2] + color[4];
      else
        return prefix + &#039;#&#039; + color;
    })
    .replace(/(rgb|rgba|hsl|hsla)\(([^\)]+)\)/g, function (match, colorFunction, colorDef) {
      var tokens = colorDef.split(&#039;,&#039;);
      var applies = (colorFunction == &#039;hsl&#039; &amp;&amp; tokens.length == 3) ||
        (colorFunction == &#039;hsla&#039; &amp;&amp; tokens.length == 4) ||
        (colorFunction == &#039;rgb&#039; &amp;&amp; tokens.length == 3 &amp;&amp; colorDef.indexOf(&#039;%&#039;) &gt; 0) ||
        (colorFunction == &#039;rgba&#039; &amp;&amp; tokens.length == 4 &amp;&amp; colorDef.indexOf(&#039;%&#039;) &gt; 0);
      if (!applies)
        return match;

      if (tokens[1].indexOf(&#039;%&#039;) == -1)
        tokens[1] += &#039;%&#039;;
      if (tokens[2].indexOf(&#039;%&#039;) == -1)
        tokens[2] += &#039;%&#039;;
      return colorFunction + &#039;(&#039; + tokens.join(&#039;,&#039;) + &#039;)&#039;;
    });

  if (compatibility.colors.opacity &amp;&amp; name.indexOf(&#039;background&#039;) == -1) {
    value = value.replace(/(?:rgba|hsla)\(0,0%?,0%?,0\)/g, function (match) {
      if (split(value, &#039;,&#039;).pop().indexOf(&#039;gradient(&#039;) &gt; -1)
        return match;

      return &#039;transparent&#039;;
    });
  }

  return HexNameShortener.shorten(value);
}

function pixelLengthMinifier(_, value, compatibility) {
  if (!WHOLE_PIXEL_VALUE.test(value))
    return value;

  return value.replace(WHOLE_PIXEL_VALUE, function (match, val) {
    var newValue;
    var intVal = parseInt(val);

    if (intVal === 0)
      return match;

    if (compatibility.properties.shorterLengthUnits &amp;&amp; compatibility.units.pt &amp;&amp; intVal * 3 % 4 === 0)
      newValue = intVal * 3 / 4 + &#039;pt&#039;;

    if (compatibility.properties.shorterLengthUnits &amp;&amp; compatibility.units.pc &amp;&amp; intVal % 16 === 0)
      newValue = intVal / 16 + &#039;pc&#039;;

    if (compatibility.properties.shorterLengthUnits &amp;&amp; compatibility.units.in &amp;&amp; intVal % 96 === 0)
      newValue = intVal / 96 + &#039;in&#039;;

    if (newValue)
      newValue = match.substring(0, match.indexOf(val)) + newValue;

    return newValue &amp;&amp; newValue.length &lt; match.length ? newValue : match;
  });
}

function timeUnitMinifier(_, value) {
  if (!TIME_VALUE.test(value))
    return value;

  return value.replace(TIME_VALUE, function (match, val, unit) {
    var newValue;

    if (unit == &#039;ms&#039;) {
      newValue = parseInt(val) / 1000 + &#039;s&#039;;
    } else if (unit == &#039;s&#039;) {
      newValue = parseFloat(val) * 1000 + &#039;ms&#039;;
    }

    return newValue.length &lt; match.length ? newValue : match;
  });
}

function minifyBorderRadius(property) {
  var values = property.value;
  var spliceAt;

  if (values.length == 3 &amp;&amp; values[1][0] == &#039;/&#039; &amp;&amp; values[0][0] == values[2][0])
    spliceAt = 1;
  else if (values.length == 5 &amp;&amp; values[2][0] == &#039;/&#039; &amp;&amp; values[0][0] == values[3][0] &amp;&amp; values[1][0] == values[4][0])
    spliceAt = 2;
  else if (values.length == 7 &amp;&amp; values[3][0] == &#039;/&#039; &amp;&amp; values[0][0] == values[4][0] &amp;&amp; values[1][0] == values[5][0] &amp;&amp; values[2][0] == values[6][0])
    spliceAt = 3;
  else if (values.length == 9 &amp;&amp; values[4][0] == &#039;/&#039; &amp;&amp; values[0][0] == values[5][0] &amp;&amp; values[1][0] == values[6][0] &amp;&amp; values[2][0] == values[7][0] &amp;&amp; values[3][0] == values[8][0])
    spliceAt = 4;

  if (spliceAt) {
    property.value.splice(spliceAt);
    property.dirty = true;
  }
}

function minifyFilter(property) {
  if (property.value.length == 1) {
    property.value[0][0] = property.value[0][0].replace(/progid:DXImageTransform\.Microsoft\.(Alpha|Chroma)(\W)/, function (match, filter, suffix) {
      return filter.toLowerCase() + suffix;
    });
  }

  property.value[0][0] = property.value[0][0]
    .replace(/,(\S)/g, &#039;, $1&#039;)
    .replace(/ ?= ?/g, &#039;=&#039;);
}

function minifyFont(property) {
  var values = property.value;
  var hasNumeral = FONT_NUMERAL_WEIGHTS.indexOf(values[0][0]) &gt; -1 ||
    values[1] &amp;&amp; FONT_NUMERAL_WEIGHTS.indexOf(values[1][0]) &gt; -1 ||
    values[2] &amp;&amp; FONT_NUMERAL_WEIGHTS.indexOf(values[2][0]) &gt; -1;

  if (hasNumeral)
    return;

  if (values[1] == &#039;/&#039;)
    return;

  var normalCount = 0;
  if (values[0][0] == &#039;normal&#039;)
    normalCount++;
  if (values[1] &amp;&amp; values[1][0] == &#039;normal&#039;)
    normalCount++;
  if (values[2] &amp;&amp; values[2][0] == &#039;normal&#039;)
    normalCount++;

  if (normalCount &gt; 1)
    return;

  var toOptimize;
  if (FONT_NAME_WEIGHTS_WITHOUT_NORMAL.indexOf(values[0][0]) &gt; -1)
    toOptimize = 0;
  else if (values[1] &amp;&amp; FONT_NAME_WEIGHTS_WITHOUT_NORMAL.indexOf(values[1][0]) &gt; -1)
    toOptimize = 1;
  else if (values[2] &amp;&amp; FONT_NAME_WEIGHTS_WITHOUT_NORMAL.indexOf(values[2][0]) &gt; -1)
    toOptimize = 2;
  else if (FONT_NAME_WEIGHTS.indexOf(values[0][0]) &gt; -1)
    toOptimize = 0;
  else if (values[1] &amp;&amp; FONT_NAME_WEIGHTS.indexOf(values[1][0]) &gt; -1)
    toOptimize = 1;
  else if (values[2] &amp;&amp; FONT_NAME_WEIGHTS.indexOf(values[2][0]) &gt; -1)
    toOptimize = 2;

  if (toOptimize !== undefined) {
    property.value[toOptimize][0] = valueMinifiers[&#039;font-weight&#039;](values[toOptimize][0]);
    property.dirty = true;
  }
}

function optimizeBody(properties, options) {
  var property, name, value;
  var _properties = wrapForOptimizing(properties);

  for (var i = 0, l = _properties.length; i &lt; l; i++) {
    property = _properties[i];
    name = property.name;

    if (property.hack &amp;&amp; (
        (property.hack == &#039;star&#039; || property.hack == &#039;underscore&#039;) &amp;&amp; !options.compatibility.properties.iePrefixHack ||
        property.hack == &#039;backslash&#039; &amp;&amp; !options.compatibility.properties.ieSuffixHack ||
        property.hack == &#039;bang&#039; &amp;&amp; !options.compatibility.properties.ieBangHack))
      property.unused = true;

    if (name.indexOf(&#039;padding&#039;) === 0 &amp;&amp; (isNegative(property, 0) || isNegative(property, 1) || isNegative(property, 2) || isNegative(property, 3)))
      property.unused = true;

    if (property.unused)
      continue;

    if (property.variable) {
      if (property.block)
        optimizeBody(property.value[0], options);
      continue;
    }

    for (var j = 0, m = property.value.length; j &lt; m; j++) {
      value = property.value[j][0];

      if (valueMinifiers[name])
        value = valueMinifiers[name](value, j, m);

      value = whitespaceMinifier(name, value);
      value = precisionMinifier(name, value, options.precision);
      value = pixelLengthMinifier(name, value, options.compatibility);
      value = timeUnitMinifier(name, value);
      value = zeroMinifier(name, value);
      if (options.compatibility.properties.zeroUnits) {
        value = zeroDegMinifier(name, value);
        value = unitMinifier(name, value, options.unitsRegexp);
      }
      if (options.compatibility.properties.colors)
        value = colorMininifier(name, value, options.compatibility);

      property.value[j][0] = value;
    }

    multipleZerosMinifier(property);

    if (name.indexOf(&#039;border&#039;) === 0 &amp;&amp; name.indexOf(&#039;radius&#039;) &gt; 0)
      minifyBorderRadius(property);
    else if (name == &#039;filter&#039;)
      minifyFilter(property);
    else if (name == &#039;font&#039;)
      minifyFont(property);
  }

  restoreFromOptimizing(_properties, true);
  removeUnused(_properties);
}

function cleanupCharsets(tokens) {
  var hasCharset = false;

  for (var i = 0, l = tokens.length; i &lt; l; i++) {
    var token = tokens[i];

    if (token[0] != &#039;at-rule&#039;)
      continue;

    if (!CHARSET_REGEXP.test(token[1][0]))
      continue;

    if (hasCharset || token[1][0].indexOf(CHARSET_TOKEN) == -1) {
      tokens.splice(i, 1);
      i--;
      l--;
    } else {
      hasCharset = true;
      tokens.splice(i, 1);
      tokens.unshift([&#039;at-rule&#039;, [token[1][0].replace(CHARSET_REGEXP, CHARSET_TOKEN)]]);
    }
  }
}

function buildUnitRegexp(options) {
  var units = [&#039;px&#039;, &#039;em&#039;, &#039;ex&#039;, &#039;cm&#039;, &#039;mm&#039;, &#039;in&#039;, &#039;pt&#039;, &#039;pc&#039;, &#039;%&#039;];
  var otherUnits = [&#039;ch&#039;, &#039;rem&#039;, &#039;vh&#039;, &#039;vm&#039;, &#039;vmax&#039;, &#039;vmin&#039;, &#039;vw&#039;];

  otherUnits.forEach(function (unit) {
    if (options.compatibility.units[unit])
      units.push(unit);
  });

  return new RegExp(&#039;(^|\\s|\\(|,)0(?:&#039; + units.join(&#039;|&#039;) + &#039;)(\\W|$)&#039;, &#039;g&#039;);
}

function buildPrecision(options) {
  var precision = {};

  precision.value = options.roundingPrecision === undefined ?
    DEFAULT_ROUNDING_PRECISION :
    options.roundingPrecision;
  precision.multiplier = Math.pow(10, precision.value);
  precision.regexp = new RegExp(&#039;(\\d*\\.\\d{&#039; + (precision.value + 1) + &#039;,})px&#039;, &#039;g&#039;);

  return precision;
}

function optimize(tokens, options) {
  var ie7Hack = options.compatibility.selectors.ie7Hack;
  var adjacentSpace = options.compatibility.selectors.adjacentSpace;
  var spaceAfterClosingBrace = options.compatibility.properties.spaceAfterClosingBrace;
  var mayHaveCharset = false;

  options.unitsRegexp = buildUnitRegexp(options);
  options.precision = buildPrecision(options);

  for (var i = 0, l = tokens.length; i &lt; l; i++) {
    var token = tokens[i];

    switch (token[0]) {
      case &#039;selector&#039;:
        token[1] = cleanUpSelectors(token[1], !ie7Hack, adjacentSpace);
        optimizeBody(token[2], options);
        break;
      case &#039;block&#039;:
        cleanUpBlock(token[1], spaceAfterClosingBrace);
        optimize(token[2], options);
        break;
      case &#039;flat-block&#039;:
        cleanUpBlock(token[1], spaceAfterClosingBrace);
        optimizeBody(token[2], options);
        break;
      case &#039;at-rule&#039;:
        cleanUpAtRule(token[1]);
        mayHaveCharset = true;
    }

    if (token[1].length === 0 || (token[2] &amp;&amp; token[2].length === 0)) {
      tokens.splice(i, 1);
      i--;
      l--;
    }
  }

  if (mayHaveCharset)
    cleanupCharsets(tokens);
}

module.exports = optimize;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
