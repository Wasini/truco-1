<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint/lib/config/autoconfig.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint/lib/config/autoconfig.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">73.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">372</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">66.60</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.93</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Used for creating a suggested configuration based on project code.
 * @author Ian VanSchooten
 */

&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

var lodash = require(&quot;lodash&quot;),
    debug = require(&quot;debug&quot;),
    eslint = require(&quot;../eslint&quot;),
    configRule = require(&quot;./config-rule&quot;),
    ConfigOps = require(&quot;./config-ops&quot;),
    recConfig = require(&quot;../../conf/eslint.json&quot;);

//------------------------------------------------------------------------------
// Data
//------------------------------------------------------------------------------

var MAX_CONFIG_COMBINATIONS = 17, // 16 combinations + 1 for severity only
    RECOMMENDED_CONFIG_NAME = &quot;eslint:recommended&quot;;

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

debug = debug(&quot;eslint:autoconfig&quot;);

/**
 * Information about a rule configuration, in the context of a Registry.
 *
 * @typedef {Object}     registryItem
 * @param   {ruleConfig} config        A valid configuration for the rule
 * @param   {number}     specificity   The number of elements in the ruleConfig array
 * @param   {number}     errorCount    The number of errors encountered when linting with the config
 */

 /**
  * This callback is used to measure execution status in a progress bar
  * @callback progressCallback
  * @param {number} The total number of times the callback will be called.
  */

/**
 * Create registryItems for rules
 * @param   {rulesConfig} rulesConfig Hash of rule names and arrays of ruleConfig items
 * @returns {Object}                  registryItems for each rule in provided rulesConfig
 */
function makeRegistryItems(rulesConfig) {
    return Object.keys(rulesConfig).reduce(function(accumulator, ruleId) {
        accumulator[ruleId] = rulesConfig[ruleId].map(function(config) {
            return {
                config: config,
                specificity: config.length || 1,
                errorCount: void 0
            };
        });
        return accumulator;
    }, {});
}

/**
* Creates an object in which to store rule configs and error counts
*
* Unless a rulesConfig is provided at construction, the registry will not contain
* any rules, only methods.  This will be useful for building up registries manually.
*
* @constructor
* @class   Registry
* @param   {rulesConfig} [rulesConfig] Hash of rule names and arrays of possible configurations
*/
function Registry(rulesConfig) {
    this.rules = (rulesConfig) ? makeRegistryItems(rulesConfig) : {};
}

Registry.prototype = {

    constructor: Registry,

    /**
     * Populate the registry with core rule configs.
     *
     * It will set the registry&#039;s `rule` property to an object having rule names
     * as keys and an array of registryItems as values.
     *
     * @returns {void}
     */
    populateFromCoreRules: function() {
        var rulesConfig = configRule.createCoreRuleConfigs();

        this.rules = makeRegistryItems(rulesConfig);
    },

    /**
     * Creates sets of rule configurations which can be used for linting
     * and initializes registry errors to zero for those configurations (side effect).
     *
     * This combines as many rules together as possible, such that the first sets
     * in the array will have the highest number of rules configured, and later sets
     * will have fewer and fewer, as not all rules have the same number of possible
     * configurations.
     *
     * The length of the returned array will be &lt;= MAX_CONFIG_COMBINATIONS.
     *
     * @param   {Object}   registry The autoconfig registry
     * @returns {Object[]}          &quot;rules&quot; configurations to use for linting
     */
    buildRuleSets: function() {
        var idx = 0,
            ruleIds = Object.keys(this.rules),
            ruleSets = [];

        /**
         * Add a rule configuration from the registry to the ruleSets
         *
         * This is broken out into its own function so that it doesn&#039;t need to be
         * created inside of the while loop.
         *
         * @param   {string} rule The ruleId to add.
         * @returns {void}
         */
        var addRuleToRuleSet = function(rule) {

            /*
             * This check ensures that there is a rule configuration and that
             * it has fewer than the max combinations allowed.
             * If it has too many configs, we will only use the most basic of
             * the possible configurations.
             */
            var hasFewCombos = (this.rules[rule].length &lt;= MAX_CONFIG_COMBINATIONS);

            if (this.rules[rule][idx] &amp;&amp; (hasFewCombos || this.rules[rule][idx].specificity &lt;= 2)) {

                /*
                 * If the rule has too many possible combinations, only take
                 * simple ones, avoiding objects.
                 */
                if (!hasFewCombos &amp;&amp; typeof this.rules[rule][idx].config[1] === &quot;object&quot;) {
                    return;
                }

                ruleSets[idx] = ruleSets[idx] || {};
                ruleSets[idx][rule] = this.rules[rule][idx].config;

                /*
                 * Initialize errorCount to zero, since this is a config which
                 * will be linted.
                 */
                this.rules[rule][idx].errorCount = 0;
            }
        }.bind(this);

        while (ruleSets.length === idx) {
            ruleIds.forEach(addRuleToRuleSet);
            idx += 1;
        }

        return ruleSets;
    },

    /**
     * Remove all items from the registry with a non-zero number of errors
     *
     * Note: this also removes rule configurations which were not linted
     * (meaning, they have an undefined errorCount).
     *
     * @returns {void}
     */
    stripFailingConfigs: function() {
        var ruleIds = Object.keys(this.rules),
            newRegistry = new Registry();

        newRegistry.rules = lodash.assign({}, this.rules);
        ruleIds.forEach(function(ruleId) {
            var errorFreeItems = newRegistry.rules[ruleId].filter(function(registryItem) {
                return (registryItem.errorCount === 0);
            });

            if (errorFreeItems.length &gt; 0) {
                newRegistry.rules[ruleId] = errorFreeItems;
            } else {
                delete newRegistry.rules[ruleId];
            }
        });

        return newRegistry;
    },

    /**
     * Removes rule configurations which were not included in a ruleSet
     *
     * @returns {void}
     */
    stripExtraConfigs: function() {
        var ruleIds = Object.keys(this.rules),
            newRegistry = new Registry();

        newRegistry.rules = lodash.assign({}, this.rules);
        ruleIds.forEach(function(ruleId) {
            newRegistry.rules[ruleId] = newRegistry.rules[ruleId].filter(function(registryItem) {
                return (typeof registryItem.errorCount !== &quot;undefined&quot;);
            });
        });

        return newRegistry;
    },

    /**
     * Creates a registry of rules which had no error-free configs.
     * The new registry is intended to be analyzed to determine whether its rules
     * should be disabled or set to warning.
     *
     * @returns {Registry}  A registry of failing rules.
     */
    getFailingRulesRegistry: function() {
        var ruleIds = Object.keys(this.rules),
            failingRegistry = new Registry();

        ruleIds.forEach(function(ruleId) {
            var failingConfigs = this.rules[ruleId].filter(function(registryItem) {
                return (registryItem.errorCount &gt; 0);
            });

            if (failingConfigs &amp;&amp; failingConfigs.length === this.rules[ruleId].length) {
                failingRegistry.rules[ruleId] = failingConfigs;
            }
        }.bind(this));

        return failingRegistry;
    },

    /**
     * Create an eslint config for any rules which only have one configuration
     * in the registry.
     *
     * @returns {Object} An eslint config with rules section populated
     */
    createConfig: function() {
        var ruleIds = Object.keys(this.rules),
            config = {rules: {}};

        ruleIds.forEach(function(ruleId) {
            if (this.rules[ruleId].length === 1) {
                config.rules[ruleId] = this.rules[ruleId][0].config;
            }
        }.bind(this));

        return config;
    },

    /**
     * Return a cloned registry containing only configs with a desired specificity
     *
     * @param   {number} specificity Only keep configs with this specificity
     * @returns {Registry}           A registry of rules
     */
    filterBySpecificity: function(specificity) {
        var ruleIds = Object.keys(this.rules),
            newRegistry = new Registry();

        newRegistry.rules = lodash.assign({}, this.rules);
        ruleIds.forEach(function(ruleId) {
            newRegistry.rules[ruleId] = this.rules[ruleId].filter(function(registryItem) {
                return (registryItem.specificity === specificity);
            });
        }.bind(this));

        return newRegistry;
    },

    /**
     * Lint SourceCodes against all configurations in the registry, and record results
     *
     * @param   {Object[]} sourceCodes  SourceCode objects for each filename
     * @param   {Object}   config       ESLint config object
     * @param   {progressCallback} [cb] Optional callback for reporting execution status
     * @returns {Registry}              New registry with errorCount populated
     */
    lintSourceCode: function(sourceCodes, config, cb) {
        var totalFilesLinting,
            lintConfig,
            ruleSets,
            ruleSetIdx,
            filenames,
            lintedRegistry;

        lintedRegistry = new Registry();
        lintedRegistry.rules = lodash.assign({}, this.rules);

        ruleSets = lintedRegistry.buildRuleSets();

        lintedRegistry = lintedRegistry.stripExtraConfigs();

        debug(&quot;Linting with all possible rule combinations&quot;);

        filenames = Object.keys(sourceCodes);

        totalFilesLinting = filenames.length * ruleSets.length;

        filenames.forEach(function(filename) {
            debug(&quot;Linting file: &quot; + filename);

            ruleSetIdx = 0;

            ruleSets.forEach(function(ruleSet) {
                lintConfig = lodash.assign({}, config, {rules: ruleSet});
                var lintResults = eslint.verify(sourceCodes[filename], lintConfig);

                lintResults.forEach(function(result) {

                    // It is possible that the error is from a configuration comment
                    // in a linted file, in which case there may not be a config
                    // set in this ruleSetIdx. (https://github.com/eslint/eslint/issues/5992)
                    if (lintedRegistry.rules[result.ruleId][ruleSetIdx]) {
                        lintedRegistry.rules[result.ruleId][ruleSetIdx].errorCount += 1;
                    }
                });

                ruleSetIdx += 1;

                if (cb) {
                    cb(totalFilesLinting);  // eslint-disable-line callback-return
                }
            });

            // Deallocate for GC
            sourceCodes[filename] = null;
        });

        return lintedRegistry;
    }
};

/**
 * Extract rule configuration into eslint:recommended where possible.
 *
 * This will return a new config with `&quot;extends&quot;: &quot;eslint:recommended&quot;` and
 * only the rules which have configurations different from the recommended config.
 *
 * @param   {Object} config config object
 * @returns {Object}        config object using `&quot;extends&quot;: &quot;eslint:recommended&quot;`
 */
function extendFromRecommended(config) {
    var newConfig = lodash.assign({}, config);

    ConfigOps.normalizeToStrings(newConfig);

    var recRules = Object.keys(recConfig.rules).filter(function(ruleId) {
        return ConfigOps.isErrorSeverity(recConfig.rules[ruleId]);
    });

    recRules.forEach(function(ruleId) {
        if (lodash.isEqual(recConfig.rules[ruleId], newConfig.rules[ruleId])) {
            delete newConfig.rules[ruleId];
        }
    });
    newConfig.extends = RECOMMENDED_CONFIG_NAME;
    return newConfig;
}


//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = {
    Registry: Registry,
    extendFromRecommended: extendFromRecommended
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
