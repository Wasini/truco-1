<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/bson/lib/bson/parser/deserializer.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/bson/lib/bson/parser/deserializer.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">35.43</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">531</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">106.59</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.77</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;

var readIEEE754 = require(&#039;../float_parser&#039;).readIEEE754,
	f = require(&#039;util&#039;).format,
	Long = require(&#039;../long&#039;).Long,
  Double = require(&#039;../double&#039;).Double,
  Timestamp = require(&#039;../timestamp&#039;).Timestamp,
  ObjectID = require(&#039;../objectid&#039;).ObjectID,
  Symbol = require(&#039;../symbol&#039;).Symbol,
  Code = require(&#039;../code&#039;).Code,
  MinKey = require(&#039;../min_key&#039;).MinKey,
  MaxKey = require(&#039;../max_key&#039;).MaxKey,
  DBRef = require(&#039;../db_ref&#039;).DBRef,
  BSONRegExp = require(&#039;../regexp&#039;).BSONRegExp,
  Binary = require(&#039;../binary&#039;).Binary;

var deserialize = function(buffer, options, isArray) {
	options = options == null ? {} : options;
	var index = options &amp;&amp; options.index ? options.index : 0;
	// Read the document size
  var size = buffer[index] | buffer[index+1] &lt;&lt; 8 | buffer[index+2] &lt;&lt; 16 | buffer[index+3] &lt;&lt; 24;

	// Ensure buffer is valid size
  if(size &lt; 5 || buffer.length &lt; size) {
		throw new Error(&quot;corrupt bson message&quot;);
	}

	// Illegal end value
	if(buffer[index + size - 1] != 0) {
		throw new Error(&quot;One object, sized correctly, with a spot for an EOO, but the EOO isn&#039;t 0x00&quot;);
	}

	// Start deserializtion
	return deserializeObject(buffer, index, options, isArray);
}

var deserializeObject = function(buffer, index, options, isArray) {
	var evalFunctions = options[&#039;evalFunctions&#039;] == null ? false : options[&#039;evalFunctions&#039;];
  var cacheFunctions = options[&#039;cacheFunctions&#039;] == null ? false : options[&#039;cacheFunctions&#039;];
  var cacheFunctionsCrc32 = options[&#039;cacheFunctionsCrc32&#039;] == null ? false : options[&#039;cacheFunctionsCrc32&#039;];
  var promoteLongs = options[&#039;promoteLongs&#039;] == null ? true : options[&#039;promoteLongs&#039;];
	var fieldsAsRaw = options[&#039;fieldsAsRaw&#039;] == null ? null : options[&#039;fieldsAsRaw&#039;];
	var raw = options[&#039;raw&#039;] == null ? false : options[&#039;raw&#039;];
  // Return BSONRegExp objects instead of native regular expressions
  var bsonRegExp = typeof options[&#039;bsonRegExp&#039;] == &#039;boolean&#039; ? options[&#039;bsonRegExp&#039;] : false;
  var promoteBuffers = options[&#039;promoteBuffers&#039;] == null ? false : options[&#039;promoteBuffers&#039;];

  // Validate that we have at least 4 bytes of buffer
  if(buffer.length &lt; 5) throw new Error(&quot;corrupt bson message &lt; 5 bytes long&quot;);

	// Read the document size
  var size = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;

	// Ensure buffer is valid size
  if(size &lt; 5 || size &gt; buffer.length) throw new Error(&quot;corrupt bson message&quot;);

  // Create holding object
  var object = isArray ? [] : {};

  // While we have more left data left keep parsing
  while(true) {
    // Read the type
    var elementType = buffer[index++];
    // If we get a zero it&#039;s the last byte, exit
    if(elementType == 0) break;

		// Get the start search index
		var i = index;
		// Locate the end of the c string
		while(buffer[i] !== 0x00 &amp;&amp; i &lt; buffer.length) {
			i++
		}

		// If are at the end of the buffer there is a problem with the document
		if(i &gt;= buffer.length) throw new Error(&quot;Bad BSON Document: illegal CString&quot;)
		var name = buffer.toString(&#039;utf8&#039;, index, i);

		index = i + 1;

		if(elementType == BSON.BSON_DATA_STRING) {
      var stringSize = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
			if(stringSize &lt;= 0 || stringSize &gt; (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error(&quot;bad string length in bson&quot;);
      object[name] = buffer.toString(&#039;utf8&#039;, index, index + stringSize - 1);
      index = index + stringSize;
		} else if(elementType == BSON.BSON_DATA_OID) {
      var string = buffer.toString(&#039;binary&#039;, index, index + 12);
      object[name] = new ObjectID(string);
      index = index + 12;
		} else if(elementType == BSON.BSON_DATA_INT) {
      object[name] = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
		} else if(elementType == BSON.BSON_DATA_NUMBER) {
			object[name] = buffer.readDoubleLE(index);
      index = index + 8;
		} else if(elementType == BSON.BSON_DATA_DATE) {
      var lowBits = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
      var highBits = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
      object[name] = new Date(new Long(lowBits, highBits).toNumber());
		} else if(elementType == BSON.BSON_DATA_BOOLEAN) {
      object[name] = buffer[index++] == 1;
		} else if(elementType == BSON.BSON_DATA_OBJECT) {
			var _index = index;
      var objectSize = buffer[index] | buffer[index + 1] &lt;&lt; 8 | buffer[index + 2] &lt;&lt; 16 | buffer[index + 3] &lt;&lt; 24;
			if(objectSize &lt;= 0 || objectSize &gt; (buffer.length - index)) throw new Error(&quot;bad embedded document length in bson&quot;);

			// We have a raw value
			if(raw) {
	      object[name] = buffer.slice(index, index + objectSize);
			} else {
	      object[name] = deserializeObject(buffer, _index, options, false);
			}

      index = index + objectSize;
		} else if(elementType == BSON.BSON_DATA_ARRAY) {
			var _index = index;
      var objectSize = buffer[index] | buffer[index + 1] &lt;&lt; 8 | buffer[index + 2] &lt;&lt; 16 | buffer[index + 3] &lt;&lt; 24;
			var arrayOptions = options;

			// All elements of array to be returned as raw bson
			if(fieldsAsRaw &amp;&amp; fieldsAsRaw[name]) {
				arrayOptions = {};
				for(var n in options) arrayOptions[n] = options[n];
				arrayOptions[&#039;raw&#039;] = true;
			}

      object[name] = deserializeObject(buffer, _index, arrayOptions, true);
      index = index + objectSize;
		} else if(elementType == BSON.BSON_DATA_UNDEFINED || elementType == BSON.BSON_DATA_NULL) {
      object[name] = null;
		} else if(elementType == BSON.BSON_DATA_LONG) {
      // Unpack the low and high bits
      var lowBits = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
      var highBits = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
      var long = new Long(lowBits, highBits);
      // Promote the long if possible
      if(promoteLongs) {
        object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) &amp;&amp; long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
      } else {
        object[name] = long;
      }
		} else if(elementType == BSON.BSON_DATA_BINARY) {
      var binarySize = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
      var subType = buffer[index++];
      // Decode as raw Buffer object if options specifies it
      if(buffer[&#039;slice&#039;] != null) {
        // If we have subtype 2 skip the 4 bytes for the size
        if(subType == Binary.SUBTYPE_BYTE_ARRAY) {
          binarySize = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
        }
        if(promoteBuffers) {
          object[name] = buffer.slice(index, index + binarySize);
        } else {
          object[name] = new Binary(buffer.slice(index, index + binarySize), subType);
        }
      } else {
        var _buffer = typeof Uint8Array != &#039;undefined&#039; ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
        // If we have subtype 2 skip the 4 bytes for the size
        if(subType == Binary.SUBTYPE_BYTE_ARRAY) {
          binarySize = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
        }
        // Copy the data
        for(var i = 0; i &lt; binarySize; i++) {
          _buffer[i] = buffer[index + i];
        }
        if(promoteBuffers) {
          object[name] = _buffer;
        } else {
          object[name] = new Binary(_buffer, subType);
        }
      }
      // Update the index
      index = index + binarySize;
		} else if(elementType == BSON.BSON_DATA_REGEXP &amp;&amp; bsonRegExp == false) {
			// Get the start search index
			var i = index;
			// Locate the end of the c string
			while(buffer[i] !== 0x00 &amp;&amp; i &lt; buffer.length) {
				i++
			}
			// If are at the end of the buffer there is a problem with the document
			if(i &gt;= buffer.length) throw new Error(&quot;Bad BSON Document: illegal CString&quot;)
			// Return the C string
			var source = buffer.toString(&#039;utf8&#039;, index, i);
      // Create the regexp
			index = i + 1;

			// Get the start search index
			var i = index;
			// Locate the end of the c string
			while(buffer[i] !== 0x00 &amp;&amp; i &lt; buffer.length) {
				i++
			}
			// If are at the end of the buffer there is a problem with the document
			if(i &gt;= buffer.length) throw new Error(&quot;Bad BSON Document: illegal CString&quot;)
			// Return the C string
			var regExpOptions = buffer.toString(&#039;utf8&#039;, index, i);
			index = i + 1;

      // For each option add the corresponding one for javascript
      var optionsArray = new Array(regExpOptions.length);

      // Parse options
      for(var i = 0; i &lt; regExpOptions.length; i++) {
        switch(regExpOptions[i]) {
          case &#039;m&#039;:
            optionsArray[i] = &#039;m&#039;;
            break;
          case &#039;s&#039;:
            optionsArray[i] = &#039;g&#039;;
            break;
          case &#039;i&#039;:
            optionsArray[i] = &#039;i&#039;;
            break;
        }
      }

      object[name] = new RegExp(source, optionsArray.join(&#039;&#039;));
    } else if(elementType == BSON.BSON_DATA_REGEXP &amp;&amp; bsonRegExp == true) {
			// Get the start search index
			var i = index;
			// Locate the end of the c string
			while(buffer[i] !== 0x00 &amp;&amp; i &lt; buffer.length) {
				i++
			}
			// If are at the end of the buffer there is a problem with the document
			if(i &gt;= buffer.length) throw new Error(&quot;Bad BSON Document: illegal CString&quot;)
			// Return the C string
			var source = buffer.toString(&#039;utf8&#039;, index, i);
      index = i + 1;

			// Get the start search index
			var i = index;
			// Locate the end of the c string
			while(buffer[i] !== 0x00 &amp;&amp; i &lt; buffer.length) {
				i++
			}
			// If are at the end of the buffer there is a problem with the document
			if(i &gt;= buffer.length) throw new Error(&quot;Bad BSON Document: illegal CString&quot;)
			// Return the C string
			var regExpOptions = buffer.toString(&#039;utf8&#039;, index, i);
      index = i + 1;

      // Set the object
      object[name] = new BSONRegExp(source, regExpOptions);
		} else if(elementType == BSON.BSON_DATA_SYMBOL) {
      var stringSize = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
			if(stringSize &lt;= 0 || stringSize &gt; (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error(&quot;bad string length in bson&quot;);
      object[name] = new Symbol(buffer.toString(&#039;utf8&#039;, index, index + stringSize - 1));
      index = index + stringSize;
		} else if(elementType == BSON.BSON_DATA_TIMESTAMP) {
      var lowBits = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
      var highBits = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
      object[name] = new Timestamp(lowBits, highBits);
		} else if(elementType == BSON.BSON_DATA_MIN_KEY) {
      object[name] = new MinKey();
		} else if(elementType == BSON.BSON_DATA_MAX_KEY) {
      object[name] = new MaxKey();
		} else if(elementType == BSON.BSON_DATA_CODE) {
      var stringSize = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
			if(stringSize &lt;= 0 || stringSize &gt; (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error(&quot;bad string length in bson&quot;);
      var functionString = buffer.toString(&#039;utf8&#039;, index, index + stringSize - 1);

      // If we are evaluating the functions
      if(evalFunctions) {
        var value = null;
        // If we have cache enabled let&#039;s look for the md5 of the function in the cache
        if(cacheFunctions) {
          var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
          // Got to do this to avoid V8 deoptimizing the call due to finding eval
          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
        } else {
          object[name] = isolateEval(functionString);
        }
      } else {
        object[name]  = new Code(functionString, {});
      }

      // Update parse index position
      index = index + stringSize;
		} else if(elementType == BSON.BSON_DATA_CODE_W_SCOPE) {
      var totalSize = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
      var stringSize = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
			if(stringSize &lt;= 0 || stringSize &gt; (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error(&quot;bad string length in bson&quot;);
      // Javascript function
      var functionString = buffer.toString(&#039;utf8&#039;, index, index + stringSize - 1);
      // Update parse index position
      index = index + stringSize;
      // Parse the element
			var _index = index;
      // Decode the size of the object document
      var objectSize = buffer[index] | buffer[index + 1] &lt;&lt; 8 | buffer[index + 2] &lt;&lt; 16 | buffer[index + 3] &lt;&lt; 24;
      // Decode the scope object
      var scopeObject = deserializeObject(buffer, _index, options, false);
      // Adjust the index
      index = index + objectSize;

      // If we are evaluating the functions
      if(evalFunctions) {
        // Contains the value we are going to set
        var value = null;
        // If we have cache enabled let&#039;s look for the md5 of the function in the cache
        if(cacheFunctions) {
          var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
          // Got to do this to avoid V8 deoptimizing the call due to finding eval
          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
        } else {
          object[name] = isolateEval(functionString);
        }

        object[name].scope = scopeObject;
      } else {
        object[name]  = new Code(functionString, scopeObject);
      }
    }
  }

  // Check if we have a db ref object
  if(object[&#039;$id&#039;] != null) object = new DBRef(object[&#039;$ref&#039;], object[&#039;$id&#039;], object[&#039;$db&#039;]);
  return object;
}

/**
 * Ensure eval is isolated.
 *
 * @ignore
 * @api private
 */
var isolateEvalWithHash = function(functionCache, hash, functionString, object) {
  // Contains the value we are going to set
  var value = null;

  // Check for cache hit, eval if missing and return cached function
  if(functionCache[hash] == null) {
    eval(&quot;value = &quot; + functionString);
    functionCache[hash] = value;
  }
  // Set the object
  return functionCache[hash].bind(object);
}

/**
 * Ensure eval is isolated.
 *
 * @ignore
 * @api private
 */
var isolateEval = function(functionString) {
  // Contains the value we are going to set
  var value = null;
  // Eval the function
  eval(&quot;value = &quot; + functionString);
  return value;
}

var BSON = {};

/**
 * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5
 *
 * @ignore
 * @api private
 */
var functionCache = BSON.functionCache = {};

/**
 * Number BSON Type
 *
 * @classconstant BSON_DATA_NUMBER
 **/
BSON.BSON_DATA_NUMBER = 1;
/**
 * String BSON Type
 *
 * @classconstant BSON_DATA_STRING
 **/
BSON.BSON_DATA_STRING = 2;
/**
 * Object BSON Type
 *
 * @classconstant BSON_DATA_OBJECT
 **/
BSON.BSON_DATA_OBJECT = 3;
/**
 * Array BSON Type
 *
 * @classconstant BSON_DATA_ARRAY
 **/
BSON.BSON_DATA_ARRAY = 4;
/**
 * Binary BSON Type
 *
 * @classconstant BSON_DATA_BINARY
 **/
BSON.BSON_DATA_BINARY = 5;
/**
 * Binary BSON Type
 *
 * @classconstant BSON_DATA_UNDEFINED
 **/
BSON.BSON_DATA_UNDEFINED = 7;
/**
 * ObjectID BSON Type
 *
 * @classconstant BSON_DATA_OID
 **/
BSON.BSON_DATA_OID = 7;
/**
 * Boolean BSON Type
 *
 * @classconstant BSON_DATA_BOOLEAN
 **/
BSON.BSON_DATA_BOOLEAN = 8;
/**
 * Date BSON Type
 *
 * @classconstant BSON_DATA_DATE
 **/
BSON.BSON_DATA_DATE = 9;
/**
 * null BSON Type
 *
 * @classconstant BSON_DATA_NULL
 **/
BSON.BSON_DATA_NULL = 10;
/**
 * RegExp BSON Type
 *
 * @classconstant BSON_DATA_REGEXP
 **/
BSON.BSON_DATA_REGEXP = 11;
/**
 * Code BSON Type
 *
 * @classconstant BSON_DATA_CODE
 **/
BSON.BSON_DATA_CODE = 13;
/**
 * Symbol BSON Type
 *
 * @classconstant BSON_DATA_SYMBOL
 **/
BSON.BSON_DATA_SYMBOL = 14;
/**
 * Code with Scope BSON Type
 *
 * @classconstant BSON_DATA_CODE_W_SCOPE
 **/
BSON.BSON_DATA_CODE_W_SCOPE = 15;
/**
 * 32 bit Integer BSON Type
 *
 * @classconstant BSON_DATA_INT
 **/
BSON.BSON_DATA_INT = 16;
/**
 * Timestamp BSON Type
 *
 * @classconstant BSON_DATA_TIMESTAMP
 **/
BSON.BSON_DATA_TIMESTAMP = 17;
/**
 * Long BSON Type
 *
 * @classconstant BSON_DATA_LONG
 **/
BSON.BSON_DATA_LONG = 18;
/**
 * MinKey BSON Type
 *
 * @classconstant BSON_DATA_MIN_KEY
 **/
BSON.BSON_DATA_MIN_KEY = 0xff;
/**
 * MaxKey BSON Type
 *
 * @classconstant BSON_DATA_MAX_KEY
 **/
BSON.BSON_DATA_MAX_KEY = 0x7f;

/**
 * Binary Default Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
 **/
BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
/**
 * Binary Function Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
 **/
BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
/**
 * Binary Byte Array Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
 **/
BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
/**
 * Binary UUID Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_UUID
 **/
BSON.BSON_BINARY_SUBTYPE_UUID = 3;
/**
 * Binary MD5 Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_MD5
 **/
BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
/**
 * Binary User Defined Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
 **/
BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;

// BSON MAX VALUES
BSON.BSON_INT32_MAX = 0x7FFFFFFF;
BSON.BSON_INT32_MIN = -0x80000000;

BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
BSON.BSON_INT64_MIN = -Math.pow(2, 63);

// JS MAX PRECISE VALUES
BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.

// Internal long versions
var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);  // Any integer up to 2^53 can be precisely represented by a double.
var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);  // Any integer down to -2^53 can be precisely represented by a double.

module.exports = deserialize</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
