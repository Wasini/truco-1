<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/braces/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/braces/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.85</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">399</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">78.11</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.75</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * braces &lt;https://github.com/jonschlinkert/braces&gt;
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT license.
 */

&#039;use strict&#039;;

/**
 * Module dependencies
 */

var expand = require(&#039;expand-range&#039;);
var repeat = require(&#039;repeat-element&#039;);
var tokens = require(&#039;preserve&#039;);

/**
 * Expose `braces`
 */

module.exports = function(str, options) {
  if (typeof str !== &#039;string&#039;) {
    throw new Error(&#039;braces expects a string&#039;);
  }
  return braces(str, options);
};

/**
 * Expand `{foo,bar}` or `{1..5}` braces in the
 * given `string`.
 *
 * @param  {String} `str`
 * @param  {Array} `arr`
 * @param  {Object} `options`
 * @return {Array}
 */

function braces(str, arr, options) {
  if (str === &#039;&#039;) {
    return [];
  }

  if (!Array.isArray(arr)) {
    options = arr;
    arr = [];
  }

  var opts = options || {};
  arr = arr || [];

  if (typeof opts.nodupes === &#039;undefined&#039;) {
    opts.nodupes = true;
  }

  var fn = opts.fn;
  var es6;

  if (typeof opts === &#039;function&#039;) {
    fn = opts;
    opts = {};
  }

  if (!(patternRe instanceof RegExp)) {
    patternRe = patternRegex();
  }

  var matches = str.match(patternRe) || [];
  var m = matches[0];

  switch(m) {
    case &#039;\\,&#039;:
      return escapeCommas(str, arr, opts);
    case &#039;\\.&#039;:
      return escapeDots(str, arr, opts);
    case &#039;\/.&#039;:
      return escapePaths(str, arr, opts);
    case &#039; &#039;:
      return splitWhitespace(str);
    case &#039;{,}&#039;:
      return exponential(str, opts, braces);
    case &#039;{}&#039;:
      return emptyBraces(str, arr, opts);
    case &#039;\\{&#039;:
    case &#039;\\}&#039;:
      return escapeBraces(str, arr, opts);
    case &#039;${&#039;:
      if (!/\{[^{]+\{/.test(str)) {
        return arr.concat(str);
      } else {
        es6 = true;
        str = tokens.before(str, es6Regex());
      }
  }

  if (!(braceRe instanceof RegExp)) {
    braceRe = braceRegex();
  }

  var match = braceRe.exec(str);
  if (match == null) {
    return [str];
  }

  var outter = match[1];
  var inner = match[2];
  if (inner === &#039;&#039;) { return [str]; }

  var segs, segsLength;

  if (inner.indexOf(&#039;..&#039;) !== -1) {
    segs = expand(inner, opts, fn) || inner.split(&#039;,&#039;);
    segsLength = segs.length;

  } else if (inner[0] === &#039;&quot;&#039; || inner[0] === &#039;\&#039;&#039;) {
    return arr.concat(str.split(/[&#039;&quot;]/).join(&#039;&#039;));

  } else {
    segs = inner.split(&#039;,&#039;);
    if (opts.makeRe) {
      return braces(str.replace(outter, wrap(segs, &#039;|&#039;)), opts);
    }

    segsLength = segs.length;
    if (segsLength === 1 &amp;&amp; opts.bash) {
      segs[0] = wrap(segs[0], &#039;\\&#039;);
    }
  }

  var len = segs.length;
  var i = 0, val;

  while (len--) {
    var path = segs[i++];

    if (/(\.[^.\/])/.test(path)) {
      if (segsLength &gt; 1) {
        return segs;
      } else {
        return [str];
      }
    }

    val = splice(str, outter, path);

    if (/\{[^{}]+?\}/.test(val)) {
      arr = braces(val, arr, opts);
    } else if (val !== &#039;&#039;) {
      if (opts.nodupes &amp;&amp; arr.indexOf(val) !== -1) { continue; }
      arr.push(es6 ? tokens.after(val) : val);
    }
  }

  if (opts.strict) { return filter(arr, filterEmpty); }
  return arr;
}

/**
 * Expand exponential ranges
 *
 *   `a{,}{,}` =&gt; [&#039;a&#039;, &#039;a&#039;, &#039;a&#039;, &#039;a&#039;]
 */

function exponential(str, options, fn) {
  if (typeof options === &#039;function&#039;) {
    fn = options;
    options = null;
  }

  var opts = options || {};
  var esc = &#039;__ESC_EXP__&#039;;
  var exp = 0;
  var res;

  var parts = str.split(&#039;{,}&#039;);
  if (opts.nodupes) {
    return fn(parts.join(&#039;&#039;), opts);
  }

  exp = parts.length - 1;
  res = fn(parts.join(esc), opts);
  var len = res.length;
  var arr = [];
  var i = 0;

  while (len--) {
    var ele = res[i++];
    var idx = ele.indexOf(esc);

    if (idx === -1) {
      arr.push(ele);

    } else {
      ele = ele.split(&#039;__ESC_EXP__&#039;).join(&#039;&#039;);
      if (!!ele &amp;&amp; opts.nodupes !== false) {
        arr.push(ele);

      } else {
        var num = Math.pow(2, exp);
        arr.push.apply(arr, repeat(ele, num));
      }
    }
  }
  return arr;
}

/**
 * Wrap a value with parens, brackets or braces,
 * based on the given character/separator.
 *
 * @param  {String|Array} `val`
 * @param  {String} `ch`
 * @return {String}
 */

function wrap(val, ch) {
  if (ch === &#039;|&#039;) {
    return &#039;(&#039; + val.join(ch) + &#039;)&#039;;
  }
  if (ch === &#039;,&#039;) {
    return &#039;{&#039; + val.join(ch) + &#039;}&#039;;
  }
  if (ch === &#039;-&#039;) {
    return &#039;[&#039; + val.join(ch) + &#039;]&#039;;
  }
  if (ch === &#039;\\&#039;) {
    return &#039;\\{&#039; + val + &#039;\\}&#039;;
  }
}

/**
 * Handle empty braces: `{}`
 */

function emptyBraces(str, arr, opts) {
  return braces(str.split(&#039;{}&#039;).join(&#039;\\{\\}&#039;), arr, opts);
}

/**
 * Filter out empty-ish values
 */

function filterEmpty(ele) {
  return !!ele &amp;&amp; ele !== &#039;\\&#039;;
}

/**
 * Handle patterns with whitespace
 */

function splitWhitespace(str) {
  var segs = str.split(&#039; &#039;);
  var len = segs.length;
  var res = [];
  var i = 0;

  while (len--) {
    res.push.apply(res, braces(segs[i++]));
  }
  return res;
}

/**
 * Handle escaped braces: `\\{foo,bar}`
 */

function escapeBraces(str, arr, opts) {
  if (!/\{[^{]+\{/.test(str)) {
    return arr.concat(str.split(&#039;\\&#039;).join(&#039;&#039;));
  } else {
    str = str.split(&#039;\\{&#039;).join(&#039;__LT_BRACE__&#039;);
    str = str.split(&#039;\\}&#039;).join(&#039;__RT_BRACE__&#039;);
    return map(braces(str, arr, opts), function(ele) {
      ele = ele.split(&#039;__LT_BRACE__&#039;).join(&#039;{&#039;);
      return ele.split(&#039;__RT_BRACE__&#039;).join(&#039;}&#039;);
    });
  }
}

/**
 * Handle escaped dots: `{1\\.2}`
 */

function escapeDots(str, arr, opts) {
  if (!/[^\\]\..+\\\./.test(str)) {
    return arr.concat(str.split(&#039;\\&#039;).join(&#039;&#039;));
  } else {
    str = str.split(&#039;\\.&#039;).join(&#039;__ESC_DOT__&#039;);
    return map(braces(str, arr, opts), function(ele) {
      return ele.split(&#039;__ESC_DOT__&#039;).join(&#039;.&#039;);
    });
  }
}

/**
 * Handle escaped dots: `{1\\.2}`
 */

function escapePaths(str, arr, opts) {
  str = str.split(&#039;\/.&#039;).join(&#039;__ESC_PATH__&#039;);
  return map(braces(str, arr, opts), function(ele) {
    return ele.split(&#039;__ESC_PATH__&#039;).join(&#039;\/.&#039;);
  });
}

/**
 * Handle escaped commas: `{a\\,b}`
 */

function escapeCommas(str, arr, opts) {
  if (!/\w,/.test(str)) {
    return arr.concat(str.split(&#039;\\&#039;).join(&#039;&#039;));
  } else {
    str = str.split(&#039;\\,&#039;).join(&#039;__ESC_COMMA__&#039;);
    return map(braces(str, arr, opts), function(ele) {
      return ele.split(&#039;__ESC_COMMA__&#039;).join(&#039;,&#039;);
    });
  }
}

/**
 * Regex for common patterns
 */

function patternRegex() {
  return /\${|( (?=[{,}])|(?=[{,}]) )|{}|{,}|\\,(?=.*[{}])|\/\.(?=.*[{}])|\\\.(?={)|\\{|\\}/;
}

/**
 * Braces regex.
 */

function braceRegex() {
  return /.*(\\?\{([^}]+)\})/;
}

/**
 * es6 delimiter regex.
 */

function es6Regex() {
  return /\$\{([^}]+)\}/;
}

var braceRe;
var patternRe;

/**
 * Faster alternative to `String.replace()` when the
 * index of the token to be replaces can&#039;t be supplied
 */

function splice(str, token, replacement) {
  var i = str.indexOf(token);
  return str.substr(0, i) + replacement
    + str.substr(i + token.length);
}

/**
 * Fast array map
 */

function map(arr, fn) {
  if (arr == null) {
    return [];
  }

  var len = arr.length;
  var res = new Array(len);
  var i = -1;

  while (++i &lt; len) {
    res[i] = fn(arr[i], i, arr);
  }

  return res;
}

/**
 * Fast array filter
 */

function filter(arr, cb) {
  if (arr == null) return [];
  if (typeof cb !== &#039;function&#039;) {
    throw new TypeError(&#039;braces: filter expects a callback function.&#039;);
  }

  var len = arr.length;
  var res = arr.slice();
  var i = 0;

  while (len--) {
    if (!cb(arr[len], i++)) {
      res.splice(len, 1);
    }
  }
  return res;
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
