<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint/lib/rules/key-spacing.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint/lib/rules/key-spacing.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.64</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">492</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">57.36</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.91</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Rule to specify spacing of object literal keys and values
 * @author Brandon Mills
 */
&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether a string contains a line terminator as defined in
 * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3
 * @param {string} str String to test.
 * @returns {boolean} True if str contains a line terminator.
 */
function containsLineTerminator(str) {
    return /[\n\r\u2028\u2029]/.test(str);
}

/**
 * Gets the last element of an array.
 * @param {Array} arr An array.
 * @returns {any} Last element of arr.
 */
function last(arr) {
    return arr[arr.length - 1];
}

/**
 * Checks whether a property is a member of the property group it follows.
 * @param {ASTNode} lastMember The last Property known to be in the group.
 * @param {ASTNode} candidate The next Property that might be in the group.
 * @returns {boolean} True if the candidate property is part of the group.
 */
function continuesPropertyGroup(lastMember, candidate) {
    var groupEndLine = lastMember.loc.start.line,
        candidateStartLine = candidate.loc.start.line,
        comments, i;

    if (candidateStartLine - groupEndLine &lt;= 1) {
        return true;
    }

    // Check that the first comment is adjacent to the end of the group, the
    // last comment is adjacent to the candidate property, and that successive
    // comments are adjacent to each other.
    comments = candidate.leadingComments;
    if (
        comments &amp;&amp;
        comments[0].loc.start.line - groupEndLine &lt;= 1 &amp;&amp;
        candidateStartLine - last(comments).loc.end.line &lt;= 1
    ) {
        for (i = 1; i &lt; comments.length; i++) {
            if (comments[i].loc.start.line - comments[i - 1].loc.end.line &gt; 1) {
                return false;
            }
        }
        return true;
    }

    return false;
}

/**
 * Checks whether a node is contained on a single line.
 * @param {ASTNode} node AST Node being evaluated.
 * @returns {boolean} True if the node is a single line.
 */
function isSingleLine(node) {
    return (node.loc.end.line === node.loc.start.line);
}

/** Sets option values from the configured options with defaults
 * @param {Object} toOptions Object to be initialized
 * @param {Object} fromOptions Object to be initialized from
 * @returns {Object} The object with correctly initialized options and values
 */
function initOptions(toOptions, fromOptions) {
    toOptions.mode = fromOptions.mode || &quot;strict&quot;;

    // Set align if exists -  multiLine case
    if (typeof fromOptions.align !== &quot;undefined&quot;) {
        toOptions.align = fromOptions.align;
    }

    // Set value of beforeColon
    if (typeof fromOptions.beforeColon !== &quot;undefined&quot;) {
        toOptions.beforeColon = +fromOptions.beforeColon;
    } else {
        toOptions.beforeColon = 0;
    }

    // Set value of afterColon
    if (typeof fromOptions.afterColon !== &quot;undefined&quot;) {
        toOptions.afterColon = +fromOptions.afterColon;
    } else {
        toOptions.afterColon = 1;
    }

    return toOptions;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

var messages = {
    key: &quot;{{error}} space after {{computed}}key &#039;{{key}}&#039;.&quot;,
    value: &quot;{{error}} space before value for {{computed}}key &#039;{{key}}&#039;.&quot;
};

module.exports = {
    meta: {
        docs: {
            description: &quot;enforce consistent spacing between keys and values in object literal properties&quot;,
            category: &quot;Stylistic Issues&quot;,
            recommended: false
        },

        fixable: &quot;whitespace&quot;,

        schema: [{
            anyOf: [
                {
                    type: &quot;object&quot;,
                    properties: {
                        align: {
                            enum: [&quot;colon&quot;, &quot;value&quot;]
                        },
                        mode: {
                            enum: [&quot;strict&quot;, &quot;minimum&quot;]
                        },
                        beforeColon: {
                            type: &quot;boolean&quot;
                        },
                        afterColon: {
                            type: &quot;boolean&quot;
                        }
                    },
                    additionalProperties: false
                },
                {
                    type: &quot;object&quot;,
                    properties: {
                        singleLine: {
                            type: &quot;object&quot;,
                            properties: {
                                mode: {
                                    enum: [&quot;strict&quot;, &quot;minimum&quot;]
                                },
                                beforeColon: {
                                    type: &quot;boolean&quot;
                                },
                                afterColon: {
                                    type: &quot;boolean&quot;
                                }
                            },
                            additionalProperties: false
                        },
                        multiLine: {
                            type: &quot;object&quot;,
                            properties: {
                                align: {
                                    enum: [&quot;colon&quot;, &quot;value&quot;]
                                },
                                mode: {
                                    enum: [&quot;strict&quot;, &quot;minimum&quot;]
                                },
                                beforeColon: {
                                    type: &quot;boolean&quot;
                                },
                                afterColon: {
                                    type: &quot;boolean&quot;
                                }
                            },
                            additionalProperties: false
                        }
                    },
                    additionalProperties: false
                }
            ]
        }]
    },

    create: function(context) {

        /**
         * OPTIONS
         * &quot;key-spacing&quot;: [2, {
         *     beforeColon: false,
         *     afterColon: true,
         *     align: &quot;colon&quot; // Optional, or &quot;value&quot;
         * }
         */

        var options = context.options[0] || {},
            multiLineOptions = initOptions({}, (options.multiLine || options)),
            singleLineOptions = initOptions({}, (options.singleLine || options));

        var sourceCode = context.getSourceCode();

        /**
         * Determines if the given property is key-value property.
         * @param {ASTNode} property Property node to check.
         * @returns {Boolean} Whether the property is a key-value property.
         */
        function isKeyValueProperty(property) {
            return !(
                (property.method ||
                property.shorthand ||
                property.kind !== &quot;init&quot; || property.type !== &quot;Property&quot;) // Could be &quot;ExperimentalSpreadProperty&quot; or &quot;SpreadProperty&quot;
            );
        }

        /**
         * Starting from the given a node (a property.key node here) looks forward
         * until it finds the last token before a colon punctuator and returns it.
         * @param {ASTNode} node The node to start looking from.
         * @returns {ASTNode} The last token before a colon punctuator.
         */
        function getLastTokenBeforeColon(node) {
            var prevNode;

            while (node &amp;&amp; (node.type !== &quot;Punctuator&quot; || node.value !== &quot;:&quot;)) {
                prevNode = node;
                node = sourceCode.getTokenAfter(node);
            }

            return prevNode;
        }

        /**
         * Starting from the given a node (a property.key node here) looks forward
         * until it finds the colon punctuator and returns it.
         * @param {ASTNode} node The node to start looking from.
         * @returns {ASTNode} The colon punctuator.
         */
        function getNextColon(node) {

            while (node &amp;&amp; (node.type !== &quot;Punctuator&quot; || node.value !== &quot;:&quot;)) {
                node = sourceCode.getTokenAfter(node);
            }

            return node;
        }

        /**
         * Gets an object literal property&#039;s key as the identifier name or string value.
         * @param {ASTNode} property Property node whose key to retrieve.
         * @returns {string} The property&#039;s key.
         */
        function getKey(property) {
            var key = property.key;

            if (property.computed) {
                return sourceCode.getText().slice(key.range[0], key.range[1]);
            }

            return property.key.name || property.key.value;
        }

        /**
         * Reports an appropriately-formatted error if spacing is incorrect on one
         * side of the colon.
         * @param {ASTNode} property Key-value pair in an object literal.
         * @param {string} side Side being verified - either &quot;key&quot; or &quot;value&quot;.
         * @param {string} whitespace Actual whitespace string.
         * @param {int} expected Expected whitespace length.
         * @param {string} mode Value of the mode as &quot;strict&quot; or &quot;minimum&quot;
         * @returns {void}
         */
        function report(property, side, whitespace, expected, mode) {
            var diff = whitespace.length - expected,
                nextColon = getNextColon(property.key),
                tokenBeforeColon = sourceCode.getTokenBefore(nextColon),
                tokenAfterColon = sourceCode.getTokenAfter(nextColon),
                isKeySide = side === &quot;key&quot;,
                locStart = isKeySide ? tokenBeforeColon.loc.start : tokenAfterColon.loc.start,
                isExtra = diff &gt; 0,
                diffAbs = Math.abs(diff),
                spaces = Array(diffAbs + 1).join(&quot; &quot;),
                fix,
                range;

            if ((
                diff &amp;&amp; mode === &quot;strict&quot; ||
                diff &lt; 0 &amp;&amp; mode === &quot;minimum&quot; ||
                diff &gt; 0 &amp;&amp; !expected &amp;&amp; mode === &quot;minimum&quot;) &amp;&amp;
                !(expected &amp;&amp; containsLineTerminator(whitespace))
            ) {
                if (isExtra) {

                    // Remove whitespace
                    if (isKeySide) {
                        range = [tokenBeforeColon.end, tokenBeforeColon.end + diffAbs];
                    } else {
                        range = [tokenAfterColon.start - diffAbs, tokenAfterColon.start];
                    }
                    fix = function(fixer) {
                        return fixer.removeRange(range);
                    };
                } else {

                    // Add whitespace
                    if (isKeySide) {
                        fix = function(fixer) {
                            return fixer.insertTextAfter(tokenBeforeColon, spaces);
                        };
                    } else {
                        fix = function(fixer) {
                            return fixer.insertTextBefore(tokenAfterColon, spaces);
                        };
                    }
                }

                context.report({
                    node: property[side],
                    loc: locStart,
                    message: messages[side],
                    data: {
                        error: isExtra ? &quot;Extra&quot; : &quot;Missing&quot;,
                        computed: property.computed ? &quot;computed &quot; : &quot;&quot;,
                        key: getKey(property)
                    },
                    fix: fix
                });
            }
        }

        /**
         * Gets the number of characters in a key, including quotes around string
         * keys and braces around computed property keys.
         * @param {ASTNode} property Property of on object literal.
         * @returns {int} Width of the key.
         */
        function getKeyWidth(property) {
            var startToken, endToken;

            startToken = sourceCode.getFirstToken(property);
            endToken = getLastTokenBeforeColon(property.key);

            return endToken.range[1] - startToken.range[0];
        }

        /**
         * Gets the whitespace around the colon in an object literal property.
         * @param {ASTNode} property Property node from an object literal.
         * @returns {Object} Whitespace before and after the property&#039;s colon.
         */
        function getPropertyWhitespace(property) {
            var whitespace = /(\s*):(\s*)/.exec(sourceCode.getText().slice(
                property.key.range[1], property.value.range[0]
            ));

            if (whitespace) {
                return {
                    beforeColon: whitespace[1],
                    afterColon: whitespace[2]
                };
            }
            return null;
        }

        /**
         * Creates groups of properties.
         * @param  {ASTNode} node ObjectExpression node being evaluated.
         * @returns {Array.&lt;ASTNode[]&gt;} Groups of property AST node lists.
         */
        function createGroups(node) {
            if (node.properties.length === 1) {
                return [node.properties];
            }

            return node.properties.reduce(function(groups, property) {
                var currentGroup = last(groups),
                    prev = last(currentGroup);

                if (!prev || continuesPropertyGroup(prev, property)) {
                    currentGroup.push(property);
                } else {
                    groups.push([property]);
                }

                return groups;
            }, [
                []
            ]);
        }

        /**
         * Verifies correct vertical alignment of a group of properties.
         * @param {ASTNode[]} properties List of Property AST nodes.
         * @returns {void}
         */
        function verifyGroupAlignment(properties) {
            var length = properties.length,
                widths = properties.map(getKeyWidth), // Width of keys, including quotes
                targetWidth = Math.max.apply(null, widths),
                i, property, whitespace, width,
                align = multiLineOptions.align,
                beforeColon = multiLineOptions.beforeColon,
                afterColon = multiLineOptions.afterColon,
                mode = multiLineOptions.mode;

            // Conditionally include one space before or after colon
            targetWidth += (align === &quot;colon&quot; ? beforeColon : afterColon);

            for (i = 0; i &lt; length; i++) {
                property = properties[i];
                whitespace = getPropertyWhitespace(property);
                if (whitespace) { // Object literal getters/setters lack a colon
                    width = widths[i];

                    if (align === &quot;value&quot;) {
                        report(property, &quot;key&quot;, whitespace.beforeColon, beforeColon, mode);
                        report(property, &quot;value&quot;, whitespace.afterColon, targetWidth - width, mode);
                    } else { // align = &quot;colon&quot;
                        report(property, &quot;key&quot;, whitespace.beforeColon, targetWidth - width, mode);
                        report(property, &quot;value&quot;, whitespace.afterColon, afterColon, mode);
                    }
                }
            }
        }

        /**
         * Verifies vertical alignment, taking into account groups of properties.
         * @param  {ASTNode} node ObjectExpression node being evaluated.
         * @returns {void}
         */
        function verifyAlignment(node) {
            createGroups(node).forEach(function(group) {
                verifyGroupAlignment(group.filter(isKeyValueProperty));
            });
        }

        /**
         * Verifies spacing of property conforms to specified options.
         * @param  {ASTNode} node Property node being evaluated.
         * @param {Object} lineOptions Configured singleLine or multiLine options
         * @returns {void}
         */
        function verifySpacing(node, lineOptions) {
            var actual = getPropertyWhitespace(node);

            if (actual) { // Object literal getters/setters lack colons
                report(node, &quot;key&quot;, actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
                report(node, &quot;value&quot;, actual.afterColon, lineOptions.afterColon, lineOptions.mode);
            }
        }

        /**
         * Verifies spacing of each property in a list.
         * @param  {ASTNode[]} properties List of Property AST nodes.
         * @returns {void}
         */
        function verifyListSpacing(properties) {
            var length = properties.length;

            for (var i = 0; i &lt; length; i++) {
                verifySpacing(properties[i], singleLineOptions);
            }
        }

        //--------------------------------------------------------------------------
        // Public API
        //--------------------------------------------------------------------------

        if (multiLineOptions.align) { // Verify vertical alignment

            return {
                ObjectExpression: function(node) {
                    if (isSingleLine(node)) {
                        verifyListSpacing(node.properties.filter(isKeyValueProperty));
                    } else {
                        verifyAlignment(node);
                    }
                }
            };

        } else { // Obey beforeColon and afterColon in each property as configured

            return {
                Property: function(node) {
                    verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);
                }
            };

        }

    }
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
