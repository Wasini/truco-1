<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ajv/dist/ajv.bundle.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ajv/dist/ajv.bundle.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">51.15</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">7911</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">282.07</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">120.43</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function(f){if(typeof exports===&quot;object&quot;&amp;&amp;typeof module!==&quot;undefined&quot;){module.exports=f()}else if(typeof define===&quot;function&quot;&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==&quot;undefined&quot;){g=window}else if(typeof global!==&quot;undefined&quot;){g=global}else if(typeof self!==&quot;undefined&quot;){g=self}else{g=this}g.Ajv = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(&quot;Cannot find module &#039;&quot;+o+&quot;&#039;&quot;);throw f.code=&quot;MODULE_NOT_FOUND&quot;,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
&#039;use strict&#039;;

module.exports = {
  setup: setupAsync,
  compile: compileAsync
};


var util = require(&#039;./compile/util&#039;);

var ASYNC = {
  &#039;*&#039;: checkGenerators,
  &#039;co*&#039;: checkGenerators,
  &#039;es7&#039;: checkAsyncFunction
};

var TRANSPILE = {
  &#039;nodent&#039;: getNodent,
  &#039;regenerator&#039;: getRegenerator
};

var MODES = [
  { async: &#039;co*&#039; },
  { async: &#039;es7&#039;, transpile: &#039;nodent&#039; },
  { async: &#039;co*&#039;, transpile: &#039;regenerator&#039; }
];


var regenerator, nodent;


function setupAsync(opts, required) {
  if (required !== false) required = true;
  var async = opts.async
    , transpile = opts.transpile
    , check;

  switch (typeof transpile) {
    case &#039;string&#039;:
      var get = TRANSPILE[transpile];
      if (!get) throw new Error(&#039;bad transpiler: &#039; + transpile);
      return (opts._transpileFunc = get(opts, required));
    case &#039;undefined&#039;:
    case &#039;boolean&#039;:
      if (typeof async == &#039;string&#039;) {
        check = ASYNC[async];
        if (!check) throw new Error(&#039;bad async mode: &#039; + async);
        return (opts.transpile = check(opts, required));
      }

      for (var i=0; i&lt;MODES.length; i++) {
        var _opts = MODES[i];
        if (setupAsync(_opts, false)) {
          util.copy(_opts, opts);
          return opts.transpile;
        }
      }
      /* istanbul ignore next */
      throw new Error(&#039;generators, nodent and regenerator are not available&#039;);
    case &#039;function&#039;:
      return (opts._transpileFunc = opts.transpile);
    default:
      throw new Error(&#039;bad transpiler: &#039; + transpile);
  }
}


function checkGenerators(opts, required) {
  /* jshint evil: true */
  try {
    (new Function(&#039;(function*(){})()&#039;))();
    return true;
  } catch(e) {
    /* istanbul ignore next */
    if (required) throw new Error(&#039;generators not supported&#039;);
  }
}


function checkAsyncFunction(opts, required) {
  /* jshint evil: true */
  try {
    (new Function(&#039;(async function(){})()&#039;))();
    /* istanbul ignore next */
    return true;
  } catch(e) {
    if (required) throw new Error(&#039;es7 async functions not supported&#039;);
  }
}


function getRegenerator(opts, required) {
  try {
    if (!regenerator) {
      regenerator = require(&#039;&#039; + &#039;regenerator&#039;);
      regenerator.runtime();
    }
    if (!opts.async || opts.async === true)
      opts.async = &#039;es7&#039;;
    return regeneratorTranspile;
  } catch(e) {
    /* istanbul ignore next */
    if (required) throw new Error(&#039;regenerator not available&#039;);
  }
}


function regeneratorTranspile(code) {
  return regenerator.compile(code).code;
}


function getNodent(opts, required) {
  /* jshint evil: true */
  try {
    if (!nodent) nodent = require(&#039;&#039; + &#039;nodent&#039;)({ log: false, dontInstallRequireHook: true });
    if (opts.async != &#039;es7&#039;) {
      if (opts.async &amp;&amp; opts.async !== true) console.warn(&#039;nodent transpiles only es7 async functions&#039;);
      opts.async = &#039;es7&#039;;
    }
    return nodentTranspile;
  } catch(e) {
    /* istanbul ignore next */
    if (required) throw new Error(&#039;nodent not available&#039;);
  }
}


function nodentTranspile(code) {
  return nodent.compile(code, &#039;&#039;, { promises: true, sourcemap: false }).code;
}


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and node-style callback.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Function} callback node-style callback, it is always called with 2 parameters: error (or null) and validating function.
 */
function compileAsync(schema, callback) {
  /* eslint no-shadow: 0 */
  /* jshint validthis: true */
  var schemaObj;
  var self = this;
  try {
    schemaObj = this._addSchema(schema);
  } catch(e) {
    setTimeout(function() { callback(e); });
    return;
  }
  if (schemaObj.validate) {
    setTimeout(function() { callback(null, schemaObj.validate); });
  } else {
    if (typeof this._opts.loadSchema != &#039;function&#039;)
      throw new Error(&#039;options.loadSchema should be a function&#039;);
    _compileAsync(schema, callback, true);
  }


  function _compileAsync(schema, callback, firstCall) {
    var validate;
    try { validate = self.compile(schema); }
    catch(e) {
      if (e.missingSchema) loadMissingSchema(e);
      else deferCallback(e);
      return;
    }
    deferCallback(null, validate);

    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (self._refs[ref] || self._schemas[ref])
        return callback(new Error(&#039;Schema &#039; + ref + &#039; is loaded but &#039; + e.missingRef + &#039; cannot be resolved&#039;));
      var _callbacks = self._loadingSchemas[ref];
      if (_callbacks) {
        if (typeof _callbacks == &#039;function&#039;)
          self._loadingSchemas[ref] = [_callbacks, schemaLoaded];
        else
          _callbacks[_callbacks.length] = schemaLoaded;
      } else {
        self._loadingSchemas[ref] = schemaLoaded;
        self._opts.loadSchema(ref, function (err, sch) {
          var _callbacks = self._loadingSchemas[ref];
          delete self._loadingSchemas[ref];
          if (typeof _callbacks == &#039;function&#039;) {
            _callbacks(err, sch);
          } else {
            for (var i=0; i&lt;_callbacks.length; i++)
              _callbacks[i](err, sch);
          }
        });
      }

      function schemaLoaded(err, sch) {
        if (err) return callback(err);
        if (!(self._refs[ref] || self._schemas[ref])) {
          try {
            self.addSchema(sch, ref);
          } catch(e) {
            callback(e);
            return;
          }
        }
        _compileAsync(schema, callback);
      }
    }

    function deferCallback(err, validate) {
      if (firstCall) setTimeout(function() { callback(err, validate); });
      else return callback(err, validate);
    }
  }
}

},{&quot;./compile/util&quot;:10}],2:[function(require,module,exports){
&#039;use strict&#039;;


var Cache = module.exports = function Cache() {
  this._cache = {};
};


Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};


Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};


Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};


Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};

},{}],3:[function(require,module,exports){
&#039;use strict&#039;;

//all requires must be explicit because browserify won&#039;t work with dynamic requires
module.exports = {
  &#039;$ref&#039;: require(&#039;../dotjs/ref&#039;),
  allOf: require(&#039;../dotjs/allOf&#039;),
  anyOf: require(&#039;../dotjs/anyOf&#039;),
  dependencies: require(&#039;../dotjs/dependencies&#039;),
  &#039;enum&#039;: require(&#039;../dotjs/enum&#039;),
  format: require(&#039;../dotjs/format&#039;),
  items: require(&#039;../dotjs/items&#039;),
  maximum: require(&#039;../dotjs/_limit&#039;),
  minimum: require(&#039;../dotjs/_limit&#039;),
  maxItems: require(&#039;../dotjs/_limitItems&#039;),
  minItems: require(&#039;../dotjs/_limitItems&#039;),
  maxLength: require(&#039;../dotjs/_limitLength&#039;),
  minLength: require(&#039;../dotjs/_limitLength&#039;),
  maxProperties: require(&#039;../dotjs/_limitProperties&#039;),
  minProperties: require(&#039;../dotjs/_limitProperties&#039;),
  multipleOf: require(&#039;../dotjs/multipleOf&#039;),
  not: require(&#039;../dotjs/not&#039;),
  oneOf: require(&#039;../dotjs/oneOf&#039;),
  pattern: require(&#039;../dotjs/pattern&#039;),
  properties: require(&#039;../dotjs/properties&#039;),
  required: require(&#039;../dotjs/required&#039;),
  uniqueItems: require(&#039;../dotjs/uniqueItems&#039;),
  validate: require(&#039;../dotjs/validate&#039;)
};

},{&quot;../dotjs/_limit&quot;:13,&quot;../dotjs/_limitItems&quot;:14,&quot;../dotjs/_limitLength&quot;:15,&quot;../dotjs/_limitProperties&quot;:16,&quot;../dotjs/allOf&quot;:17,&quot;../dotjs/anyOf&quot;:18,&quot;../dotjs/dependencies&quot;:21,&quot;../dotjs/enum&quot;:22,&quot;../dotjs/format&quot;:23,&quot;../dotjs/items&quot;:24,&quot;../dotjs/multipleOf&quot;:25,&quot;../dotjs/not&quot;:26,&quot;../dotjs/oneOf&quot;:27,&quot;../dotjs/pattern&quot;:28,&quot;../dotjs/properties&quot;:30,&quot;../dotjs/ref&quot;:31,&quot;../dotjs/required&quot;:32,&quot;../dotjs/uniqueItems&quot;:34,&quot;../dotjs/validate&quot;:35}],4:[function(require,module,exports){
&#039;use strict&#039;;

module.exports = function equal(a, b) {
  if (a === b) return true;

  var arrA = Array.isArray(a)
    , arrB = Array.isArray(b)
    , i;

  if (arrA &amp;&amp; arrB) {
    if (a.length != b.length) return false;
    for (i = 0; i &lt; a.length; i++)
      if (!equal(a[i], b[i])) return false;
    return true;
  }

  if (arrA != arrB) return false;

  if (a &amp;&amp; b &amp;&amp; typeof a === &#039;object&#039; &amp;&amp; typeof b === &#039;object&#039;) {
    var keys = Object.keys(a);

    if (keys.length !== Object.keys(b).length) return false;

    for (i = 0; i &lt; keys.length; i++)
      if (b[keys[i]] === undefined) return false;

    for (i = 0; i &lt; keys.length; i++)
      if(!equal(a[keys[i]], b[keys[i]])) return false;

    return true;
  }

  return false;
};

},{}],5:[function(require,module,exports){
&#039;use strict&#039;;

var util = require(&#039;./util&#039;);

var DATE = /^\d\d\d\d-(\d\d)-(\d\d)$/;
var DAYS = [0,31,29,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
var HOSTNAME = /^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&amp;&#039;()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:@\/?]|%[0-9a-f]{2})*)?(?:\#(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:@\/?]|%[0-9a-f]{2})*)?$/i;
var UUID = /^(?:urn\:uuid\:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~\/]|~0|~1)+)*(?:\/)?$|^\#(?:\/(?:[a-z0-9_\-\.!$&amp;&#039;()*+,;:=@]|%[0-9a-f]{2}|~0|~1)+)*(?:\/)?$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:\#|(?:\/(?:[^~\/]|~0|~1)+)*(?:\/)?)$/;


module.exports = formats;

function formats(mode) {
  mode = mode == &#039;full&#039; ? &#039;full&#039; : &#039;fast&#039;;
  var formatDefs = util.copy(formats[mode]);
  for (var fName in formats.compare) {
    formatDefs[fName] = {
      validate: formatDefs[fName],
      compare: formats.compare[fName]
    };
  }
  return formatDefs;
}


formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
  &#039;date-time&#039;: /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+-.]*)?(?:\:|\/)\/?[^\s]*$/i,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for &#039;willful violation&#039;)
  email: /^[a-z0-9.!#$%&amp;&#039;*+\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  &#039;json-pointer&#039;: JSON_POINTER,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  &#039;relative-json-pointer&#039;: RELATIVE_JSON_POINTER
};


formats.full = {
  date: date,
  time: time,
  &#039;date-time&#039;: date_time,
  uri: uri,
  email: /^[a-z0-9!#$%&amp;&#039;*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;&#039;&#039;*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: hostname,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  &#039;json-pointer&#039;: JSON_POINTER,
  &#039;relative-json-pointer&#039;: RELATIVE_JSON_POINTER
};


formats.compare = {
  date: compareDate,
  time: compareTime,
  &#039;date-time&#039;: compareDateTime
};


function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var month = +matches[1];
  var day = +matches[2];
  return month &gt;= 1 &amp;&amp; month &lt;= 12 &amp;&amp; day &gt;= 1 &amp;&amp; day &lt;= DAYS[month];
}


function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return hour &lt;= 23 &amp;&amp; minute &lt;= 59 &amp;&amp; second &lt;= 59 &amp;&amp; (!full || timeZone);
}


var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 &amp;&amp; date(dateTime[0]) &amp;&amp; time(dateTime[1], true);
}


function hostname(str) {
  // http://tools.ietf.org/html/rfc1034#section-3.5
  return str.length &lt;= 255 &amp;&amp; HOSTNAME.test(str);
}


var NOT_URI_FRAGMENT = /\/|\:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required &quot;.&quot;
  return NOT_URI_FRAGMENT.test(str) &amp;&amp; URI.test(str);
}


function regex(str) {
  try {
    new RegExp(str);
    return true;
  } catch(e) {
    return false;
  }
}


function compareDate(d1, d2) {
  if (!(d1 &amp;&amp; d2)) return;
  if (d1 &gt; d2) return 1;
  if (d1 &lt; d2) return -1;
  if (d1 === d2) return 0;
}


function compareTime(t1, t2) {
  if (!(t1 &amp;&amp; t2)) return;
  t1 = t1.match(TIME);
  t2 = t2.match(TIME);
  if (!(t1 &amp;&amp; t2)) return;
  t1 = t1[1] + t1[2] + t1[3] + (t1[4]||&#039;&#039;);
  t2 = t2[1] + t2[2] + t2[3] + (t2[4]||&#039;&#039;);
  if (t1 &gt; t2) return 1;
  if (t1 &lt; t2) return -1;
  if (t1 === t2) return 0;
}


function compareDateTime(dt1, dt2) {
  if (!(dt1 &amp;&amp; dt2)) return;
  dt1 = dt1.split(DATE_TIME_SEPARATOR);
  dt2 = dt2.split(DATE_TIME_SEPARATOR);
  var res = compareDate(dt1[0], dt2[0]);
  if (res === undefined) return;
  return res || compareTime(dt1[1], dt2[1]);
}

},{&quot;./util&quot;:10}],6:[function(require,module,exports){
&#039;use strict&#039;;

var resolve = require(&#039;./resolve&#039;)
  , util = require(&#039;./util&#039;)
  , stableStringify = require(&#039;json-stable-stringify&#039;)
  , async = require(&#039;../async&#039;);

var beautify = (function() { try { return require(&#039;&#039; + &#039;js-beautify&#039;).js_beautify; } catch(e) {/*empty*/} })();

var validateGenerator = require(&#039;../dotjs/validate&#039;);

/**
 * Functions below are used inside compiled validations function
 */

var co = require(&#039;co&#039;);
var ucs2length = util.ucs2length;
var equal = require(&#039;./equal&#039;);

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = require(&#039;./validation_error&#039;);

module.exports = compile;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = {}
    , patterns = []
    , patternsHash = {}
    , defaults = []
    , defaultsHash = {}
    , customRules = []
    , keepSourceCode = this._opts.sourceCode !== false;

  root = root || { schema: schema, refVal: refVal, refs: refs };

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (keepSourceCode) cv.sourceCode = v.sourceCode;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  function callValidate() {
    var validate = compilation.validate;
    var result = validate.apply(null, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root &amp;&amp; _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;
    if ($async &amp;&amp; !opts.transpile) async.setup(opts);

    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: &#039;&#039;,
      errSchemaPath: &#039;#&#039;,
      errorPath: &#039;&quot;&quot;&#039;,
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      self: self
    });

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode + &#039;return validate;&#039;;

    if (opts.beautify) {
      /* istanbul ignore else */
      if (beautify) sourceCode = beautify(sourceCode, opts.beautify);
      else console.error(&#039;&quot;npm install js-beautify&quot; to use beautify option&#039;);
    }
    // console.log(&#039;\n\n\n *** \n&#039;, sourceCode);
    var validate, validateCode
      , transpile = opts._transpileFunc;
    try {
      validateCode = $async &amp;&amp; transpile
                      ? transpile(sourceCode)
                      : sourceCode;

      var makeValidate = new Function(
        &#039;self&#039;,
        &#039;RULES&#039;,
        &#039;formats&#039;,
        &#039;root&#039;,
        &#039;refVal&#039;,
        &#039;defaults&#039;,
        &#039;customRules&#039;,
        &#039;co&#039;,
        &#039;equal&#039;,
        &#039;ucs2length&#039;,
        &#039;ValidationError&#039;,
        validateCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        co,
        equal,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    } catch(e) {
      console.error(&#039;Error compiling schema, function code:&#039;, validateCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (keepSourceCode) validate.sourceCode = sourceCode;

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = &#039;refVal[&#039; + refIndex + &#039;]&#039;;
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot &amp;&amp; root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (!v) {
      var localSchema = localRefs &amp;&amp; localRefs[ref];
      if (localSchema) {
        v = resolve.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v) {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return &#039;refVal&#039; + refId;
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == &#039;object&#039;
            ? { code: code, schema: refVal, inline: true }
            : { code: code, $async: refVal &amp;&amp; refVal.$async };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return &#039;pattern&#039; + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case &#039;boolean&#039;:
      case &#039;number&#039;:
        return &#039;&#039; + value;
      case &#039;string&#039;:
        return util.toQuotedString(value);
      case &#039;object&#039;:
        if (value === null) return &#039;null&#039;;
        var valueStr = stableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return &#039;default&#039; + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    var validateSchema = rule.definition.validateSchema;
    if (validateSchema &amp;&amp; self._opts.validateSchema !== false) {
      var valid = validateSchema(schema);
      if (!valid) {
        var message = &#039;keyword schema is invalid: &#039; + self.errorsText(validateSchema.errors);
        if (self._opts.validateSchema == &#039;log&#039;) console.error(message);
        else throw new Error(message);
      }
    }

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
    }

    var index = customRules.length;
    customRules[index] = validate;

    return {
      code: &#039;customRule&#039; + index,
      validate: validate
    };
  }
}


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties &quot;index&quot; (compilation index) and &quot;compiling&quot; (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index &gt;= 0) return { index: index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return { index: index, compiling: false };
}


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i &gt;= 0) this._compilations.splice(i, 1);
}


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i=0; i&lt;this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema &amp;&amp; c.root == root &amp;&amp; c.baseId == baseId) return i;
  }
  return -1;
}


function patternCode(i, patterns) {
  return &#039;var pattern&#039; + i + &#039; = new RegExp(&#039; + util.toQuotedString(patterns[i]) + &#039;);&#039;;
}


function defaultCode(i) {
  return &#039;var default&#039; + i + &#039; = defaults[&#039; + i + &#039;];&#039;;
}


function refValCode(i, refVal) {
  return refVal[i] ? &#039;var refVal&#039; + i + &#039; = refVal[&#039; + i + &#039;];&#039; : &#039;&#039;;
}


function customRuleCode(i) {
  return &#039;var customRule&#039; + i + &#039; = customRules[&#039; + i + &#039;];&#039;;
}


function vars(arr, statement) {
  if (!arr.length) return &#039;&#039;;
  var code = &#039;&#039;;
  for (var i=0; i&lt;arr.length; i++)
    code += statement(i, arr);
  return code;
}

},{&quot;../async&quot;:1,&quot;../dotjs/validate&quot;:35,&quot;./equal&quot;:4,&quot;./resolve&quot;:7,&quot;./util&quot;:10,&quot;./validation_error&quot;:11,&quot;co&quot;:46,&quot;json-stable-stringify&quot;:47}],7:[function(require,module,exports){
&#039;use strict&#039;;

var url = require(&#039;url&#039;)
  , equal = require(&#039;./equal&#039;)
  , util = require(&#039;./util&#039;)
  , SchemaObject = require(&#039;./schema_obj&#039;);

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == &#039;string&#039;) {
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) {
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof SchemaObject) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema) {
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = url.parse(ref, false, true)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(root.schema.id);
  if (refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == &#039;string&#039;) {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return { schema: refVal, root: root, baseId: baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(root.schema.id);
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    if (schema.id) baseId = resolveUrl(baseId, schema.id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}


var PREVENT_SCOPE_CHANGE = util.toHash([&#039;properties&#039;, &#039;patternProperties&#039;, &#039;enum&#039;, &#039;dependencies&#039;, &#039;definitions&#039;]);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.hash = parsedRef.hash || &#039;&#039;;
  if (parsedRef.hash.slice(0,2) != &#039;#/&#039;) return;
  var parts = parsedRef.hash.split(&#039;/&#039;);

  for (var i = 1; i &lt; parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (!schema) break;
      if (schema.id &amp;&amp; !PREVENT_SCOPE_CHANGE[part]) baseId = resolveUrl(baseId, schema.id);
      if (schema.$ref) {
        var $ref = resolveUrl(baseId, schema.$ref);
        var res = resolveSchema.call(this, root, $ref);
        if (res) {
          schema = res.schema;
          root = res.root;
          baseId = res.baseId;
        }
      }
    }
  }
  if (schema &amp;&amp; schema != root.schema)
    return { schema: schema, root: root, baseId: baseId };
}


var SIMPLE_INLINED = util.toHash([
  &#039;type&#039;, &#039;format&#039;, &#039;pattern&#039;,
  &#039;maxLength&#039;, &#039;minLength&#039;,
  &#039;maxProperties&#039;, &#039;minProperties&#039;,
  &#039;maxItems&#039;, &#039;minItems&#039;,
  &#039;maximum&#039;, &#039;minimum&#039;,
  &#039;uniqueItems&#039;, &#039;multipleOf&#039;,
  &#039;required&#039;, &#039;enum&#039;
]);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) &lt;= limit;
}


function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i=0; i&lt;schema.length; i++) {
      item = schema[i];
      if (typeof item == &#039;object&#039; &amp;&amp; !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == &#039;$ref&#039;) return false;
      item = schema[key];
      if (typeof item == &#039;object&#039; &amp;&amp; !checkNoRef(item)) return false;
    }
  }
  return true;
}


function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i=0; i&lt;schema.length; i++) {
      item = schema[i];
      if (typeof item == &#039;object&#039;) count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == &#039;$ref&#039;) return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == &#039;object&#039;) count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}


function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = url.parse(id, false, true);
  return _getFullPath(p);
}


function _getFullPath(p) {
  var protocolSeparator = p.protocol || p.href.slice(0,2) == &#039;//&#039; ? &#039;//&#039; : &#039;&#039;;
  return (p.protocol||&#039;&#039;) + protocolSeparator + (p.host||&#039;&#039;) + (p.path||&#039;&#039;)  + &#039;#&#039;;
}


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, &#039;&#039;) : &#039;&#039;;
}


function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return url.resolve(baseId, id);
}


/* @this Ajv */
function resolveIds(schema) {
  /* eslint no-shadow: 0 */
  /* jshint validthis: true */
  var id = normalizeId(schema.id);
  var localRefs = {};
  _resolveIds.call(this, schema, getFullPath(id, false), id);
  return localRefs;

  /* @this Ajv */
  function _resolveIds(schema, fullPath, baseId) {
    /* jshint validthis: true */
    if (Array.isArray(schema)) {
      for (var i=0; i&lt;schema.length; i++)
        _resolveIds.call(this, schema[i], fullPath+&#039;/&#039;+i, baseId);
    } else if (schema &amp;&amp; typeof schema == &#039;object&#039;) {
      if (typeof schema.id == &#039;string&#039;) {
        var id = baseId = baseId
                          ? url.resolve(baseId, schema.id)
                          : schema.id;
        id = normalizeId(id);

        var refVal = this._refs[id];
        if (typeof refVal == &#039;string&#039;) refVal = this._refs[refVal];
        if (refVal &amp;&amp; refVal.schema) {
          if (!equal(schema, refVal.schema))
            throw new Error(&#039;id &quot;&#039; + id + &#039;&quot; resolves to more than one schema&#039;);
        } else if (id != normalizeId(fullPath)) {
          if (id[0] == &#039;#&#039;) {
            if (localRefs[id] &amp;&amp; !equal(schema, localRefs[id]))
              throw new Error(&#039;id &quot;&#039; + id + &#039;&quot; resolves to more than one schema&#039;);
            localRefs[id] = schema;
          } else {
            this._refs[id] = fullPath;
          }
        }
      }
      for (var key in schema)
        _resolveIds.call(this, schema[key], fullPath+&#039;/&#039;+util.escapeFragment(key), baseId);
    }
  }
}

},{&quot;./equal&quot;:4,&quot;./schema_obj&quot;:9,&quot;./util&quot;:10,&quot;url&quot;:44}],8:[function(require,module,exports){
&#039;use strict&#039;;

var ruleModules = require(&#039;./_rules&#039;)
  , toHash = require(&#039;./util&#039;).toHash;

module.exports = function rules() {
  var RULES = [
    { type: &#039;number&#039;,
      rules: [ &#039;maximum&#039;, &#039;minimum&#039;, &#039;multipleOf&#039;] },
    { type: &#039;string&#039;,
      rules: [ &#039;maxLength&#039;, &#039;minLength&#039;, &#039;pattern&#039;, &#039;format&#039; ] },
    { type: &#039;array&#039;,
      rules: [ &#039;maxItems&#039;, &#039;minItems&#039;, &#039;uniqueItems&#039;, &#039;items&#039; ] },
    { type: &#039;object&#039;,
      rules: [ &#039;maxProperties&#039;, &#039;minProperties&#039;, &#039;required&#039;, &#039;dependencies&#039;, &#039;properties&#039; ] },
    { rules: [ &#039;$ref&#039;, &#039;enum&#039;, &#039;not&#039;, &#039;anyOf&#039;, &#039;oneOf&#039;, &#039;allOf&#039; ] }
  ];

  var ALL = [ &#039;type&#039;, &#039;additionalProperties&#039;, &#039;patternProperties&#039; ];
  var KEYWORDS = [ &#039;additionalItems&#039;, &#039;$schema&#039;, &#039;id&#039;, &#039;title&#039;, &#039;description&#039;, &#039;default&#039; ];
  var TYPES = [ &#039;number&#039;, &#039;integer&#039;, &#039;string&#039;, &#039;array&#039;, &#039;object&#039;, &#039;boolean&#039;, &#039;null&#039; ];
  RULES.all = toHash(ALL);

  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: ruleModules[keyword]
      };
      return rule;
    });
  });

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.types = toHash(TYPES);
  RULES.custom = {};

  return RULES;
};

},{&quot;./_rules&quot;:3,&quot;./util&quot;:10}],9:[function(require,module,exports){
&#039;use strict&#039;;

var util = require(&#039;./util&#039;);

module.exports = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}

},{&quot;./util&quot;:10}],10:[function(require,module,exports){
&#039;use strict&#039;;


module.exports = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  ucs2length: ucs2length,
  varOccurences: varOccurences,
  varReplace: varReplace,
  cleanUpCode: cleanUpCode,
  cleanUpVarErrors: cleanUpVarErrors,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  stableStringify: require(&#039;json-stable-stringify&#039;),
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};


function copy(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}


function checkDataType(dataType, data, negate) {
  var EQUAL = negate ? &#039; !== &#039; : &#039; === &#039;
    , AND = negate ? &#039; || &#039; : &#039; &amp;&amp; &#039;
    , OK = negate ? &#039;!&#039; : &#039;&#039;
    , NOT = negate ? &#039;&#039; : &#039;!&#039;;
  switch (dataType) {
    case &#039;null&#039;: return data + EQUAL + &#039;null&#039;;
    case &#039;array&#039;: return OK + &#039;Array.isArray(&#039; + data + &#039;)&#039;;
    case &#039;object&#039;: return &#039;(&#039; + OK + data + AND +
                          &#039;typeof &#039; + data + EQUAL + &#039;&quot;object&quot;&#039; + AND +
                          NOT + &#039;Array.isArray(&#039; + data + &#039;))&#039;;
    case &#039;integer&#039;: return &#039;(typeof &#039; + data + EQUAL + &#039;&quot;number&quot;&#039; + AND +
                           NOT + &#039;(&#039; + data + &#039; % 1)&#039; +
                           AND + data + EQUAL + data + &#039;)&#039;;
    default: return &#039;typeof &#039; + data + EQUAL + &#039;&quot;&#039; + dataType + &#039;&quot;&#039;;
  }
}


function checkDataTypes(dataTypes, data) {
  switch (dataTypes.length) {
    case 1: return checkDataType(dataTypes[0], data, true);
    default:
      var code = &#039;&#039;;
      var types = toHash(dataTypes);
      if (types.array &amp;&amp; types.object) {
        code = types.null ? &#039;(&#039;: &#039;(!&#039; + data + &#039; || &#039;;
        code += &#039;typeof &#039; + data + &#039; !== &quot;object&quot;)&#039;;
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? &#039; &amp;&amp; &#039; : &#039;&#039; ) + checkDataType(t, data, true);

      return code;
  }
}


var COERCE_TO_TYPES = toHash([ &#039;string&#039;, &#039;number&#039;, &#039;integer&#039;, &#039;boolean&#039;, &#039;null&#039; ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i=0; i&lt;dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === &#039;array&#039; &amp;&amp; t === &#039;array&#039;) types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === &#039;array&#039; &amp;&amp; dataTypes === &#039;array&#039;) {
    return [&#039;array&#039;];
  }
}


function toHash(arr) {
  var hash = {};
  for (var i=0; i&lt;arr.length; i++) hash[arr[i]] = true;
  return hash;
}


var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /&#039;|\\/g;
function getProperty(key) {
  return typeof key == &#039;number&#039;
          ? &#039;[&#039; + key + &#039;]&#039;
          : IDENTIFIER.test(key)
            ? &#039;.&#039; + key
            : &quot;[&#039;&quot; + escapeQuotes(key) + &quot;&#039;]&quot;;
}


function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, &#039;\\$&amp;&#039;)
            .replace(/\n/g, &#039;\\n&#039;)
            .replace(/\r/g, &#039;\\r&#039;)
            .replace(/\f/g, &#039;\\f&#039;)
            .replace(/\t/g, &#039;\\t&#039;);
}


// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
function ucs2length(str) {
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos &lt; len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; pos &lt; len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value &amp; 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
}


function varOccurences(str, dataVar) {
  dataVar += &#039;[^0-9]&#039;;
  var matches = str.match(new RegExp(dataVar, &#039;g&#039;));
  return matches ? matches.length : 0;
}


function varReplace(str, dataVar, expr) {
  dataVar += &#039;([^0-9])&#039;;
  expr = expr.replace(/\$/g, &#039;$$$$&#039;);
  return str.replace(new RegExp(dataVar, &#039;g&#039;), expr + &#039;$1&#039;);
}


var EMPTY_ELSE = /else\s*{\s*}/g
  , EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g
  , EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;
function cleanUpCode(out) {
  return out.replace(EMPTY_ELSE, &#039;&#039;)
            .replace(EMPTY_IF_NO_ELSE, &#039;&#039;)
            .replace(EMPTY_IF_WITH_ELSE, &#039;if (!($1))&#039;);
}


var ERRORS_REGEXP = /[^v\.]errors/g
  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g
  , REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g
  , RETURN_VALID = &#039;return errors === 0;&#039;
  , RETURN_TRUE = &#039;validate.errors = null; return true;&#039;
  , RETURN_ASYNC = /if \(errors === 0\) return true;\s*else throw new ValidationError\(vErrors\);/
  , RETURN_TRUE_ASYNC = &#039;return true;&#039;;

function cleanUpVarErrors(out, async) {
  var matches = out.match(ERRORS_REGEXP);
  if (!matches || matches.length !== 2) return out;
  return async
          ? out.replace(REMOVE_ERRORS_ASYNC, &#039;&#039;)
               .replace(RETURN_ASYNC, RETURN_TRUE_ASYNC)
          : out.replace(REMOVE_ERRORS, &#039;&#039;)
               .replace(RETURN_VALID, RETURN_TRUE);
}


function schemaHasRules(schema, rules) {
  for (var key in schema) if (rules[key]) return true;
}


function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  for (var key in schema) if (key != exceptKeyword &amp;&amp; rules[key]) return true;
}


function toQuotedString(str) {
  return &#039;\&#039;&#039; + escapeQuotes(str) + &#039;\&#039;&#039;;
}


function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
              ? &#039;\&#039;/\&#039; + &#039; + expr + (isNumber ? &#039;&#039; : &#039;.replace(/~/g, \&#039;~0\&#039;).replace(/\\//g, \&#039;~1\&#039;)&#039;)
              : (isNumber ? &#039;\&#039;[\&#039; + &#039; + expr + &#039; + \&#039;]\&#039;&#039; : &#039;\&#039;[\\\&#039;\&#039; + &#039; + expr + &#039; + \&#039;\\\&#039;]\&#039;&#039;);
  return joinPaths(currentPath, path);
}


function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
              ? toQuotedString(&#039;/&#039; + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}


var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === &#039;&#039;) return &#039;rootData&#039;;
  if ($data[0] == &#039;/&#039;) {
    if (!JSON_POINTER.test($data)) throw new Error(&#039;Invalid JSON-pointer: &#039; + $data);
    jsonPointer = $data;
    data = &#039;rootData&#039;;
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER);
    if (!matches) throw new Error(&#039;Invalid JSON-pointer: &#039; + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == &#039;#&#039;) {
      if (up &gt;= lvl) throw new Error(&#039;Cannot access property/index &#039; + up + &#039; levels up, current level is &#039; + lvl);
      return paths[lvl - up];
    }

    if (up &gt; lvl) throw new Error(&#039;Cannot access data &#039; + up + &#039; levels up, current level is &#039; + lvl);
    data = &#039;data&#039; + ((lvl - up) || &#039;&#039;);
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split(&#039;/&#039;);
  for (var i=0; i&lt;segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += &#039; &amp;&amp; &#039; + data;
    }
  }
  return expr;
}


function joinPaths (a, b) {
  if (a == &#039;&quot;&quot;&#039;) return b;
  return (a + &#039; + &#039; + b).replace(/&#039; \+ &#039;/g, &#039;&#039;);
}


function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}


function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}


function escapeJsonPointer(str) {
  return str.replace(/~/g, &#039;~0&#039;).replace(/\//g, &#039;~1&#039;);
}


function unescapeJsonPointer(str) {
  return str.replace(/~1/g, &#039;/&#039;).replace(/~0/g, &#039;~&#039;);
}

},{&quot;json-stable-stringify&quot;:47}],11:[function(require,module,exports){
&#039;use strict&#039;;

module.exports = ValidationError;


function ValidationError(errors) {
  this.message = &#039;validation failed&#039;;
  this.errors = errors;
  this.ajv = this.validation = true;
}


ValidationError.prototype = Object.create(Error.prototype);
ValidationError.prototype.constructor = ValidationError;

},{}],12:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate__formatLimit(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  out += &#039;var &#039; + ($valid) + &#039; = undefined;&#039;;
  if (it.opts.format === false) {
    out += &#039; &#039; + ($valid) + &#039; = true; &#039;;
    return out;
  }
  var $schemaFormat = it.schema.format,
    $isDataFormat = it.opts.v5 &amp;&amp; $schemaFormat.$data,
    $closingBraces = &#039;&#039;;
  if ($isDataFormat) {
    var $schemaValueFormat = it.util.getData($schemaFormat.$data, $dataLvl, it.dataPathArr),
      $format = &#039;format&#039; + $lvl,
      $compare = &#039;compare&#039; + $lvl;
    out += &#039; var &#039; + ($format) + &#039; = formats[&#039; + ($schemaValueFormat) + &#039;] , &#039; + ($compare) + &#039; = &#039; + ($format) + &#039; &amp;&amp; &#039; + ($format) + &#039;.compare;&#039;;
  } else {
    var $format = it.formats[$schemaFormat];
    if (!($format &amp;&amp; $format.compare)) {
      out += &#039;  &#039; + ($valid) + &#039; = true; &#039;;
      return out;
    }
    var $compare = &#039;formats&#039; + it.util.getProperty($schemaFormat) + &#039;.compare&#039;;
  }
  var $isMax = $keyword == &#039;formatMaximum&#039;,
    $exclusiveKeyword = &#039;formatExclusive&#039; + ($isMax ? &#039;Maximum&#039; : &#039;Minimum&#039;),
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.v5 &amp;&amp; $schemaExcl &amp;&amp; $schemaExcl.$data,
    $op = $isMax ? &#039;&lt;&#039; : &#039;&gt;&#039;,
    $result = &#039;result&#039; + $lvl;
  var $isData = it.opts.v5 &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = &#039;exclusive&#039; + $lvl,
      $opExpr = &#039;op&#039; + $lvl,
      $opStr = &#039;\&#039; + &#039; + $opExpr + &#039; + \&#039;&#039;;
    out += &#039; var schemaExcl&#039; + ($lvl) + &#039; = &#039; + ($schemaValueExcl) + &#039;; &#039;;
    $schemaValueExcl = &#039;schemaExcl&#039; + $lvl;
    out += &#039; if (typeof &#039; + ($schemaValueExcl) + &#039; != \&#039;boolean\&#039; &amp;&amp; &#039; + ($schemaValueExcl) + &#039; !== undefined) { &#039; + ($valid) + &#039; = false; &#039;;
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = &#039;&#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;_formatExclusiveLimit&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: {} &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;&#039; + ($exclusiveKeyword) + &#039; should be boolean\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
      } else {
        out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
      }
    } else {
      out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    }
    out += &#039; }  &#039;;
    if ($breakOnError) {
      $closingBraces += &#039;}&#039;;
      out += &#039; else { &#039;;
    }
    if ($isData) {
      out += &#039; if (&#039; + ($schemaValue) + &#039; === undefined) &#039; + ($valid) + &#039; = true; else if (typeof &#039; + ($schemaValue) + &#039; != \&#039;string\&#039;) &#039; + ($valid) + &#039; = false; else { &#039;;
      $closingBraces += &#039;}&#039;;
    }
    if ($isDataFormat) {
      out += &#039; if (!&#039; + ($compare) + &#039;) &#039; + ($valid) + &#039; = true; else { &#039;;
      $closingBraces += &#039;}&#039;;
    }
    out += &#039; var &#039; + ($result) + &#039; = &#039; + ($compare) + &#039;(&#039; + ($data) + &#039;,  &#039;;
    if ($isData) {
      out += &#039;&#039; + ($schemaValue);
    } else {
      out += &#039;&#039; + (it.util.toQuotedString($schema));
    }
    out += &#039; ); if (&#039; + ($result) + &#039; === undefined) &#039; + ($valid) + &#039; = false; var &#039; + ($exclusive) + &#039; = &#039; + ($schemaValueExcl) + &#039; === true; if (&#039; + ($valid) + &#039; === undefined) { &#039; + ($valid) + &#039; = &#039; + ($exclusive) + &#039; ? &#039; + ($result) + &#039; &#039; + ($op) + &#039; 0 : &#039; + ($result) + &#039; &#039; + ($op) + &#039;= 0; } if (!&#039; + ($valid) + &#039;) var op&#039; + ($lvl) + &#039; = &#039; + ($exclusive) + &#039; ? \&#039;&#039; + ($op) + &#039;\&#039; : \&#039;&#039; + ($op) + &#039;=\&#039;;&#039;;
  } else {
    var $exclusive = $schemaExcl === true,
      $opStr = $op;
    if (!$exclusive) $opStr += &#039;=&#039;;
    var $opExpr = &#039;\&#039;&#039; + $opStr + &#039;\&#039;&#039;;
    if ($isData) {
      out += &#039; if (&#039; + ($schemaValue) + &#039; === undefined) &#039; + ($valid) + &#039; = true; else if (typeof &#039; + ($schemaValue) + &#039; != \&#039;string\&#039;) &#039; + ($valid) + &#039; = false; else { &#039;;
      $closingBraces += &#039;}&#039;;
    }
    if ($isDataFormat) {
      out += &#039; if (!&#039; + ($compare) + &#039;) &#039; + ($valid) + &#039; = true; else { &#039;;
      $closingBraces += &#039;}&#039;;
    }
    out += &#039; var &#039; + ($result) + &#039; = &#039; + ($compare) + &#039;(&#039; + ($data) + &#039;,  &#039;;
    if ($isData) {
      out += &#039;&#039; + ($schemaValue);
    } else {
      out += &#039;&#039; + (it.util.toQuotedString($schema));
    }
    out += &#039; ); if (&#039; + ($result) + &#039; === undefined) &#039; + ($valid) + &#039; = false; if (&#039; + ($valid) + &#039; === undefined) &#039; + ($valid) + &#039; = &#039; + ($result) + &#039; &#039; + ($op);
    if (!$exclusive) {
      out += &#039;=&#039;;
    }
    out += &#039; 0;&#039;;
  }
  out += &#039;&#039; + ($closingBraces) + &#039;if (!&#039; + ($valid) + &#039;) { &#039;;
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;_formatLimit&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { comparison: &#039; + ($opExpr) + &#039;, limit:  &#039;;
    if ($isData) {
      out += &#039;&#039; + ($schemaValue);
    } else {
      out += &#039;&#039; + (it.util.toQuotedString($schema));
    }
    out += &#039; , exclusive: &#039; + ($exclusive) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should be &#039; + ($opStr) + &#039; &quot;&#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue) + &#039; + \&#039;&#039;;
      } else {
        out += &#039;&#039; + (it.util.escapeQuotes($schema));
      }
      out += &#039;&quot;\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + (it.util.toQuotedString($schema));
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039;}&#039;;
  return out;
}

},{}],13:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate__limit(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $isData = it.opts.v5 &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == &#039;maximum&#039;,
    $exclusiveKeyword = $isMax ? &#039;exclusiveMaximum&#039; : &#039;exclusiveMinimum&#039;,
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.v5 &amp;&amp; $schemaExcl &amp;&amp; $schemaExcl.$data,
    $op = $isMax ? &#039;&lt;&#039; : &#039;&gt;&#039;,
    $notOp = $isMax ? &#039;&gt;&#039; : &#039;&lt;&#039;;
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = &#039;exclusive&#039; + $lvl,
      $opExpr = &#039;op&#039; + $lvl,
      $opStr = &#039;\&#039; + &#039; + $opExpr + &#039; + \&#039;&#039;;
    out += &#039; var schemaExcl&#039; + ($lvl) + &#039; = &#039; + ($schemaValueExcl) + &#039;; &#039;;
    $schemaValueExcl = &#039;schemaExcl&#039; + $lvl;
    out += &#039; var exclusive&#039; + ($lvl) + &#039;; if (typeof &#039; + ($schemaValueExcl) + &#039; != \&#039;boolean\&#039; &amp;&amp; typeof &#039; + ($schemaValueExcl) + &#039; != \&#039;undefined\&#039;) { &#039;;
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = &#039;&#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;_exclusiveLimit&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: {} &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;&#039; + ($exclusiveKeyword) + &#039; should be boolean\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
      } else {
        out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
      }
    } else {
      out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    }
    out += &#039; } else if( &#039;;
    if ($isData) {
      out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;number\&#039;) || &#039;;
    }
    out += &#039; ((exclusive&#039; + ($lvl) + &#039; = &#039; + ($schemaValueExcl) + &#039; === true) ? &#039; + ($data) + &#039; &#039; + ($notOp) + &#039;= &#039; + ($schemaValue) + &#039; : &#039; + ($data) + &#039; &#039; + ($notOp) + &#039; &#039; + ($schemaValue) + &#039;) || &#039; + ($data) + &#039; !== &#039; + ($data) + &#039;) { var op&#039; + ($lvl) + &#039; = exclusive&#039; + ($lvl) + &#039; ? \&#039;&#039; + ($op) + &#039;\&#039; : \&#039;&#039; + ($op) + &#039;=\&#039;;&#039;;
  } else {
    var $exclusive = $schemaExcl === true,
      $opStr = $op;
    if (!$exclusive) $opStr += &#039;=&#039;;
    var $opExpr = &#039;\&#039;&#039; + $opStr + &#039;\&#039;&#039;;
    out += &#039; if ( &#039;;
    if ($isData) {
      out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;number\&#039;) || &#039;;
    }
    out += &#039; &#039; + ($data) + &#039; &#039; + ($notOp);
    if ($exclusive) {
      out += &#039;=&#039;;
    }
    out += &#039; &#039; + ($schemaValue) + &#039; || &#039; + ($data) + &#039; !== &#039; + ($data) + &#039;) {&#039;;
  }
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;_limit&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { comparison: &#039; + ($opExpr) + &#039;, limit: &#039; + ($schemaValue) + &#039;, exclusive: &#039; + ($exclusive) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should be &#039; + ($opStr) + &#039; &#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue);
      } else {
        out += &#039;&#039; + ($schema) + &#039;\&#039;&#039;;
      }
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039; } &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],14:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate__limitItems(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $isData = it.opts.v5 &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == &#039;maxItems&#039; ? &#039;&gt;&#039; : &#039;&lt;&#039;;
  out += &#039;if ( &#039;;
  if ($isData) {
    out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;number\&#039;) || &#039;;
  }
  out += &#039; &#039; + ($data) + &#039;.length &#039; + ($op) + &#039; &#039; + ($schemaValue) + &#039;) { &#039;;
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;_limitItems&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { limit: &#039; + ($schemaValue) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should NOT have &#039;;
      if ($keyword == &#039;maxItems&#039;) {
        out += &#039;more&#039;;
      } else {
        out += &#039;less&#039;;
      }
      out += &#039; than &#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue) + &#039; + \&#039;&#039;;
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039; items\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039;} &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],15:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate__limitLength(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $isData = it.opts.v5 &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == &#039;maxLength&#039; ? &#039;&gt;&#039; : &#039;&lt;&#039;;
  out += &#039;if ( &#039;;
  if ($isData) {
    out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;number\&#039;) || &#039;;
  }
  if (it.opts.unicode === false) {
    out += &#039; &#039; + ($data) + &#039;.length &#039;;
  } else {
    out += &#039; ucs2length(&#039; + ($data) + &#039;) &#039;;
  }
  out += &#039; &#039; + ($op) + &#039; &#039; + ($schemaValue) + &#039;) { &#039;;
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;_limitLength&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { limit: &#039; + ($schemaValue) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should NOT be &#039;;
      if ($keyword == &#039;maxLength&#039;) {
        out += &#039;longer&#039;;
      } else {
        out += &#039;shorter&#039;;
      }
      out += &#039; than &#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue) + &#039; + \&#039;&#039;;
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039; characters\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039;} &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],16:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate__limitProperties(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $isData = it.opts.v5 &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == &#039;maxProperties&#039; ? &#039;&gt;&#039; : &#039;&lt;&#039;;
  out += &#039;if ( &#039;;
  if ($isData) {
    out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;number\&#039;) || &#039;;
  }
  out += &#039; Object.keys(&#039; + ($data) + &#039;).length &#039; + ($op) + &#039; &#039; + ($schemaValue) + &#039;) { &#039;;
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;_limitProperties&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { limit: &#039; + ($schemaValue) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should NOT have &#039;;
      if ($keyword == &#039;maxProperties&#039;) {
        out += &#039;more&#039;;
      } else {
        out += &#039;less&#039;;
      }
      out += &#039; than &#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue) + &#039; + \&#039;&#039;;
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039; properties\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039;} &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],17:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_allOf(it, $keyword) {
  var out = &#039; &#039;;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  var $currentBaseId = $it.baseId;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i &lt; l1) {
      $sch = arr1[$i += 1];
      if (it.util.schemaHasRules($sch, it.RULES.all)) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + &#039;[&#039; + $i + &#039;]&#039;;
        $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + $i;
        out += &#039;  &#039; + (it.validate($it)) + &#039; &#039;;
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += &#039; if (valid&#039; + ($it.level) + &#039;) { &#039;;
          $closingBraces += &#039;}&#039;;
        }
      }
    }
  }
  if ($breakOnError) {
    out += &#039; &#039; + ($closingBraces.slice(0, -1));
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],18:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_anyOf(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  var $noEmptySchema = $schema.every(function($sch) {
    return it.util.schemaHasRules($sch, it.RULES.all);
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += &#039; var &#039; + ($errs) + &#039; = errors; var &#039; + ($valid) + &#039; = false;  &#039;;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i &lt; l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + &#039;[&#039; + $i + &#039;]&#039;;
        $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + $i;
        out += &#039;  &#039; + (it.validate($it)) + &#039; &#039;;
        $it.baseId = $currentBaseId;
        out += &#039; &#039; + ($valid) + &#039; = &#039; + ($valid) + &#039; || valid&#039; + ($it.level) + &#039;; if (!&#039; + ($valid) + &#039;) { &#039;;
        $closingBraces += &#039;}&#039;;
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += &#039; &#039; + ($closingBraces) + &#039; if (!&#039; + ($valid) + &#039;) {  var err =   &#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;anyOf&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: {} &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;should match some schema in anyOf\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else {  errors = &#039; + ($errs) + &#039;; if (vErrors !== null) { if (&#039; + ($errs) + &#039;) vErrors.length = &#039; + ($errs) + &#039;; else vErrors = null; } &#039;;
    if (it.opts.allErrors) {
      out += &#039; } &#039;;
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += &#039; if (true) { &#039;;
    }
  }
  return out;
}

},{}],19:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_constant(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $isData = it.opts.v5 &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!$isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = validate.schema&#039; + ($schemaPath) + &#039;;&#039;;
  }
  out += &#039;var &#039; + ($valid) + &#039; = equal(&#039; + ($data) + &#039;, schema&#039; + ($lvl) + &#039;); if (!&#039; + ($valid) + &#039;) {   &#039;;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;constant&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: {} &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should be equal to constant\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039; }&#039;;
  return out;
}

},{}],20:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_custom(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $errs = &#039;errs__&#039; + $lvl;
  var $isData = it.opts.v5 &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = &#039;definition&#039; + $lvl,
    $rDef = $rule.definition,
    $validate = $rDef.validate,
    $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData &amp;&amp; $rDef.$data) {
    $validateCode = &#039;keywordValidate&#039; + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += &#039; var &#039; + ($definition) + &#039; = RULES.custom[\&#039;&#039; + ($keyword) + &#039;\&#039;].definition; var &#039; + ($validateCode) + &#039; = &#039; + ($definition) + &#039;.validate;&#039;;
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    $schemaValue = &#039;validate.schema&#039; + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + &#039;.errors&#039;,
    $i = &#039;i&#039; + $lvl,
    $ruleErr = &#039;ruleErr&#039; + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword &amp;&amp; !it.async) throw new Error(&#039;async keyword in sync schema&#039;);
  if (!($inline || $macro)) {
    out += &#039;&#039; + ($ruleErrs) + &#039; = null;&#039;;
  }
  out += &#039;var &#039; + ($errs) + &#039; = errors;var valid&#039; + ($lvl) + &#039;;&#039;;
  if ($inline &amp;&amp; $rDef.statements) {
    out += &#039; &#039; + ($ruleValidate.validate);
  } else if ($macro) {
    var $it = it.util.copy(it);
    $it.level++;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = &#039;&#039;;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += &#039; &#039; + ($code);
  } else if (!$inline) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = &#039;&#039;;
    out += &#039;  &#039; + ($validateCode) + &#039;.call( &#039;;
    if (it.opts.passContext) {
      out += &#039;this&#039;;
    } else {
      out += &#039;self&#039;;
    }
    if ($compile || $rDef.schema === false) {
      out += &#039; , &#039; + ($data) + &#039; &#039;;
    } else {
      out += &#039; , &#039; + ($schemaValue) + &#039; , &#039; + ($data) + &#039; , validate.schema&#039; + (it.schemaPath) + &#039; &#039;;
    }
    out += &#039; , (dataPath || \&#039;\&#039;)&#039;;
    if (it.errorPath != &#039;&quot;&quot;&#039;) {
      out += &#039; + &#039; + (it.errorPath);
    }
    if ($dataLvl) {
      out += &#039; , data&#039; + (($dataLvl - 1) || &#039;&#039;) + &#039; , &#039; + (it.dataPathArr[$dataLvl]) + &#039; &#039;;
    } else {
      out += &#039; , parentData , parentDataProperty &#039;;
    }
    out += &#039; , rootData )  &#039;;
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors !== false) {
      if ($asyncKeyword) {
        $ruleErrs = &#039;customErrors&#039; + $lvl;
        out += &#039; var &#039; + ($ruleErrs) + &#039; = null; try { valid&#039; + ($lvl) + &#039; = &#039; + (it.yieldAwait) + (def_callRuleValidate) + &#039;; } catch (e) { valid&#039; + ($lvl) + &#039; = false; if (e instanceof ValidationError) &#039; + ($ruleErrs) + &#039; = e.errors; else throw e; } &#039;;
      } else {
        out += &#039; &#039; + ($validateCode) + &#039;.errors = null; &#039;;
      }
    }
  }
  out += &#039;if (&#039;;
  if ($validateSchema) {
    out += &#039; !&#039; + ($definition) + &#039;.validateSchema(&#039; + ($schemaValue) + &#039;) || &#039;;
  }
  out += &#039; ! &#039;;
  if ($inline) {
    if ($rDef.statements) {
      out += &#039; valid&#039; + ($lvl) + &#039; &#039;;
    } else {
      out += &#039; (&#039; + ($ruleValidate.validate) + &#039;) &#039;;
    }
  } else if ($macro) {
    out += &#039; valid&#039; + ($it.level) + &#039; &#039;;
  } else {
    if ($asyncKeyword) {
      if ($rDef.errors === false) {
        out += &#039; (&#039; + (it.yieldAwait) + (def_callRuleValidate) + &#039;) &#039;;
      } else {
        out += &#039; valid&#039; + ($lvl) + &#039; &#039;;
      }
    } else {
      out += &#039; &#039; + (def_callRuleValidate) + &#039; &#039;;
    }
  }
  out += &#039;) { &#039;;
  $errorKeyword = $rule.keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;custom&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { keyword: \&#039;&#039; + ($rule.keyword) + &#039;\&#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should pass &quot;&#039; + ($rule.keyword) + &#039;&quot; keyword validation\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  var def_customError = out;
  out = $$outStack.pop();
  if ($inline) {
    if ($rDef.errors) {
      if ($rDef.errors != &#039;full&#039;) {
        out += &#039;  for (var &#039; + ($i) + &#039;=&#039; + ($errs) + &#039;; &#039; + ($i) + &#039;&lt;errors; &#039; + ($i) + &#039;++) { var &#039; + ($ruleErr) + &#039; = vErrors[&#039; + ($i) + &#039;]; if (&#039; + ($ruleErr) + &#039;.dataPath === undefined) { &#039; + ($ruleErr) + &#039;.dataPath = (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039;; } if (&#039; + ($ruleErr) + &#039;.schemaPath === undefined) { &#039; + ($ruleErr) + &#039;.schemaPath = &quot;&#039; + ($errSchemaPath) + &#039;&quot;; } &#039;;
        if (it.opts.verbose) {
          out += &#039; &#039; + ($ruleErr) + &#039;.schema = &#039; + ($schemaValue) + &#039;; &#039; + ($ruleErr) + &#039;.data = &#039; + ($data) + &#039;; &#039;;
        }
        out += &#039; } &#039;;
      }
    } else {
      if ($rDef.errors === false) {
        out += &#039; &#039; + (def_customError) + &#039; &#039;;
      } else {
        out += &#039; if (&#039; + ($errs) + &#039; == errors) { &#039; + (def_customError) + &#039; } else {  for (var &#039; + ($i) + &#039;=&#039; + ($errs) + &#039;; &#039; + ($i) + &#039;&lt;errors; &#039; + ($i) + &#039;++) { var &#039; + ($ruleErr) + &#039; = vErrors[&#039; + ($i) + &#039;]; if (&#039; + ($ruleErr) + &#039;.dataPath === undefined) { &#039; + ($ruleErr) + &#039;.dataPath = (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039;; } if (&#039; + ($ruleErr) + &#039;.schemaPath === undefined) { &#039; + ($ruleErr) + &#039;.schemaPath = &quot;&#039; + ($errSchemaPath) + &#039;&quot;; } &#039;;
        if (it.opts.verbose) {
          out += &#039; &#039; + ($ruleErr) + &#039;.schema = &#039; + ($schemaValue) + &#039;; &#039; + ($ruleErr) + &#039;.data = &#039; + ($data) + &#039;; &#039;;
        }
        out += &#039; } } &#039;;
      }
    }
  } else if ($macro) {
    out += &#039;   var err =   &#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;custom&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { keyword: \&#039;&#039; + ($rule.keyword) + &#039;\&#039; } &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;should pass &quot;&#039; + ($rule.keyword) + &#039;&quot; keyword validation\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += &#039; throw new ValidationError(vErrors); &#039;;
      } else {
        out += &#039; validate.errors = vErrors; return false &#039;;
      }
    }
  } else {
    if ($rDef.errors === false) {
      out += &#039; &#039; + (def_customError) + &#039; &#039;;
    } else {
      out += &#039; if (Array.isArray(&#039; + ($ruleErrs) + &#039;)) { if (vErrors === null) vErrors = &#039; + ($ruleErrs) + &#039;; else vErrors = vErrors.concat(&#039; + ($ruleErrs) + &#039;); errors = vErrors.length;  for (var &#039; + ($i) + &#039;=&#039; + ($errs) + &#039;; &#039; + ($i) + &#039;&lt;errors; &#039; + ($i) + &#039;++) { var &#039; + ($ruleErr) + &#039; = vErrors[&#039; + ($i) + &#039;];  &#039; + ($ruleErr) + &#039;.dataPath = (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039;;   &#039; + ($ruleErr) + &#039;.schemaPath = &quot;&#039; + ($errSchemaPath) + &#039;&quot;;  &#039;;
      if (it.opts.verbose) {
        out += &#039; &#039; + ($ruleErr) + &#039;.schema = &#039; + ($schemaValue) + &#039;; &#039; + ($ruleErr) + &#039;.data = &#039; + ($data) + &#039;; &#039;;
      }
      out += &#039; } } else { &#039; + (def_customError) + &#039; } &#039;;
    }
  }
  out += &#039; } &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],21:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_dependencies(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  var $schemaDeps = {},
    $propertyDeps = {};
  for ($property in $schema) {
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += &#039;var &#039; + ($errs) + &#039; = errors;&#039;;
  var $currentErrorPath = it.errorPath;
  out += &#039;var missing&#039; + ($lvl) + &#039;;&#039;;
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    out += &#039; if (&#039; + ($data) + (it.util.getProperty($property)) + &#039; !== undefined &#039;;
    if ($breakOnError) {
      out += &#039; &amp;&amp; ( &#039;;
      var arr1 = $deps;
      if (arr1) {
        var _$property, $i = -1,
          l1 = arr1.length - 1;
        while ($i &lt; l1) {
          _$property = arr1[$i += 1];
          if ($i) {
            out += &#039; || &#039;;
          }
          var $prop = it.util.getProperty(_$property);
          out += &#039; ( &#039; + ($data) + ($prop) + &#039; === undefined &amp;&amp; (missing&#039; + ($lvl) + &#039; = &#039; + (it.util.toQuotedString(it.opts.jsonPointers ? _$property : $prop)) + &#039;) ) &#039;;
        }
      }
      out += &#039;)) {  &#039;;
      var $propertyPath = &#039;missing&#039; + $lvl,
        $missingProperty = &#039;\&#039; + &#039; + $propertyPath + &#039; + \&#039;&#039;;
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + &#039; + &#039; + $propertyPath;
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = &#039;&#039;; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;dependencies&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { property: \&#039;&#039; + (it.util.escapeQuotes($property)) + &#039;\&#039;, missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039;, depsCount: &#039; + ($deps.length) + &#039;, deps: \&#039;&#039; + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(&quot;, &quot;))) + &#039;\&#039; } &#039;;
        if (it.opts.messages !== false) {
          out += &#039; , message: \&#039;should have &#039;;
          if ($deps.length == 1) {
            out += &#039;property &#039; + (it.util.escapeQuotes($deps[0]));
          } else {
            out += &#039;properties &#039; + (it.util.escapeQuotes($deps.join(&quot;, &quot;)));
          }
          out += &#039; when property &#039; + (it.util.escapeQuotes($property)) + &#039; is present\&#039; &#039;;
        }
        if (it.opts.verbose) {
          out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
        }
        out += &#039; } &#039;;
      } else {
        out += &#039; {} &#039;;
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
        if (it.async) {
          out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
        } else {
          out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
        }
      } else {
        out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
      }
    } else {
      out += &#039; ) { &#039;;
      var arr2 = $deps;
      if (arr2) {
        var $reqProperty, i2 = -1,
          l2 = arr2.length - 1;
        while (i2 &lt; l2) {
          $reqProperty = arr2[i2 += 1];
          var $prop = it.util.getProperty($reqProperty),
            $missingProperty = it.util.escapeQuotes($reqProperty);
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPath($currentErrorPath, $reqProperty, it.opts.jsonPointers);
          }
          out += &#039; if (&#039; + ($data) + ($prop) + &#039; === undefined) {  var err =   &#039;; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;dependencies&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { property: \&#039;&#039; + (it.util.escapeQuotes($property)) + &#039;\&#039;, missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039;, depsCount: &#039; + ($deps.length) + &#039;, deps: \&#039;&#039; + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(&quot;, &quot;))) + &#039;\&#039; } &#039;;
            if (it.opts.messages !== false) {
              out += &#039; , message: \&#039;should have &#039;;
              if ($deps.length == 1) {
                out += &#039;property &#039; + (it.util.escapeQuotes($deps[0]));
              } else {
                out += &#039;properties &#039; + (it.util.escapeQuotes($deps.join(&quot;, &quot;)));
              }
              out += &#039; when property &#039; + (it.util.escapeQuotes($property)) + &#039; is present\&#039; &#039;;
            }
            if (it.opts.verbose) {
              out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
            }
            out += &#039; } &#039;;
          } else {
            out += &#039; {} &#039;;
          }
          out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } &#039;;
        }
      }
    }
    out += &#039; }   &#039;;
    if ($breakOnError) {
      $closingBraces += &#039;}&#039;;
      out += &#039; else { &#039;;
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if (it.util.schemaHasRules($sch, it.RULES.all)) {
      out += &#039; valid&#039; + ($it.level) + &#039; = true; if (&#039; + ($data) + &#039;[\&#039;&#039; + ($property) + &#039;\&#039;] !== undefined) { &#039;;
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + it.util.escapeFragment($property);
      out += &#039;  &#039; + (it.validate($it)) + &#039; &#039;;
      $it.baseId = $currentBaseId;
      out += &#039; }  &#039;;
      if ($breakOnError) {
        out += &#039; if (valid&#039; + ($it.level) + &#039;) { &#039;;
        $closingBraces += &#039;}&#039;;
      }
    }
  }
  if ($breakOnError) {
    out += &#039;   &#039; + ($closingBraces) + &#039; if (&#039; + ($errs) + &#039; == errors) {&#039;;
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],22:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_enum(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $isData = it.opts.v5 &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $i = &#039;i&#039; + $lvl;
  if (!$isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = validate.schema&#039; + ($schemaPath) + &#039;;&#039;;
  }
  out += &#039;var &#039; + ($valid) + &#039;;&#039;;
  if ($isData) {
    out += &#039; if (schema&#039; + ($lvl) + &#039; === undefined) &#039; + ($valid) + &#039; = true; else if (!Array.isArray(schema&#039; + ($lvl) + &#039;)) &#039; + ($valid) + &#039; = false; else {&#039;;
  }
  out += &#039;&#039; + ($valid) + &#039; = false;for (var &#039; + ($i) + &#039;=0; &#039; + ($i) + &#039;&lt;schema&#039; + ($lvl) + &#039;.length; &#039; + ($i) + &#039;++) if (equal(&#039; + ($data) + &#039;, schema&#039; + ($lvl) + &#039;[&#039; + ($i) + &#039;])) { &#039; + ($valid) + &#039; = true; break; }&#039;;
  if ($isData) {
    out += &#039;  }  &#039;;
  }
  out += &#039; if (!&#039; + ($valid) + &#039;) {   &#039;;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;enum&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { allowedValues: schema&#039; + ($lvl) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should be equal to one of the allowed values\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039; }&#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],23:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_format(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += &#039; if (true) { &#039;;
    }
    return out;
  }
  var $isData = it.opts.v5 &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if ($isData) {
    var $format = &#039;format&#039; + $lvl;
    out += &#039; var &#039; + ($format) + &#039; = formats[&#039; + ($schemaValue) + &#039;]; var isObject&#039; + ($lvl) + &#039; = typeof &#039; + ($format) + &#039; == \&#039;object\&#039; &amp;&amp; !(&#039; + ($format) + &#039; instanceof RegExp) &amp;&amp; &#039; + ($format) + &#039;.validate; if (isObject&#039; + ($lvl) + &#039;) { var async&#039; + ($lvl) + &#039; = &#039; + ($format) + &#039;.async; &#039; + ($format) + &#039; = &#039; + ($format) + &#039;.validate; } if (  &#039;;
    if ($isData) {
      out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;string\&#039;) || &#039;;
    }
    out += &#039; (&#039; + ($format) + &#039; &amp;&amp; !(typeof &#039; + ($format) + &#039; == \&#039;function\&#039; ? &#039;;
    if (it.async) {
      out += &#039; (async&#039; + ($lvl) + &#039; ? &#039; + (it.yieldAwait) + &#039; &#039; + ($format) + &#039;(&#039; + ($data) + &#039;) : &#039; + ($format) + &#039;(&#039; + ($data) + &#039;)) &#039;;
    } else {
      out += &#039; &#039; + ($format) + &#039;(&#039; + ($data) + &#039;) &#039;;
    }
    out += &#039; : &#039; + ($format) + &#039;.test(&#039; + ($data) + &#039;)))) {&#039;;
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($breakOnError) {
        out += &#039; if (true) { &#039;;
      }
      return out;
    }
    var $isObject = typeof $format == &#039;object&#039; &amp;&amp; !($format instanceof RegExp) &amp;&amp; $format.validate;
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($async) {
      if (!it.async) throw new Error(&#039;async format in sync schema&#039;);
      var $formatRef = &#039;formats&#039; + it.util.getProperty($schema) + &#039;.validate&#039;;
      out += &#039; if (!(&#039; + (it.yieldAwait) + &#039; &#039; + ($formatRef) + &#039;(&#039; + ($data) + &#039;))) { &#039;;
    } else {
      out += &#039; if (! &#039;;
      var $formatRef = &#039;formats&#039; + it.util.getProperty($schema);
      if ($isObject) $formatRef += &#039;.validate&#039;;
      if (typeof $format == &#039;function&#039;) {
        out += &#039; &#039; + ($formatRef) + &#039;(&#039; + ($data) + &#039;) &#039;;
      } else {
        out += &#039; &#039; + ($formatRef) + &#039;.test(&#039; + ($data) + &#039;) &#039;;
      }
      out += &#039;) { &#039;;
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;format&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { format:  &#039;;
    if ($isData) {
      out += &#039;&#039; + ($schemaValue);
    } else {
      out += &#039;&#039; + (it.util.toQuotedString($schema));
    }
    out += &#039;  } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should match format &quot;&#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue) + &#039; + \&#039;&#039;;
      } else {
        out += &#039;&#039; + (it.util.escapeQuotes($schema));
      }
      out += &#039;&quot;\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + (it.util.toQuotedString($schema));
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039; } &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],24:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_items(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  var $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = &#039;data&#039; + $dataNxt,
    $currentBaseId = it.baseId;
  out += &#039;var &#039; + ($errs) + &#039; = errors;var &#039; + ($valid) + &#039;;&#039;;
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += &#039; &#039; + ($valid) + &#039; = &#039; + ($data) + &#039;.length &lt;= &#039; + ($schema.length) + &#039;; &#039;;
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + &#039;/additionalItems&#039;;
      out += &#039;  if (!&#039; + ($valid) + &#039;) {   &#039;;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = &#039;&#039;; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;additionalItems&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { limit: &#039; + ($schema.length) + &#039; } &#039;;
        if (it.opts.messages !== false) {
          out += &#039; , message: \&#039;should NOT have more than &#039; + ($schema.length) + &#039; items\&#039; &#039;;
        }
        if (it.opts.verbose) {
          out += &#039; , schema: false , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
        }
        out += &#039; } &#039;;
      } else {
        out += &#039; {} &#039;;
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
        if (it.async) {
          out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
        } else {
          out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
        }
      } else {
        out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
      }
      out += &#039; } &#039;;
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += &#039;}&#039;;
        out += &#039; else { &#039;;
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i &lt; l1) {
        $sch = arr1[$i += 1];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          out += &#039; valid&#039; + ($it.level) + &#039; = true; if (&#039; + ($data) + &#039;.length &gt; &#039; + ($i) + &#039;) { &#039;;
          var $passData = $data + &#039;[&#039; + $i + &#039;]&#039;;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + &#039;[&#039; + $i + &#039;]&#039;;
          $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) &lt; 2) {
            out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
          } else {
            out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
          }
          out += &#039; }  &#039;;
          if ($breakOnError) {
            out += &#039; if (valid&#039; + ($it.level) + &#039;) { &#039;;
            $closingBraces += &#039;}&#039;;
          }
        }
      }
    }
    if (typeof $additionalItems == &#039;object&#039; &amp;&amp; it.util.schemaHasRules($additionalItems, it.RULES.all)) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + &#039;.additionalItems&#039;;
      $it.errSchemaPath = it.errSchemaPath + &#039;/additionalItems&#039;;
      out += &#039; valid&#039; + ($it.level) + &#039; = true; if (&#039; + ($data) + &#039;.length &gt; &#039; + ($schema.length) + &#039;) {  for (var i&#039; + ($lvl) + &#039; = &#039; + ($schema.length) + &#039;; i&#039; + ($lvl) + &#039; &lt; &#039; + ($data) + &#039;.length; i&#039; + ($lvl) + &#039;++) { &#039;;
      $it.errorPath = it.util.getPathExpr(it.errorPath, &#039;i&#039; + $lvl, it.opts.jsonPointers, true);
      var $passData = $data + &#039;[i&#039; + $lvl + &#039;]&#039;;
      $it.dataPathArr[$dataNxt] = &#039;i&#039; + $lvl;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) &lt; 2) {
        out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
      } else {
        out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
      }
      if ($breakOnError) {
        out += &#039; if (!valid&#039; + ($it.level) + &#039;) break; &#039;;
      }
      out += &#039; } }  &#039;;
      if ($breakOnError) {
        out += &#039; if (valid&#039; + ($it.level) + &#039;) { &#039;;
        $closingBraces += &#039;}&#039;;
      }
    }
  } else if (it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += &#039;  for (var i&#039; + ($lvl) + &#039; = &#039; + (0) + &#039;; i&#039; + ($lvl) + &#039; &lt; &#039; + ($data) + &#039;.length; i&#039; + ($lvl) + &#039;++) { &#039;;
    $it.errorPath = it.util.getPathExpr(it.errorPath, &#039;i&#039; + $lvl, it.opts.jsonPointers, true);
    var $passData = $data + &#039;[i&#039; + $lvl + &#039;]&#039;;
    $it.dataPathArr[$dataNxt] = &#039;i&#039; + $lvl;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) &lt; 2) {
      out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
    } else {
      out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
    }
    if ($breakOnError) {
      out += &#039; if (!valid&#039; + ($it.level) + &#039;) break; &#039;;
    }
    out += &#039; }  &#039;;
    if ($breakOnError) {
      out += &#039; if (valid&#039; + ($it.level) + &#039;) { &#039;;
      $closingBraces += &#039;}&#039;;
    }
  }
  if ($breakOnError) {
    out += &#039; &#039; + ($closingBraces) + &#039; if (&#039; + ($errs) + &#039; == errors) {&#039;;
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],25:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_multipleOf(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $isData = it.opts.v5 &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  out += &#039;var division&#039; + ($lvl) + &#039;;if (&#039;;
  if ($isData) {
    out += &#039; &#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; ( typeof &#039; + ($schemaValue) + &#039; != \&#039;number\&#039; || &#039;;
  }
  out += &#039; (division&#039; + ($lvl) + &#039; = &#039; + ($data) + &#039; / &#039; + ($schemaValue) + &#039;, &#039;;
  if (it.opts.multipleOfPrecision) {
    out += &#039; Math.abs(Math.round(division&#039; + ($lvl) + &#039;) - division&#039; + ($lvl) + &#039;) &gt; 1e-&#039; + (it.opts.multipleOfPrecision) + &#039; &#039;;
  } else {
    out += &#039; division&#039; + ($lvl) + &#039; !== parseInt(division&#039; + ($lvl) + &#039;) &#039;;
  }
  out += &#039; ) &#039;;
  if ($isData) {
    out += &#039;  )  &#039;;
  }
  out += &#039; ) {   &#039;;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;multipleOf&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { multipleOf: &#039; + ($schemaValue) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should be multiple of &#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue);
      } else {
        out += &#039;&#039; + ($schema) + &#039;\&#039;&#039;;
      }
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039;} &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],26:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_not(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  if (it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += &#039; var &#039; + ($errs) + &#039; = errors;  &#039;;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += &#039; &#039; + (it.validate($it)) + &#039; &#039;;
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += &#039; if (valid&#039; + ($it.level) + &#039;) {   &#039;;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = &#039;&#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;not&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: {} &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;should NOT be valid\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
      } else {
        out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
      }
    } else {
      out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    }
    out += &#039; } else {  errors = &#039; + ($errs) + &#039;; if (vErrors !== null) { if (&#039; + ($errs) + &#039;) vErrors.length = &#039; + ($errs) + &#039;; else vErrors = null; } &#039;;
    if (it.opts.allErrors) {
      out += &#039; } &#039;;
    }
  } else {
    out += &#039;  var err =   &#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;not&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: {} &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;should NOT be valid\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    if ($breakOnError) {
      out += &#039; if (false) { &#039;;
    }
  }
  return out;
}

},{}],27:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_oneOf(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  out += &#039;var &#039; + ($errs) + &#039; = errors;var prevValid&#039; + ($lvl) + &#039; = false;var &#039; + ($valid) + &#039; = false;&#039;;
  var $currentBaseId = $it.baseId;
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i &lt; l1) {
      $sch = arr1[$i += 1];
      if (it.util.schemaHasRules($sch, it.RULES.all)) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + &#039;[&#039; + $i + &#039;]&#039;;
        $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + $i;
        out += &#039;  &#039; + (it.validate($it)) + &#039; &#039;;
        $it.baseId = $currentBaseId;
      } else {
        out += &#039; var valid&#039; + ($it.level) + &#039; = true; &#039;;
      }
      if ($i) {
        out += &#039; if (valid&#039; + ($it.level) + &#039; &amp;&amp; prevValid&#039; + ($lvl) + &#039;) &#039; + ($valid) + &#039; = false; else { &#039;;
        $closingBraces += &#039;}&#039;;
      }
      out += &#039; if (valid&#039; + ($it.level) + &#039;) &#039; + ($valid) + &#039; = prevValid&#039; + ($lvl) + &#039; = true;&#039;;
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += &#039;&#039; + ($closingBraces) + &#039;if (!&#039; + ($valid) + &#039;) {   &#039;;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;oneOf&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: {} &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should match exactly one schema in oneOf\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039;} else {  errors = &#039; + ($errs) + &#039;; if (vErrors !== null) { if (&#039; + ($errs) + &#039;) vErrors.length = &#039; + ($errs) + &#039;; else vErrors = null; }&#039;;
  if (it.opts.allErrors) {
    out += &#039; } &#039;;
  }
  return out;
}

},{}],28:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_pattern(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $isData = it.opts.v5 &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? &#039;(new RegExp(&#039; + $schemaValue + &#039;))&#039; : it.usePattern($schema);
  out += &#039;if ( &#039;;
  if ($isData) {
    out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;string\&#039;) || &#039;;
  }
  out += &#039; !&#039; + ($regexp) + &#039;.test(&#039; + ($data) + &#039;) ) {   &#039;;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;pattern&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { pattern:  &#039;;
    if ($isData) {
      out += &#039;&#039; + ($schemaValue);
    } else {
      out += &#039;&#039; + (it.util.toQuotedString($schema));
    }
    out += &#039;  } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should match pattern &quot;&#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue) + &#039; + \&#039;&#039;;
      } else {
        out += &#039;&#039; + (it.util.escapeQuotes($schema));
      }
      out += &#039;&quot;\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + (it.util.toQuotedString($schema));
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039;} &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],29:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_patternRequired(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $key = &#039;key&#039; + $lvl,
    $matched = &#039;patternMatched&#039; + $lvl,
    $closingBraces = &#039;&#039;,
    $ownProperties = it.opts.ownProperties;
  out += &#039;var &#039; + ($valid) + &#039; = true;&#039;;
  var arr1 = $schema;
  if (arr1) {
    var $pProperty, i1 = -1,
      l1 = arr1.length - 1;
    while (i1 &lt; l1) {
      $pProperty = arr1[i1 += 1];
      out += &#039; var &#039; + ($matched) + &#039; = false; for (var &#039; + ($key) + &#039; in &#039; + ($data) + &#039;) {  &#039;;
      if ($ownProperties) {
        out += &#039; if (!Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, &#039; + ($key) + &#039;)) continue; &#039;;
      }
      out += &#039; &#039; + ($matched) + &#039; = &#039; + (it.usePattern($pProperty)) + &#039;.test(&#039; + ($key) + &#039;); if (&#039; + ($matched) + &#039;) break; } &#039;;
      var $missingPattern = it.util.escapeQuotes($pProperty);
      out += &#039; if (!&#039; + ($matched) + &#039;) { &#039; + ($valid) + &#039; = false;  var err =   &#039;; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;patternRequired&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { missingPattern: \&#039;&#039; + ($missingPattern) + &#039;\&#039; } &#039;;
        if (it.opts.messages !== false) {
          out += &#039; , message: \&#039;should have property matching pattern \\\&#039;&#039; + ($missingPattern) + &#039;\\\&#039;\&#039; &#039;;
        }
        if (it.opts.verbose) {
          out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
        }
        out += &#039; } &#039;;
      } else {
        out += &#039; {} &#039;;
      }
      out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; }   &#039;;
      if ($breakOnError) {
        $closingBraces += &#039;}&#039;;
        out += &#039; else { &#039;;
      }
    }
  }
  out += &#039;&#039; + ($closingBraces);
  return out;
}

},{}],30:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_properties(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  var $key = &#039;key&#039; + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = &#039;data&#039; + $dataNxt;
  var $schemaKeys = Object.keys($schema || {}),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == &#039;object&#039; &amp;&amp; Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required &amp;&amp; !(it.opts.v5 &amp;&amp; $required.$data) &amp;&amp; $required.length &lt; it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
  if (it.opts.v5) {
    var $pgProperties = it.schema.patternGroups || {},
      $pgPropertyKeys = Object.keys($pgProperties);
  }
  out += &#039;var &#039; + ($errs) + &#039; = errors;var valid&#039; + ($it.level) + &#039; = true;&#039;;
  if ($checkAdditional) {
    out += &#039; for (var &#039; + ($key) + &#039; in &#039; + ($data) + &#039;) {  &#039;;
    if ($ownProperties) {
      out += &#039; if (!Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, &#039; + ($key) + &#039;)) continue; &#039;;
    }
    if ($someProperties) {
      out += &#039; var isAdditional&#039; + ($lvl) + &#039; = !(false &#039;;
      if ($schemaKeys.length) {
        if ($schemaKeys.length &gt; 5) {
          out += &#039; || validate.schema&#039; + ($schemaPath) + &#039;[&#039; + ($key) + &#039;] &#039;;
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 &lt; l1) {
              $propertyKey = arr1[i1 += 1];
              out += &#039; || &#039; + ($key) + &#039; == &#039; + (it.util.toQuotedString($propertyKey)) + &#039; &#039;;
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i &lt; l2) {
            $pProperty = arr2[$i += 1];
            out += &#039; || &#039; + (it.usePattern($pProperty)) + &#039;.test(&#039; + ($key) + &#039;) &#039;;
          }
        }
      }
      if (it.opts.v5 &amp;&amp; $pgPropertyKeys &amp;&amp; $pgPropertyKeys.length) {
        var arr3 = $pgPropertyKeys;
        if (arr3) {
          var $pgProperty, $i = -1,
            l3 = arr3.length - 1;
          while ($i &lt; l3) {
            $pgProperty = arr3[$i += 1];
            out += &#039; || &#039; + (it.usePattern($pgProperty)) + &#039;.test(&#039; + ($key) + &#039;) &#039;;
          }
        }
      }
      out += &#039; ); if (isAdditional&#039; + ($lvl) + &#039;) { &#039;;
    }
    if ($removeAdditional == &#039;all&#039;) {
      out += &#039; delete &#039; + ($data) + &#039;[&#039; + ($key) + &#039;]; &#039;;
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = &#039;\&#039; + key&#039; + $lvl + &#039; + \&#039;&#039;;
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, &#039;key&#039; + $lvl, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += &#039; delete &#039; + ($data) + &#039;[&#039; + ($key) + &#039;]; &#039;;
        } else {
          out += &#039; valid&#039; + ($it.level) + &#039; = false; &#039;;
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + &#039;/additionalProperties&#039;;
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = &#039;&#039;; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;additionalProperties&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { additionalProperty: \&#039;&#039; + ($additionalProperty) + &#039;\&#039; } &#039;;
            if (it.opts.messages !== false) {
              out += &#039; , message: \&#039;should NOT have additional properties\&#039; &#039;;
            }
            if (it.opts.verbose) {
              out += &#039; , schema: false , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
            }
            out += &#039; } &#039;;
          } else {
            out += &#039; {} &#039;;
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
            if (it.async) {
              out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
            } else {
              out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
            }
          } else {
            out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += &#039; break; &#039;;
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == &#039;failing&#039;) {
          out += &#039; var &#039; + ($errs) + &#039; = errors;  &#039;;
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + &#039;.additionalProperties&#039;;
          $it.errSchemaPath = it.errSchemaPath + &#039;/additionalProperties&#039;;
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, &#039;key&#039; + $lvl, it.opts.jsonPointers);
          var $passData = $data + &#039;[key&#039; + $lvl + &#039;]&#039;;
          $it.dataPathArr[$dataNxt] = &#039;key&#039; + $lvl;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) &lt; 2) {
            out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
          } else {
            out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
          }
          out += &#039; if (!valid&#039; + ($it.level) + &#039;) { errors = &#039; + ($errs) + &#039;; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete &#039; + ($data) + &#039;[&#039; + ($key) + &#039;]; }  &#039;;
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + &#039;.additionalProperties&#039;;
          $it.errSchemaPath = it.errSchemaPath + &#039;/additionalProperties&#039;;
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, &#039;key&#039; + $lvl, it.opts.jsonPointers);
          var $passData = $data + &#039;[key&#039; + $lvl + &#039;]&#039;;
          $it.dataPathArr[$dataNxt] = &#039;key&#039; + $lvl;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) &lt; 2) {
            out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
          } else {
            out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
          }
          if ($breakOnError) {
            out += &#039; if (!valid&#039; + ($it.level) + &#039;) break; &#039;;
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += &#039; } &#039;;
    }
    out += &#039; }  &#039;;
    if ($breakOnError) {
      out += &#039; if (valid&#039; + ($it.level) + &#039;) { &#039;;
      $closingBraces += &#039;}&#039;;
    }
  }
  var $useDefaults = it.opts.useDefaults &amp;&amp; !it.compositeRule;
  if ($schemaKeys.length) {
    var arr4 = $schemaKeys;
    if (arr4) {
      var $propertyKey, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 &lt; l4) {
        $propertyKey = arr4[i4 += 1];
        var $sch = $schema[$propertyKey];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults &amp;&amp; $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) &lt; 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039;;
          }
          if ($hasDefault) {
            out += &#039; &#039; + ($code) + &#039; &#039;;
          } else {
            if ($requiredHash &amp;&amp; $requiredHash[$propertyKey]) {
              out += &#039; if (&#039; + ($useData) + &#039; === undefined) { valid&#039; + ($it.level) + &#039; = false; &#039;;
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + &#039;/required&#039;;
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = &#039;&#039;; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;required&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039; } &#039;;
                if (it.opts.messages !== false) {
                  out += &#039; , message: \&#039;&#039;;
                  if (it.opts._errorDataPathProperty) {
                    out += &#039;is a required property&#039;;
                  } else {
                    out += &#039;should have required property \\\&#039;&#039; + ($missingProperty) + &#039;\\\&#039;&#039;;
                  }
                  out += &#039;\&#039; &#039;;
                }
                if (it.opts.verbose) {
                  out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
                }
                out += &#039; } &#039;;
              } else {
                out += &#039; {} &#039;;
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
                if (it.async) {
                  out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
                } else {
                  out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
                }
              } else {
                out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += &#039; } else { &#039;;
            } else {
              if ($breakOnError) {
                out += &#039; if (&#039; + ($useData) + &#039; === undefined) { valid&#039; + ($it.level) + &#039; = true; } else { &#039;;
              } else {
                out += &#039; if (&#039; + ($useData) + &#039; !== undefined) { &#039;;
              }
            }
            out += &#039; &#039; + ($code) + &#039; } &#039;;
          }
        }
        if ($breakOnError) {
          out += &#039; if (valid&#039; + ($it.level) + &#039;) { &#039;;
          $closingBraces += &#039;}&#039;;
        }
      }
    }
  }
  var arr5 = $pPropertyKeys;
  if (arr5) {
    var $pProperty, i5 = -1,
      l5 = arr5.length - 1;
    while (i5 &lt; l5) {
      $pProperty = arr5[i5 += 1];
      var $sch = $pProperties[$pProperty];
      if (it.util.schemaHasRules($sch, it.RULES.all)) {
        $it.schema = $sch;
        $it.schemaPath = it.schemaPath + &#039;.patternProperties&#039; + it.util.getProperty($pProperty);
        $it.errSchemaPath = it.errSchemaPath + &#039;/patternProperties/&#039; + it.util.escapeFragment($pProperty);
        out += &#039; for (var &#039; + ($key) + &#039; in &#039; + ($data) + &#039;) {  &#039;;
        if ($ownProperties) {
          out += &#039; if (!Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, &#039; + ($key) + &#039;)) continue; &#039;;
        }
        out += &#039; if (&#039; + (it.usePattern($pProperty)) + &#039;.test(&#039; + ($key) + &#039;)) { &#039;;
        $it.errorPath = it.util.getPathExpr(it.errorPath, &#039;key&#039; + $lvl, it.opts.jsonPointers);
        var $passData = $data + &#039;[key&#039; + $lvl + &#039;]&#039;;
        $it.dataPathArr[$dataNxt] = &#039;key&#039; + $lvl;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) &lt; 2) {
          out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
        } else {
          out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
        }
        if ($breakOnError) {
          out += &#039; if (!valid&#039; + ($it.level) + &#039;) break; &#039;;
        }
        out += &#039; } &#039;;
        if ($breakOnError) {
          out += &#039; else valid&#039; + ($it.level) + &#039; = true; &#039;;
        }
        out += &#039; }  &#039;;
        if ($breakOnError) {
          out += &#039; if (valid&#039; + ($it.level) + &#039;) { &#039;;
          $closingBraces += &#039;}&#039;;
        }
      }
    }
  }
  if (it.opts.v5) {
    var arr6 = $pgPropertyKeys;
    if (arr6) {
      var $pgProperty, i6 = -1,
        l6 = arr6.length - 1;
      while (i6 &lt; l6) {
        $pgProperty = arr6[i6 += 1];
        var $pgSchema = $pgProperties[$pgProperty],
          $sch = $pgSchema.schema;
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + &#039;.patternGroups&#039; + it.util.getProperty($pgProperty) + &#039;.schema&#039;;
          $it.errSchemaPath = it.errSchemaPath + &#039;/patternGroups/&#039; + it.util.escapeFragment($pgProperty) + &#039;/schema&#039;;
          out += &#039; var pgPropCount&#039; + ($lvl) + &#039; = 0; for (var &#039; + ($key) + &#039; in &#039; + ($data) + &#039;) {  &#039;;
          if ($ownProperties) {
            out += &#039; if (!Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, &#039; + ($key) + &#039;)) continue; &#039;;
          }
          out += &#039; if (&#039; + (it.usePattern($pgProperty)) + &#039;.test(&#039; + ($key) + &#039;)) { pgPropCount&#039; + ($lvl) + &#039;++; &#039;;
          $it.errorPath = it.util.getPathExpr(it.errorPath, &#039;key&#039; + $lvl, it.opts.jsonPointers);
          var $passData = $data + &#039;[key&#039; + $lvl + &#039;]&#039;;
          $it.dataPathArr[$dataNxt] = &#039;key&#039; + $lvl;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) &lt; 2) {
            out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
          } else {
            out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
          }
          if ($breakOnError) {
            out += &#039; if (!valid&#039; + ($it.level) + &#039;) break; &#039;;
          }
          out += &#039; } &#039;;
          if ($breakOnError) {
            out += &#039; else valid&#039; + ($it.level) + &#039; = true; &#039;;
          }
          out += &#039; }  &#039;;
          if ($breakOnError) {
            out += &#039; if (valid&#039; + ($it.level) + &#039;) { &#039;;
            $closingBraces += &#039;}&#039;;
          }
          var $pgMin = $pgSchema.minimum,
            $pgMax = $pgSchema.maximum;
          if ($pgMin !== undefined || $pgMax !== undefined) {
            out += &#039; var &#039; + ($valid) + &#039; = true; &#039;;
            var $currErrSchemaPath = $errSchemaPath;
            if ($pgMin !== undefined) {
              var $limit = $pgMin,
                $reason = &#039;minimum&#039;,
                $moreOrLess = &#039;less&#039;;
              out += &#039; &#039; + ($valid) + &#039; = pgPropCount&#039; + ($lvl) + &#039; &gt;= &#039; + ($pgMin) + &#039;; &#039;;
              $errSchemaPath = it.errSchemaPath + &#039;/patternGroups/minimum&#039;;
              out += &#039;  if (!&#039; + ($valid) + &#039;) {   &#039;;
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = &#039;&#039;; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;patternGroups&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { reason: \&#039;&#039; + ($reason) + &#039;\&#039;, limit: &#039; + ($limit) + &#039;, pattern: \&#039;&#039; + (it.util.escapeQuotes($pgProperty)) + &#039;\&#039; } &#039;;
                if (it.opts.messages !== false) {
                  out += &#039; , message: \&#039;should NOT have &#039; + ($moreOrLess) + &#039; than &#039; + ($limit) + &#039; properties matching pattern &quot;&#039; + (it.util.escapeQuotes($pgProperty)) + &#039;&quot;\&#039; &#039;;
                }
                if (it.opts.verbose) {
                  out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
                }
                out += &#039; } &#039;;
              } else {
                out += &#039; {} &#039;;
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
                if (it.async) {
                  out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
                } else {
                  out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
                }
              } else {
                out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
              }
              out += &#039; } &#039;;
              if ($pgMax !== undefined) {
                out += &#039; else &#039;;
              }
            }
            if ($pgMax !== undefined) {
              var $limit = $pgMax,
                $reason = &#039;maximum&#039;,
                $moreOrLess = &#039;more&#039;;
              out += &#039; &#039; + ($valid) + &#039; = pgPropCount&#039; + ($lvl) + &#039; &lt;= &#039; + ($pgMax) + &#039;; &#039;;
              $errSchemaPath = it.errSchemaPath + &#039;/patternGroups/maximum&#039;;
              out += &#039;  if (!&#039; + ($valid) + &#039;) {   &#039;;
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = &#039;&#039;; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;patternGroups&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { reason: \&#039;&#039; + ($reason) + &#039;\&#039;, limit: &#039; + ($limit) + &#039;, pattern: \&#039;&#039; + (it.util.escapeQuotes($pgProperty)) + &#039;\&#039; } &#039;;
                if (it.opts.messages !== false) {
                  out += &#039; , message: \&#039;should NOT have &#039; + ($moreOrLess) + &#039; than &#039; + ($limit) + &#039; properties matching pattern &quot;&#039; + (it.util.escapeQuotes($pgProperty)) + &#039;&quot;\&#039; &#039;;
                }
                if (it.opts.verbose) {
                  out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
                }
                out += &#039; } &#039;;
              } else {
                out += &#039; {} &#039;;
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
                if (it.async) {
                  out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
                } else {
                  out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
                }
              } else {
                out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
              }
              out += &#039; } &#039;;
            }
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
              out += &#039; if (&#039; + ($valid) + &#039;) { &#039;;
              $closingBraces += &#039;}&#039;;
            }
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += &#039; &#039; + ($closingBraces) + &#039; if (&#039; + ($errs) + &#039; == errors) {&#039;;
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],31:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_ref(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $async, $refCode;
  if ($schema == &#039;#&#039; || $schema == &#039;#/&#039;) {
    if (it.isRoot) {
      $async = it.async;
      $refCode = &#039;validate&#039;;
    } else {
      $async = it.root.schema.$async === true;
      $refCode = &#039;root.refVal[0]&#039;;
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = &#039;can\&#039;t resolve reference &#039; + $schema + &#039; from id &#039; + it.baseId;
      if (it.opts.missingRefs == &#039;fail&#039;) {
        console.log($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = &#039;&#039;; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;$ref&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { ref: \&#039;&#039; + (it.util.escapeQuotes($schema)) + &#039;\&#039; } &#039;;
          if (it.opts.messages !== false) {
            out += &#039; , message: \&#039;can\\\&#039;t resolve reference &#039; + (it.util.escapeQuotes($schema)) + &#039;\&#039; &#039;;
          }
          if (it.opts.verbose) {
            out += &#039; , schema: &#039; + (it.util.toQuotedString($schema)) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
          }
          out += &#039; } &#039;;
        } else {
          out += &#039; {} &#039;;
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
          if (it.async) {
            out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
          } else {
            out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
          }
        } else {
          out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
        }
        if ($breakOnError) {
          out += &#039; if (false) { &#039;;
        }
      } else if (it.opts.missingRefs == &#039;ignore&#039;) {
        console.log($message);
        if ($breakOnError) {
          out += &#039; if (true) { &#039;;
        }
      } else {
        var $error = new Error($message);
        $error.missingRef = it.resolve.url(it.baseId, $schema);
        $error.missingSchema = it.resolve.normalizeId(it.resolve.fullPath($error.missingRef));
        throw $error;
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      $it.schema = $refVal.schema;
      $it.schemaPath = &#039;&#039;;
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += &#039; &#039; + ($code) + &#039; &#039;;
      if ($breakOnError) {
        out += &#039; if (valid&#039; + ($it.level) + &#039;) { &#039;;
      }
    } else {
      $async = $refVal.$async === true;
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = &#039;&#039;;
    if (it.opts.passContext) {
      out += &#039; &#039; + ($refCode) + &#039;.call(this, &#039;;
    } else {
      out += &#039; &#039; + ($refCode) + &#039;( &#039;;
    }
    out += &#039; &#039; + ($data) + &#039;, (dataPath || \&#039;\&#039;)&#039;;
    if (it.errorPath != &#039;&quot;&quot;&#039;) {
      out += &#039; + &#039; + (it.errorPath);
    }
    if ($dataLvl) {
      out += &#039; , data&#039; + (($dataLvl - 1) || &#039;&#039;) + &#039; , &#039; + (it.dataPathArr[$dataLvl]) + &#039; &#039;;
    } else {
      out += &#039; , parentData , parentDataProperty &#039;;
    }
    out += &#039;, rootData)  &#039;;
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error(&#039;async schema referenced by sync schema&#039;);
      out += &#039; try { &#039;;
      if ($breakOnError) {
        out += &#039;var &#039; + ($valid) + &#039; =&#039;;
      }
      out += &#039; &#039; + (it.yieldAwait) + &#039; &#039; + (__callValidate) + &#039;; } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; } &#039;;
      if ($breakOnError) {
        out += &#039; if (&#039; + ($valid) + &#039;) { &#039;;
      }
    } else {
      out += &#039; if (!&#039; + (__callValidate) + &#039;) { if (vErrors === null) vErrors = &#039; + ($refCode) + &#039;.errors; else vErrors = vErrors.concat(&#039; + ($refCode) + &#039;.errors); errors = vErrors.length; } &#039;;
      if ($breakOnError) {
        out += &#039; else { &#039;;
      }
    }
  }
  return out;
}

},{}],32:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_required(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $isData = it.opts.v5 &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!$isData) {
    if ($schema.length &lt; it.opts.loopRequired &amp;&amp; it.schema.properties &amp;&amp; Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 &lt; l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch &amp;&amp; it.util.schemaHasRules($propertySch, it.RULES.all))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length &gt;= it.opts.loopRequired;
    if ($breakOnError) {
      out += &#039; var missing&#039; + ($lvl) + &#039;; &#039;;
      if ($loopRequired) {
        if (!$isData) {
          out += &#039; var schema&#039; + ($lvl) + &#039; = validate.schema&#039; + ($schemaPath) + &#039;; &#039;;
        }
        var $i = &#039;i&#039; + $lvl,
          $propertyPath = &#039;schema&#039; + $lvl + &#039;[&#039; + $i + &#039;]&#039;,
          $missingProperty = &#039;\&#039; + &#039; + $propertyPath + &#039; + \&#039;&#039;;
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += &#039; var &#039; + ($valid) + &#039; = true; &#039;;
        if ($isData) {
          out += &#039; if (schema&#039; + ($lvl) + &#039; === undefined) &#039; + ($valid) + &#039; = true; else if (!Array.isArray(schema&#039; + ($lvl) + &#039;)) &#039; + ($valid) + &#039; = false; else {&#039;;
        }
        out += &#039; for (var &#039; + ($i) + &#039; = 0; &#039; + ($i) + &#039; &lt; schema&#039; + ($lvl) + &#039;.length; &#039; + ($i) + &#039;++) { &#039; + ($valid) + &#039; = &#039; + ($data) + &#039;[schema&#039; + ($lvl) + &#039;[&#039; + ($i) + &#039;]] !== undefined; if (!&#039; + ($valid) + &#039;) break; } &#039;;
        if ($isData) {
          out += &#039;  }  &#039;;
        }
        out += &#039;  if (!&#039; + ($valid) + &#039;) {   &#039;;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = &#039;&#039;; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;required&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039; } &#039;;
          if (it.opts.messages !== false) {
            out += &#039; , message: \&#039;&#039;;
            if (it.opts._errorDataPathProperty) {
              out += &#039;is a required property&#039;;
            } else {
              out += &#039;should have required property \\\&#039;&#039; + ($missingProperty) + &#039;\\\&#039;&#039;;
            }
            out += &#039;\&#039; &#039;;
          }
          if (it.opts.verbose) {
            out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
          }
          out += &#039; } &#039;;
        } else {
          out += &#039; {} &#039;;
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
          if (it.async) {
            out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
          } else {
            out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
          }
        } else {
          out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
        }
        out += &#039; } else { &#039;;
      } else {
        out += &#039; if ( &#039;;
        var arr2 = $required;
        if (arr2) {
          var _$property, $i = -1,
            l2 = arr2.length - 1;
          while ($i &lt; l2) {
            _$property = arr2[$i += 1];
            if ($i) {
              out += &#039; || &#039;;
            }
            var $prop = it.util.getProperty(_$property);
            out += &#039; ( &#039; + ($data) + ($prop) + &#039; === undefined &amp;&amp; (missing&#039; + ($lvl) + &#039; = &#039; + (it.util.toQuotedString(it.opts.jsonPointers ? _$property : $prop)) + &#039;) ) &#039;;
          }
        }
        out += &#039;) {  &#039;;
        var $propertyPath = &#039;missing&#039; + $lvl,
          $missingProperty = &#039;\&#039; + &#039; + $propertyPath + &#039; + \&#039;&#039;;
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + &#039; + &#039; + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = &#039;&#039;; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;required&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039; } &#039;;
          if (it.opts.messages !== false) {
            out += &#039; , message: \&#039;&#039;;
            if (it.opts._errorDataPathProperty) {
              out += &#039;is a required property&#039;;
            } else {
              out += &#039;should have required property \\\&#039;&#039; + ($missingProperty) + &#039;\\\&#039;&#039;;
            }
            out += &#039;\&#039; &#039;;
          }
          if (it.opts.verbose) {
            out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
          }
          out += &#039; } &#039;;
        } else {
          out += &#039; {} &#039;;
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
          if (it.async) {
            out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
          } else {
            out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
          }
        } else {
          out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
        }
        out += &#039; } else { &#039;;
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += &#039; var schema&#039; + ($lvl) + &#039; = validate.schema&#039; + ($schemaPath) + &#039;; &#039;;
        }
        var $i = &#039;i&#039; + $lvl,
          $propertyPath = &#039;schema&#039; + $lvl + &#039;[&#039; + $i + &#039;]&#039;,
          $missingProperty = &#039;\&#039; + &#039; + $propertyPath + &#039; + \&#039;&#039;;
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += &#039; if (schema&#039; + ($lvl) + &#039; &amp;&amp; !Array.isArray(schema&#039; + ($lvl) + &#039;)) {  var err =   &#039;; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;required&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039; } &#039;;
            if (it.opts.messages !== false) {
              out += &#039; , message: \&#039;&#039;;
              if (it.opts._errorDataPathProperty) {
                out += &#039;is a required property&#039;;
              } else {
                out += &#039;should have required property \\\&#039;&#039; + ($missingProperty) + &#039;\\\&#039;&#039;;
              }
              out += &#039;\&#039; &#039;;
            }
            if (it.opts.verbose) {
              out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
            }
            out += &#039; } &#039;;
          } else {
            out += &#039; {} &#039;;
          }
          out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (schema&#039; + ($lvl) + &#039; !== undefined) { &#039;;
        }
        out += &#039; for (var &#039; + ($i) + &#039; = 0; &#039; + ($i) + &#039; &lt; schema&#039; + ($lvl) + &#039;.length; &#039; + ($i) + &#039;++) { if (&#039; + ($data) + &#039;[schema&#039; + ($lvl) + &#039;[&#039; + ($i) + &#039;]] === undefined) {  var err =   &#039;; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;required&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039; } &#039;;
          if (it.opts.messages !== false) {
            out += &#039; , message: \&#039;&#039;;
            if (it.opts._errorDataPathProperty) {
              out += &#039;is a required property&#039;;
            } else {
              out += &#039;should have required property \\\&#039;&#039; + ($missingProperty) + &#039;\\\&#039;&#039;;
            }
            out += &#039;\&#039; &#039;;
          }
          if (it.opts.verbose) {
            out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
          }
          out += &#039; } &#039;;
        } else {
          out += &#039; {} &#039;;
        }
        out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } &#039;;
        if ($isData) {
          out += &#039;  }  &#039;;
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $reqProperty, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 &lt; l3) {
            $reqProperty = arr3[i3 += 1];
            var $prop = it.util.getProperty($reqProperty),
              $missingProperty = it.util.escapeQuotes($reqProperty);
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $reqProperty, it.opts.jsonPointers);
            }
            out += &#039; if (&#039; + ($data) + ($prop) + &#039; === undefined) {  var err =   &#039;; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;required&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039; } &#039;;
              if (it.opts.messages !== false) {
                out += &#039; , message: \&#039;&#039;;
                if (it.opts._errorDataPathProperty) {
                  out += &#039;is a required property&#039;;
                } else {
                  out += &#039;should have required property \\\&#039;&#039; + ($missingProperty) + &#039;\\\&#039;&#039;;
                }
                out += &#039;\&#039; &#039;;
              }
              if (it.opts.verbose) {
                out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
              }
              out += &#039; } &#039;;
            } else {
              out += &#039; {} &#039;;
            }
            out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } &#039;;
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += &#039; if (true) {&#039;;
  }
  return out;
}

},{}],33:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_switch(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  var $ifPassed = &#039;ifPassed&#039; + it.level,
    $currentBaseId = $it.baseId,
    $shouldContinue;
  out += &#039;var &#039; + ($ifPassed) + &#039;;&#039;;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $caseIndex = -1,
      l1 = arr1.length - 1;
    while ($caseIndex &lt; l1) {
      $sch = arr1[$caseIndex += 1];
      if ($caseIndex &amp;&amp; !$shouldContinue) {
        out += &#039; if (!&#039; + ($ifPassed) + &#039;) { &#039;;
        $closingBraces += &#039;}&#039;;
      }
      if ($sch.if &amp;&amp; it.util.schemaHasRules($sch.if, it.RULES.all)) {
        out += &#039; var &#039; + ($errs) + &#039; = errors;   &#039;;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        $it.schema = $sch.if;
        $it.schemaPath = $schemaPath + &#039;[&#039; + $caseIndex + &#039;].if&#039;;
        $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + $caseIndex + &#039;/if&#039;;
        out += &#039;  &#039; + (it.validate($it)) + &#039; &#039;;
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += &#039; &#039; + ($ifPassed) + &#039; = valid&#039; + ($it.level) + &#039;; if (&#039; + ($ifPassed) + &#039;) {  &#039;;
        if (typeof $sch.then == &#039;boolean&#039;) {
          if ($sch.then === false) {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = &#039;&#039;; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;switch&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { caseIndex: &#039; + ($caseIndex) + &#039; } &#039;;
              if (it.opts.messages !== false) {
                out += &#039; , message: \&#039;should pass &quot;switch&quot; keyword validation\&#039; &#039;;
              }
              if (it.opts.verbose) {
                out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
              }
              out += &#039; } &#039;;
            } else {
              out += &#039; {} &#039;;
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
              if (it.async) {
                out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
              } else {
                out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
              }
            } else {
              out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
            }
          }
          out += &#039; var valid&#039; + ($it.level) + &#039; = &#039; + ($sch.then) + &#039;; &#039;;
        } else {
          $it.schema = $sch.then;
          $it.schemaPath = $schemaPath + &#039;[&#039; + $caseIndex + &#039;].then&#039;;
          $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + $caseIndex + &#039;/then&#039;;
          out += &#039;  &#039; + (it.validate($it)) + &#039; &#039;;
          $it.baseId = $currentBaseId;
        }
        out += &#039;  } else {  errors = &#039; + ($errs) + &#039;; if (vErrors !== null) { if (&#039; + ($errs) + &#039;) vErrors.length = &#039; + ($errs) + &#039;; else vErrors = null; } } &#039;;
      } else {
        out += &#039; &#039; + ($ifPassed) + &#039; = true;  &#039;;
        if (typeof $sch.then == &#039;boolean&#039;) {
          if ($sch.then === false) {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = &#039;&#039;; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;switch&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { caseIndex: &#039; + ($caseIndex) + &#039; } &#039;;
              if (it.opts.messages !== false) {
                out += &#039; , message: \&#039;should pass &quot;switch&quot; keyword validation\&#039; &#039;;
              }
              if (it.opts.verbose) {
                out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
              }
              out += &#039; } &#039;;
            } else {
              out += &#039; {} &#039;;
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
              if (it.async) {
                out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
              } else {
                out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
              }
            } else {
              out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
            }
          }
          out += &#039; var valid&#039; + ($it.level) + &#039; = &#039; + ($sch.then) + &#039;; &#039;;
        } else {
          $it.schema = $sch.then;
          $it.schemaPath = $schemaPath + &#039;[&#039; + $caseIndex + &#039;].then&#039;;
          $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + $caseIndex + &#039;/then&#039;;
          out += &#039;  &#039; + (it.validate($it)) + &#039; &#039;;
          $it.baseId = $currentBaseId;
        }
      }
      $shouldContinue = $sch.continue
    }
  }
  out += &#039;&#039; + ($closingBraces) + &#039;var &#039; + ($valid) + &#039; = valid&#039; + ($it.level) + &#039;; &#039;;
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],34:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_uniqueItems(it, $keyword) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + &#039;.&#039; + $keyword;
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $isData = it.opts.v5 &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) &amp;&amp; it.opts.uniqueItems !== false) {
    if ($isData) {
      out += &#039; var &#039; + ($valid) + &#039;; if (&#039; + ($schemaValue) + &#039; === false || &#039; + ($schemaValue) + &#039; === undefined) &#039; + ($valid) + &#039; = true; else if (typeof &#039; + ($schemaValue) + &#039; != \&#039;boolean\&#039;) &#039; + ($valid) + &#039; = false; else { &#039;;
    }
    out += &#039; var &#039; + ($valid) + &#039; = true; if (&#039; + ($data) + &#039;.length &gt; 1) { var i = &#039; + ($data) + &#039;.length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal(&#039; + ($data) + &#039;[i], &#039; + ($data) + &#039;[j])) { &#039; + ($valid) + &#039; = false; break outer; } } } } &#039;;
    if ($isData) {
      out += &#039;  }  &#039;;
    }
    out += &#039; if (!&#039; + ($valid) + &#039;) {   &#039;;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = &#039;&#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;uniqueItems&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { i: i, j: j } &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;should NOT have duplicate items (items ## \&#039; + j + \&#039; and \&#039; + i + \&#039; are identical)\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema:  &#039;;
        if ($isData) {
          out += &#039;validate.schema&#039; + ($schemaPath);
        } else {
          out += &#039;&#039; + ($schema);
        }
        out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
      } else {
        out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
      }
    } else {
      out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    }
    out += &#039; } &#039;;
    if ($breakOnError) {
      out += &#039; else { &#039;;
    }
  } else {
    if ($breakOnError) {
      out += &#039; if (true) { &#039;;
    }
  }
  return out;
}

},{}],35:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_validate(it, $keyword) {
  var out = &#039;&#039;;
  var $async = it.schema.$async === true;
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = &#039;data&#039;;
    it.rootId = it.resolve.fullPath(it.root.schema.id);
    it.baseId = it.baseId || it.rootId;
    if ($async) {
      it.async = true;
      var $es7 = it.opts.async == &#039;es7&#039;;
      it.yieldAwait = $es7 ? &#039;await&#039; : &#039;yield&#039;;
    }
    delete it.isTop;
    it.dataPathArr = [undefined];
    out += &#039; var validate = &#039;;
    if ($async) {
      if ($es7) {
        out += &#039; (async function &#039;;
      } else {
        if (it.opts.async == &#039;co*&#039;) {
          out += &#039;co.wrap&#039;;
        }
        out += &#039;(function* &#039;;
      }
    } else {
      out += &#039; (function &#039;;
    }
    out += &#039; (data, dataPath, parentData, parentDataProperty, rootData) { \&#039;use strict\&#039;; var vErrors = null; &#039;;
    out += &#039; var errors = 0;     &#039;;
    out += &#039; if (rootData === undefined) rootData = data;&#039;;
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
    if (it.schema.id) it.baseId = it.resolve.url(it.baseId, it.schema.id);
    if ($async &amp;&amp; !it.async) throw new Error(&#039;async schema in sync schema&#039;);
    out += &#039; var errs_&#039; + ($lvl) + &#039; = errors;&#039;;
  }
  var $valid = &#039;valid&#039; + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = &#039;&#039;,
    $closingBraces2 = &#039;&#039;,
    $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema &amp;&amp; it.opts.coerceTypes) {
    var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    if ($coerceToTypes) {
      var $schemaPath = it.schemaPath + &#039;.type&#039;,
        $errSchemaPath = it.errSchemaPath + &#039;/type&#039;,
        $method = $typeIsArray ? &#039;checkDataTypes&#039; : &#039;checkDataType&#039;;
      out += &#039; if (&#039; + (it.util[$method]($typeSchema, $data, true)) + &#039;) {  &#039;;
      var $dataType = &#039;dataType&#039; + $lvl,
        $coerced = &#039;coerced&#039; + $lvl;
      out += &#039; var &#039; + ($dataType) + &#039; = typeof &#039; + ($data) + &#039;; &#039;;
      if (it.opts.coerceTypes == &#039;array&#039;) {
        out += &#039; if (&#039; + ($dataType) + &#039; == \&#039;object\&#039; &amp;&amp; Array.isArray(&#039; + ($data) + &#039;)) &#039; + ($dataType) + &#039; = \&#039;array\&#039;; &#039;;
      }
      out += &#039; var &#039; + ($coerced) + &#039; = undefined; &#039;;
      var $bracesCoercion = &#039;&#039;;
      var arr1 = $coerceToTypes;
      if (arr1) {
        var $type, $i = -1,
          l1 = arr1.length - 1;
        while ($i &lt; l1) {
          $type = arr1[$i += 1];
          if ($i) {
            out += &#039; if (&#039; + ($coerced) + &#039; === undefined) { &#039;;
            $bracesCoercion += &#039;}&#039;;
          }
          if (it.opts.coerceTypes == &#039;array&#039; &amp;&amp; $type != &#039;array&#039;) {
            out += &#039; if (&#039; + ($dataType) + &#039; == \&#039;array\&#039; &amp;&amp; &#039; + ($data) + &#039;.length == 1) { &#039; + ($coerced) + &#039; = &#039; + ($data) + &#039; = &#039; + ($data) + &#039;[0]; &#039; + ($dataType) + &#039; = typeof &#039; + ($data) + &#039;;  } &#039;;
          }
          if ($type == &#039;string&#039;) {
            out += &#039; if (&#039; + ($dataType) + &#039; == \&#039;number\&#039; || &#039; + ($dataType) + &#039; == \&#039;boolean\&#039;) &#039; + ($coerced) + &#039; = \&#039;\&#039; + &#039; + ($data) + &#039;; else if (&#039; + ($data) + &#039; === null) &#039; + ($coerced) + &#039; = \&#039;\&#039;; &#039;;
          } else if ($type == &#039;number&#039; || $type == &#039;integer&#039;) {
            out += &#039; if (&#039; + ($dataType) + &#039; == \&#039;boolean\&#039; || &#039; + ($data) + &#039; === null || (&#039; + ($dataType) + &#039; == \&#039;string\&#039; &amp;&amp; &#039; + ($data) + &#039; &amp;&amp; &#039; + ($data) + &#039; == +&#039; + ($data) + &#039; &#039;;
            if ($type == &#039;integer&#039;) {
              out += &#039; &amp;&amp; !(&#039; + ($data) + &#039; % 1)&#039;;
            }
            out += &#039;)) &#039; + ($coerced) + &#039; = +&#039; + ($data) + &#039;; &#039;;
          } else if ($type == &#039;boolean&#039;) {
            out += &#039; if (&#039; + ($data) + &#039; === \&#039;false\&#039; || &#039; + ($data) + &#039; === 0 || &#039; + ($data) + &#039; === null) &#039; + ($coerced) + &#039; = false; else if (&#039; + ($data) + &#039; === \&#039;true\&#039; || &#039; + ($data) + &#039; === 1) &#039; + ($coerced) + &#039; = true; &#039;;
          } else if ($type == &#039;null&#039;) {
            out += &#039; if (&#039; + ($data) + &#039; === \&#039;\&#039; || &#039; + ($data) + &#039; === 0 || &#039; + ($data) + &#039; === false) &#039; + ($coerced) + &#039; = null; &#039;;
          } else if (it.opts.coerceTypes == &#039;array&#039; &amp;&amp; $type == &#039;array&#039;) {
            out += &#039; if (&#039; + ($dataType) + &#039; == \&#039;string\&#039; || &#039; + ($dataType) + &#039; == \&#039;number\&#039; || &#039; + ($dataType) + &#039; == \&#039;boolean\&#039; || &#039; + ($data) + &#039; == null) &#039; + ($coerced) + &#039; = [&#039; + ($data) + &#039;]; &#039;;
          }
        }
      }
      out += &#039; &#039; + ($bracesCoercion) + &#039; if (&#039; + ($coerced) + &#039; === undefined) {   &#039;;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = &#039;&#039;; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;type&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { type: \&#039;&#039;;
        if ($typeIsArray) {
          out += &#039;&#039; + ($typeSchema.join(&quot;,&quot;));
        } else {
          out += &#039;&#039; + ($typeSchema);
        }
        out += &#039;\&#039; } &#039;;
        if (it.opts.messages !== false) {
          out += &#039; , message: \&#039;should be &#039;;
          if ($typeIsArray) {
            out += &#039;&#039; + ($typeSchema.join(&quot;,&quot;));
          } else {
            out += &#039;&#039; + ($typeSchema);
          }
          out += &#039;\&#039; &#039;;
        }
        if (it.opts.verbose) {
          out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
        }
        out += &#039; } &#039;;
      } else {
        out += &#039; {} &#039;;
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
        if (it.async) {
          out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
        } else {
          out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
        }
      } else {
        out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
      }
      out += &#039; } else { &#039;;
      if ($dataLvl) {
        var $parentData = &#039;data&#039; + (($dataLvl - 1) || &#039;&#039;),
          $dataProperty = it.dataPathArr[$dataLvl];
        out += &#039; &#039; + ($data) + &#039; = &#039; + ($parentData) + &#039;[&#039; + ($dataProperty) + &#039;] = &#039; + ($coerced) + &#039;; &#039;;
      } else {
        out += &#039; data = &#039; + ($coerced) + &#039;; if (parentData !== undefined) parentData[parentDataProperty] = &#039; + ($coerced) + &#039;; &#039;;
      }
      out += &#039; } } &#039;;
    }
  }
  var $refKeywords;
  if (it.schema.$ref &amp;&amp; ($refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, &#039;$ref&#039;))) {
    if (it.opts.extendRefs == &#039;fail&#039;) {
      throw new Error(&#039;$ref: validation keywords used in schema at &#039; + it.errorPath);
    } else if (it.opts.extendRefs == &#039;ignore&#039;) {
      $refKeywords = false;
      console.log(&#039;$ref: keywords ignored in schema at path&#039;, it.errorPath);
    } else {
      console.log(&#039;$ref: all keywords used in schema at path&#039;, it.errorPath, &#039;(it will change in the next major version, see issue #260)&#039;);
    }
  }
  if (it.schema.$ref &amp;&amp; !$refKeywords) {
    out += &#039; &#039; + (it.RULES.all.$ref.code(it, &#039;$ref&#039;)) + &#039; &#039;;
    if ($breakOnError) {
      out += &#039; } if (errors === &#039;;
      if ($top) {
        out += &#039;0&#039;;
      } else {
        out += &#039;errs_&#039; + ($lvl);
      }
      out += &#039;) { &#039;;
      $closingBraces2 += &#039;}&#039;;
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 &lt; l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += &#039; if (&#039; + (it.util.checkDataType($rulesGroup.type, $data)) + &#039;) { &#039;;
          }
          if (it.opts.useDefaults &amp;&amp; !it.compositeRule) {
            if ($rulesGroup.type == &#039;object&#039; &amp;&amp; it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 &lt; l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    out += &#039;  if (&#039; + ($passData) + &#039; === undefined) &#039; + ($passData) + &#039; = &#039;;
                    if (it.opts.useDefaults == &#039;shared&#039;) {
                      out += &#039; &#039; + (it.useDefault($sch.default)) + &#039; &#039;;
                    } else {
                      out += &#039; &#039; + (JSON.stringify($sch.default)) + &#039; &#039;;
                    }
                    out += &#039;; &#039;;
                  }
                }
              }
            } else if ($rulesGroup.type == &#039;array&#039; &amp;&amp; Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i &lt; l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + &#039;[&#039; + $i + &#039;]&#039;;
                    out += &#039;  if (&#039; + ($passData) + &#039; === undefined) &#039; + ($passData) + &#039; = &#039;;
                    if (it.opts.useDefaults == &#039;shared&#039;) {
                      out += &#039; &#039; + (it.useDefault($sch.default)) + &#039; &#039;;
                    } else {
                      out += &#039; &#039; + (JSON.stringify($sch.default)) + &#039; &#039;;
                    }
                    out += &#039;; &#039;;
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 &lt; l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                out += &#039; &#039; + ($rule.code(it, $rule.keyword)) + &#039; &#039;;
                if ($breakOnError) {
                  $closingBraces1 += &#039;}&#039;;
                }
              }
            }
          }
          if ($breakOnError) {
            out += &#039; &#039; + ($closingBraces1) + &#039; &#039;;
            $closingBraces1 = &#039;&#039;;
          }
          if ($rulesGroup.type) {
            out += &#039; } &#039;;
            if ($typeSchema &amp;&amp; $typeSchema === $rulesGroup.type) {
              var $typeChecked = true;
              out += &#039; else { &#039;;
              var $schemaPath = it.schemaPath + &#039;.type&#039;,
                $errSchemaPath = it.errSchemaPath + &#039;/type&#039;;
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = &#039;&#039;; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;type&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { type: \&#039;&#039;;
                if ($typeIsArray) {
                  out += &#039;&#039; + ($typeSchema.join(&quot;,&quot;));
                } else {
                  out += &#039;&#039; + ($typeSchema);
                }
                out += &#039;\&#039; } &#039;;
                if (it.opts.messages !== false) {
                  out += &#039; , message: \&#039;should be &#039;;
                  if ($typeIsArray) {
                    out += &#039;&#039; + ($typeSchema.join(&quot;,&quot;));
                  } else {
                    out += &#039;&#039; + ($typeSchema);
                  }
                  out += &#039;\&#039; &#039;;
                }
                if (it.opts.verbose) {
                  out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
                }
                out += &#039; } &#039;;
              } else {
                out += &#039; {} &#039;;
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
                if (it.async) {
                  out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
                } else {
                  out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
                }
              } else {
                out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
              }
              out += &#039; } &#039;;
            }
          }
          if ($breakOnError) {
            out += &#039; if (errors === &#039;;
            if ($top) {
              out += &#039;0&#039;;
            } else {
              out += &#039;errs_&#039; + ($lvl);
            }
            out += &#039;) { &#039;;
            $closingBraces2 += &#039;}&#039;;
          }
        }
      }
    }
  }
  if ($typeSchema &amp;&amp; !$typeChecked &amp;&amp; !(it.opts.coerceTypes &amp;&amp; $coerceToTypes)) {
    var $schemaPath = it.schemaPath + &#039;.type&#039;,
      $errSchemaPath = it.errSchemaPath + &#039;/type&#039;,
      $method = $typeIsArray ? &#039;checkDataTypes&#039; : &#039;checkDataType&#039;;
    out += &#039; if (&#039; + (it.util[$method]($typeSchema, $data, true)) + &#039;) {   &#039;;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = &#039;&#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;type&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &quot;&#039; + ($errSchemaPath) + &#039;&quot; , params: { type: \&#039;&#039;;
      if ($typeIsArray) {
        out += &#039;&#039; + ($typeSchema.join(&quot;,&quot;));
      } else {
        out += &#039;&#039; + ($typeSchema);
      }
      out += &#039;\&#039; } &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;should be &#039;;
        if ($typeIsArray) {
          out += &#039;&#039; + ($typeSchema.join(&quot;,&quot;));
        } else {
          out += &#039;&#039; + ($typeSchema);
        }
        out += &#039;\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule &amp;&amp; $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
      } else {
        out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
      }
    } else {
      out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    }
    out += &#039; }&#039;;
  }
  if ($breakOnError) {
    out += &#039; &#039; + ($closingBraces2) + &#039; &#039;;
  }
  if ($top) {
    if ($async) {
      out += &#039; if (errors === 0) return true;           &#039;;
      out += &#039; else throw new ValidationError(vErrors); &#039;;
    } else {
      out += &#039; validate.errors = vErrors; &#039;;
      out += &#039; return errors === 0;       &#039;;
    }
    out += &#039; }); return validate;&#039;;
  } else {
    out += &#039; var &#039; + ($valid) + &#039; = errors === errs_&#039; + ($lvl) + &#039;;&#039;;
  }
  out = it.util.cleanUpCode(out);
  if ($top &amp;&amp; $breakOnError) {
    out = it.util.cleanUpVarErrors(out, $async);
  }

  function $shouldUseGroup($rulesGroup) {
    for (var i = 0; i &lt; $rulesGroup.rules.length; i++)
      if ($shouldUseRule($rulesGroup.rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || ($rule.keyword == &#039;properties&#039; &amp;&amp; (it.schema.additionalProperties === false || typeof it.schema.additionalProperties == &#039;object&#039; || (it.schema.patternProperties &amp;&amp; Object.keys(it.schema.patternProperties).length) || (it.opts.v5 &amp;&amp; it.schema.patternGroups &amp;&amp; Object.keys(it.schema.patternGroups).length)));
  }
  return out;
}

},{}],36:[function(require,module,exports){
&#039;use strict&#039;;

var IDENTIFIER = /^[a-z_$][a-z0-9_$]*$/i;
var customRuleCode = require(&#039;./dotjs/custom&#039;);

/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be a valid identifier, should be different from all standard, custom and macro keywords.
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 */
module.exports = function addKeyword(keyword, definition) {
  /* eslint no-shadow: 0 */
  var self = this;
  if (this.RULES.keywords[keyword])
    throw new Error(&#039;Keyword &#039; + keyword + &#039; is already defined&#039;);

  if (!IDENTIFIER.test(keyword))
    throw new Error(&#039;Keyword &#039; + keyword + &#039; is not a valid identifier&#039;);

  if (definition) {
    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      var i, len = dataType.length;
      for (i=0; i&lt;len; i++) checkDataType(dataType[i]);
      for (i=0; i&lt;len; i++) _addRule(keyword, dataType[i], definition);
    } else {
      if (dataType) checkDataType(dataType);
      _addRule(keyword, dataType, definition);
    }

    var $data = definition.$data === true &amp;&amp; this._opts.v5;
    if ($data &amp;&amp; !definition.validate)
      throw new Error(&#039;$data support: neither &quot;validate&quot; nor &quot;compile&quot; functions are defined&#039;);

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if ($data) {
        metaSchema = {
          anyOf: [
            metaSchema,
            { &#039;$ref&#039;: &#039;https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json#/definitions/$data&#039; }
          ]
        };
      }
      definition.validateSchema = self.compile(metaSchema, true);
    }
  }

  this.RULES.keywords[keyword] = this.RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i=0; i&lt;self.RULES.length; i++) {
      var rg = self.RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      self.RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode
    };
    ruleGroup.rules.push(rule);
    self.RULES.custom[keyword] = rule;
  }


  function checkDataType(dataType) {
    if (!self.RULES.types[dataType]) throw new Error(&#039;Unknown type &#039; + dataType);
  }
};

},{&quot;./dotjs/custom&quot;:20}],37:[function(require,module,exports){
module.exports={
    &quot;id&quot;: &quot;http://json-schema.org/draft-04/schema#&quot;,
    &quot;$schema&quot;: &quot;http://json-schema.org/draft-04/schema#&quot;,
    &quot;description&quot;: &quot;Core schema meta-schema&quot;,
    &quot;definitions&quot;: {
        &quot;schemaArray&quot;: {
            &quot;type&quot;: &quot;array&quot;,
            &quot;minItems&quot;: 1,
            &quot;items&quot;: { &quot;$ref&quot;: &quot;#&quot; }
        },
        &quot;positiveInteger&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;minimum&quot;: 0
        },
        &quot;positiveIntegerDefault0&quot;: {
            &quot;allOf&quot;: [ { &quot;$ref&quot;: &quot;#/definitions/positiveInteger&quot; }, { &quot;default&quot;: 0 } ]
        },
        &quot;simpleTypes&quot;: {
            &quot;enum&quot;: [ &quot;array&quot;, &quot;boolean&quot;, &quot;integer&quot;, &quot;null&quot;, &quot;number&quot;, &quot;object&quot;, &quot;string&quot; ]
        },
        &quot;stringArray&quot;: {
            &quot;type&quot;: &quot;array&quot;,
            &quot;items&quot;: { &quot;type&quot;: &quot;string&quot; },
            &quot;minItems&quot;: 1,
            &quot;uniqueItems&quot;: true
        }
    },
    &quot;type&quot;: &quot;object&quot;,
    &quot;properties&quot;: {
        &quot;id&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;format&quot;: &quot;uri&quot;
        },
        &quot;$schema&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;format&quot;: &quot;uri&quot;
        },
        &quot;title&quot;: {
            &quot;type&quot;: &quot;string&quot;
        },
        &quot;description&quot;: {
            &quot;type&quot;: &quot;string&quot;
        },
        &quot;default&quot;: {},
        &quot;multipleOf&quot;: {
            &quot;type&quot;: &quot;number&quot;,
            &quot;minimum&quot;: 0,
            &quot;exclusiveMinimum&quot;: true
        },
        &quot;maximum&quot;: {
            &quot;type&quot;: &quot;number&quot;
        },
        &quot;exclusiveMaximum&quot;: {
            &quot;type&quot;: &quot;boolean&quot;,
            &quot;default&quot;: false
        },
        &quot;minimum&quot;: {
            &quot;type&quot;: &quot;number&quot;
        },
        &quot;exclusiveMinimum&quot;: {
            &quot;type&quot;: &quot;boolean&quot;,
            &quot;default&quot;: false
        },
        &quot;maxLength&quot;: { &quot;$ref&quot;: &quot;#/definitions/positiveInteger&quot; },
        &quot;minLength&quot;: { &quot;$ref&quot;: &quot;#/definitions/positiveIntegerDefault0&quot; },
        &quot;pattern&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;format&quot;: &quot;regex&quot;
        },
        &quot;additionalItems&quot;: {
            &quot;anyOf&quot;: [
                { &quot;type&quot;: &quot;boolean&quot; },
                { &quot;$ref&quot;: &quot;#&quot; }
            ],
            &quot;default&quot;: {}
        },
        &quot;items&quot;: {
            &quot;anyOf&quot;: [
                { &quot;$ref&quot;: &quot;#&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/schemaArray&quot; }
            ],
            &quot;default&quot;: {}
        },
        &quot;maxItems&quot;: { &quot;$ref&quot;: &quot;#/definitions/positiveInteger&quot; },
        &quot;minItems&quot;: { &quot;$ref&quot;: &quot;#/definitions/positiveIntegerDefault0&quot; },
        &quot;uniqueItems&quot;: {
            &quot;type&quot;: &quot;boolean&quot;,
            &quot;default&quot;: false
        },
        &quot;maxProperties&quot;: { &quot;$ref&quot;: &quot;#/definitions/positiveInteger&quot; },
        &quot;minProperties&quot;: { &quot;$ref&quot;: &quot;#/definitions/positiveIntegerDefault0&quot; },
        &quot;required&quot;: { &quot;$ref&quot;: &quot;#/definitions/stringArray&quot; },
        &quot;additionalProperties&quot;: {
            &quot;anyOf&quot;: [
                { &quot;type&quot;: &quot;boolean&quot; },
                { &quot;$ref&quot;: &quot;#&quot; }
            ],
            &quot;default&quot;: {}
        },
        &quot;definitions&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;additionalProperties&quot;: { &quot;$ref&quot;: &quot;#&quot; },
            &quot;default&quot;: {}
        },
        &quot;properties&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;additionalProperties&quot;: { &quot;$ref&quot;: &quot;#&quot; },
            &quot;default&quot;: {}
        },
        &quot;patternProperties&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;additionalProperties&quot;: { &quot;$ref&quot;: &quot;#&quot; },
            &quot;default&quot;: {}
        },
        &quot;dependencies&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;additionalProperties&quot;: {
                &quot;anyOf&quot;: [
                    { &quot;$ref&quot;: &quot;#&quot; },
                    { &quot;$ref&quot;: &quot;#/definitions/stringArray&quot; }
                ]
            }
        },
        &quot;enum&quot;: {
            &quot;type&quot;: &quot;array&quot;,
            &quot;minItems&quot;: 1,
            &quot;uniqueItems&quot;: true
        },
        &quot;type&quot;: {
            &quot;anyOf&quot;: [
                { &quot;$ref&quot;: &quot;#/definitions/simpleTypes&quot; },
                {
                    &quot;type&quot;: &quot;array&quot;,
                    &quot;items&quot;: { &quot;$ref&quot;: &quot;#/definitions/simpleTypes&quot; },
                    &quot;minItems&quot;: 1,
                    &quot;uniqueItems&quot;: true
                }
            ]
        },
        &quot;allOf&quot;: { &quot;$ref&quot;: &quot;#/definitions/schemaArray&quot; },
        &quot;anyOf&quot;: { &quot;$ref&quot;: &quot;#/definitions/schemaArray&quot; },
        &quot;oneOf&quot;: { &quot;$ref&quot;: &quot;#/definitions/schemaArray&quot; },
        &quot;not&quot;: { &quot;$ref&quot;: &quot;#&quot; }
    },
    &quot;dependencies&quot;: {
        &quot;exclusiveMaximum&quot;: [ &quot;maximum&quot; ],
        &quot;exclusiveMinimum&quot;: [ &quot;minimum&quot; ]
    },
    &quot;default&quot;: {}
}

},{}],38:[function(require,module,exports){
module.exports={
    &quot;id&quot;: &quot;https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json#&quot;,
    &quot;$schema&quot;: &quot;http://json-schema.org/draft-04/schema#&quot;,
    &quot;description&quot;: &quot;Core schema meta-schema (v5 proposals)&quot;,
    &quot;definitions&quot;: {
        &quot;schemaArray&quot;: {
            &quot;type&quot;: &quot;array&quot;,
            &quot;minItems&quot;: 1,
            &quot;items&quot;: { &quot;$ref&quot;: &quot;#&quot; }
        },
        &quot;positiveInteger&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;minimum&quot;: 0
        },
        &quot;positiveIntegerDefault0&quot;: {
            &quot;allOf&quot;: [ { &quot;$ref&quot;: &quot;#/definitions/positiveInteger&quot; }, { &quot;default&quot;: 0 } ]
        },
        &quot;simpleTypes&quot;: {
            &quot;enum&quot;: [ &quot;array&quot;, &quot;boolean&quot;, &quot;integer&quot;, &quot;null&quot;, &quot;number&quot;, &quot;object&quot;, &quot;string&quot; ]
        },
        &quot;stringArray&quot;: {
            &quot;type&quot;: &quot;array&quot;,
            &quot;items&quot;: { &quot;type&quot;: &quot;string&quot; },
            &quot;minItems&quot;: 1,
            &quot;uniqueItems&quot;: true
        },
        &quot;$data&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;required&quot;: [ &quot;$data&quot; ],
            &quot;properties&quot;: {
                &quot;$data&quot;: {
                    &quot;type&quot;: &quot;string&quot;,
                    &quot;anyOf&quot;: [
                        { &quot;format&quot;: &quot;relative-json-pointer&quot; }, 
                        { &quot;format&quot;: &quot;json-pointer&quot; }
                    ]
                }
            },
            &quot;additionalProperties&quot;: false
        }
    },
    &quot;type&quot;: &quot;object&quot;,
    &quot;properties&quot;: {
        &quot;id&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;format&quot;: &quot;uri&quot;
        },
        &quot;$schema&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;format&quot;: &quot;uri&quot;
        },
        &quot;title&quot;: {
            &quot;type&quot;: &quot;string&quot;
        },
        &quot;description&quot;: {
            &quot;type&quot;: &quot;string&quot;
        },
        &quot;default&quot;: {},
        &quot;multipleOf&quot;: {
            &quot;anyOf&quot;: [
                {
                    &quot;type&quot;: &quot;number&quot;,
                    &quot;minimum&quot;: 0,
                    &quot;exclusiveMinimum&quot;: true
                },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;maximum&quot;: {
            &quot;anyOf&quot;: [
                { &quot;type&quot;: &quot;number&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;exclusiveMaximum&quot;: {
            &quot;anyOf&quot;: [
                {
                    &quot;type&quot;: &quot;boolean&quot;,
                    &quot;default&quot;: false
                },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;minimum&quot;: {
            &quot;anyOf&quot;: [
                { &quot;type&quot;: &quot;number&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;exclusiveMinimum&quot;: {
            &quot;anyOf&quot;: [
                {
                    &quot;type&quot;: &quot;boolean&quot;,
                    &quot;default&quot;: false
                },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;maxLength&quot;: {
            &quot;anyOf&quot;: [
                { &quot;$ref&quot;: &quot;#/definitions/positiveInteger&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;minLength&quot;: {
            &quot;anyOf&quot;: [
                { &quot;$ref&quot;: &quot;#/definitions/positiveIntegerDefault0&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;pattern&quot;: {
            &quot;anyOf&quot;: [
                {
                    &quot;type&quot;: &quot;string&quot;,
                    &quot;format&quot;: &quot;regex&quot;
                },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;additionalItems&quot;: {
            &quot;anyOf&quot;: [
                { &quot;type&quot;: &quot;boolean&quot; },
                { &quot;$ref&quot;: &quot;#&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ],
            &quot;default&quot;: {}
        },
        &quot;items&quot;: {
            &quot;anyOf&quot;: [
                { &quot;$ref&quot;: &quot;#&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/schemaArray&quot; }
            ],
            &quot;default&quot;: {}
        },
        &quot;maxItems&quot;: {
            &quot;anyOf&quot;: [
                { &quot;$ref&quot;: &quot;#/definitions/positiveInteger&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;minItems&quot;: {
            &quot;anyOf&quot;: [
                { &quot;$ref&quot;: &quot;#/definitions/positiveIntegerDefault0&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;uniqueItems&quot;: {
            &quot;anyOf&quot;: [
                {
                    &quot;type&quot;: &quot;boolean&quot;,
                    &quot;default&quot;: false
                },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;maxProperties&quot;: {
            &quot;anyOf&quot;: [
                { &quot;$ref&quot;: &quot;#/definitions/positiveInteger&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;minProperties&quot;: {
            &quot;anyOf&quot;: [
                { &quot;$ref&quot;: &quot;#/definitions/positiveIntegerDefault0&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;required&quot;: {
            &quot;anyOf&quot;: [
                { &quot;$ref&quot;: &quot;#/definitions/stringArray&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;additionalProperties&quot;: {
            &quot;anyOf&quot;: [
                { &quot;type&quot;: &quot;boolean&quot; },
                { &quot;$ref&quot;: &quot;#&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ],
            &quot;default&quot;: {}
        },
        &quot;definitions&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;additionalProperties&quot;: { &quot;$ref&quot;: &quot;#&quot; },
            &quot;default&quot;: {}
        },
        &quot;properties&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;additionalProperties&quot;: { &quot;$ref&quot;: &quot;#&quot; },
            &quot;default&quot;: {}
        },
        &quot;patternProperties&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;additionalProperties&quot;: { &quot;$ref&quot;: &quot;#&quot; },
            &quot;default&quot;: {}
        },
        &quot;dependencies&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;additionalProperties&quot;: {
                &quot;anyOf&quot;: [
                    { &quot;$ref&quot;: &quot;#&quot; },
                    { &quot;$ref&quot;: &quot;#/definitions/stringArray&quot; }
                ]
            }
        },
        &quot;enum&quot;: {
            &quot;anyOf&quot;: [
                {
                    &quot;type&quot;: &quot;array&quot;,
                    &quot;minItems&quot;: 1,
                    &quot;uniqueItems&quot;: true
                },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;type&quot;: {
            &quot;anyOf&quot;: [
                { &quot;$ref&quot;: &quot;#/definitions/simpleTypes&quot; },
                {
                    &quot;type&quot;: &quot;array&quot;,
                    &quot;items&quot;: { &quot;$ref&quot;: &quot;#/definitions/simpleTypes&quot; },
                    &quot;minItems&quot;: 1,
                    &quot;uniqueItems&quot;: true
                }
            ]
        },
        &quot;allOf&quot;: { &quot;$ref&quot;: &quot;#/definitions/schemaArray&quot; },
        &quot;anyOf&quot;: { &quot;$ref&quot;: &quot;#/definitions/schemaArray&quot; },
        &quot;oneOf&quot;: { &quot;$ref&quot;: &quot;#/definitions/schemaArray&quot; },
        &quot;not&quot;: { &quot;$ref&quot;: &quot;#&quot; },
        &quot;format&quot;: {
            &quot;anyOf&quot;: [
                { &quot;type&quot;: &quot;string&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;formatMaximum&quot;: {
            &quot;anyOf&quot;: [
                { &quot;type&quot;: &quot;string&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;formatMinimum&quot;: {
            &quot;anyOf&quot;: [
                { &quot;type&quot;: &quot;string&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;formatExclusiveMaximum&quot;: {
            &quot;anyOf&quot;: [
                {
                    &quot;type&quot;: &quot;boolean&quot;,
                    &quot;default&quot;: false
                },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;formatExclusiveMinimum&quot;: {
            &quot;anyOf&quot;: [
                {
                    &quot;type&quot;: &quot;boolean&quot;,
                    &quot;default&quot;: false
                },
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;constant&quot;: {
            &quot;anyOf&quot;: [
                {},
                { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
            ]
        },
        &quot;contains&quot;: { &quot;$ref&quot;: &quot;#&quot; },
        &quot;patternGroups&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;additionalProperties&quot;: {
                &quot;type&quot;: &quot;object&quot;,
                &quot;required&quot;: [ &quot;schema&quot; ],
                &quot;properties&quot;: {
                    &quot;maximum&quot;: {
                        &quot;anyOf&quot;: [
                            { &quot;$ref&quot;: &quot;#/definitions/positiveInteger&quot; },
                            { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
                        ]
                    },
                    &quot;minimum&quot;: {
                        &quot;anyOf&quot;: [
                            { &quot;$ref&quot;: &quot;#/definitions/positiveIntegerDefault0&quot; },
                            { &quot;$ref&quot;: &quot;#/definitions/$data&quot; }
                        ]
                    },
                    &quot;schema&quot;: { &quot;$ref&quot;: &quot;#&quot; }
                },
                &quot;additionalProperties&quot;: false
            },
            &quot;default&quot;: {}
        },
        &quot;switch&quot;: {
            &quot;type&quot;: &quot;array&quot;,
            &quot;items&quot;: {
                &quot;required&quot;: [ &quot;then&quot; ],
                &quot;properties&quot;: {
                    &quot;if&quot;: { &quot;$ref&quot;: &quot;#&quot; },
                    &quot;then&quot;: {
                        &quot;anyOf&quot;: [
                            { &quot;type&quot;: &quot;boolean&quot; },
                            { &quot;$ref&quot;: &quot;#&quot; }
                        ]
                    },
                    &quot;continue&quot;: { &quot;type&quot;: &quot;boolean&quot; }
                },
                &quot;additionalProperties&quot;: false,
                &quot;dependencies&quot;: {
                    &quot;continue&quot;: [ &quot;if&quot; ]
                }
            }
        }
    },
    &quot;dependencies&quot;: {
        &quot;exclusiveMaximum&quot;: [ &quot;maximum&quot; ],
        &quot;exclusiveMinimum&quot;: [ &quot;minimum&quot; ],
        &quot;formatMaximum&quot;: [ &quot;format&quot; ],
        &quot;formatMinimum&quot;: [ &quot;format&quot; ],
        &quot;formatExclusiveMaximum&quot;: [ &quot;formatMaximum&quot; ],
        &quot;formatExclusiveMinimum&quot;: [ &quot;formatMinimum&quot; ]
    },
    &quot;default&quot;: {}
}

},{}],39:[function(require,module,exports){
&#039;use strict&#039;;

var META_SCHEMA_ID = &#039;https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json&#039;;

module.exports = {
  enable: enableV5,
  META_SCHEMA_ID: META_SCHEMA_ID
};


function enableV5(ajv) {
  var inlineFunctions = {
    &#039;switch&#039;: require(&#039;./dotjs/switch&#039;),
    &#039;constant&#039;: require(&#039;./dotjs/constant&#039;),
    &#039;_formatLimit&#039;: require(&#039;./dotjs/_formatLimit&#039;),
    &#039;patternRequired&#039;: require(&#039;./dotjs/patternRequired&#039;)
  };

  if (ajv._opts.meta !== false) {
    var metaSchema = require(&#039;./refs/json-schema-v5.json&#039;);
    ajv.addMetaSchema(metaSchema, META_SCHEMA_ID);
  }
  _addKeyword(&#039;constant&#039;);
  ajv.addKeyword(&#039;contains&#039;, { type: &#039;array&#039;, macro: containsMacro });

  _addKeyword(&#039;formatMaximum&#039;, &#039;string&#039;, inlineFunctions._formatLimit);
  _addKeyword(&#039;formatMinimum&#039;, &#039;string&#039;, inlineFunctions._formatLimit);
  ajv.addKeyword(&#039;formatExclusiveMaximum&#039;);
  ajv.addKeyword(&#039;formatExclusiveMinimum&#039;);

  ajv.addKeyword(&#039;patternGroups&#039;); // implemented in properties.jst
  _addKeyword(&#039;patternRequired&#039;, &#039;object&#039;);
  _addKeyword(&#039;switch&#039;);


  function _addKeyword(keyword, types, inlineFunc) {
    var definition = {
      inline: inlineFunc || inlineFunctions[keyword],
      statements: true,
      errors: &#039;full&#039;
    };
    if (types) definition.type = types;
    ajv.addKeyword(keyword, definition);
  }
}


function containsMacro(schema) {
  return {
    not: { items: { not: schema } }
  };
}

},{&quot;./dotjs/_formatLimit&quot;:12,&quot;./dotjs/constant&quot;:19,&quot;./dotjs/patternRequired&quot;:29,&quot;./dotjs/switch&quot;:33,&quot;./refs/json-schema-v5.json&quot;:38}],40:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == &#039;object&#039; &amp;&amp; exports &amp;&amp;
		!exports.nodeType &amp;&amp; exports;
	var freeModule = typeof module == &#039;object&#039; &amp;&amp; module &amp;&amp;
		!module.nodeType &amp;&amp; module;
	var freeGlobal = typeof global == &#039;object&#039; &amp;&amp; global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = &#039;-&#039;, // &#039;\x2D&#039;

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		&#039;overflow&#039;: &#039;Overflow: input needs wider integers to process&#039;,
		&#039;not-basic&#039;: &#039;Illegal input &gt;= 0x80 (not a basic code point)&#039;,
		&#039;invalid-input&#039;: &#039;Invalid input&#039;
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split(&#039;@&#039;);
		var result = &#039;&#039;;
		if (parts.length &gt; 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + &#039;@&#039;;
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, &#039;\x2E&#039;);
		var labels = string.split(&#039;.&#039;);
		var encoded = map(labels, fn).join(&#039;.&#039;);
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see &lt;https://mathiasbynens.be/notes/javascript-encoding&gt;
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter &lt; length) {
			value = string.charCodeAt(counter++);
			if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra &amp; 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = &#039;&#039;;
			if (value &gt; 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value &gt;&gt;&gt; 10 &amp; 0x3FF | 0xD800);
				value = 0xDC00 | value &amp; 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join(&#039;&#039;);
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 &lt; 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 &lt; 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 &lt; 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit &lt; 26) - ((flag != 0) &lt;&lt; 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta &gt;&gt; 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta &gt; baseMinusTMin * tMax &gt;&gt; 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don&#039;t use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic &lt; 0) {
			basic = 0;
		}

		for (j = 0; j &lt; basic; ++j) {
			// if it&#039;s not a basic code point
			if (input.charCodeAt(j) &gt;= 0x80) {
				error(&#039;not-basic&#039;);
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic &gt; 0 ? basic + 1 : 0; index &lt; inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index &gt;= inputLength) {
					error(&#039;invalid-input&#039;);
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit &gt;= base || digit &gt; floor((maxInt - i) / w)) {
					error(&#039;overflow&#039;);
				}

				i += digit * w;
				t = k &lt;= bias ? tMin : (k &gt;= bias + tMax ? tMax : k - bias);

				if (digit &lt; t) {
					break;
				}

				baseMinusT = base - t;
				if (w &gt; floor(maxInt / baseMinusT)) {
					error(&#039;overflow&#039;);
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we&#039;ll fix that now:
			if (floor(i / out) &gt; maxInt - n) {
				error(&#039;overflow&#039;);
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j &lt; inputLength; ++j) {
			currentValue = input[j];
			if (currentValue &lt; 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount &lt; inputLength) {

			// All non-basic code points &lt; n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j &lt; inputLength; ++j) {
				currentValue = input[j];
				if (currentValue &gt;= n &amp;&amp; currentValue &lt; m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder&#039;s &lt;n,i&gt; state to &lt;m,0&gt;,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n &gt; floor((maxInt - delta) / handledCPCountPlusOne)) {
				error(&#039;overflow&#039;);
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j &lt; inputLength; ++j) {
				currentValue = input[j];

				if (currentValue &lt; n &amp;&amp; ++delta &gt; maxInt) {
					error(&#039;overflow&#039;);
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k &lt;= bias ? tMin : (k &gt;= bias + tMax ? tMax : k - bias);
						if (q &lt; t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join(&#039;&#039;);
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn&#039;t matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn&#039;t matter if you call it with a domain that&#039;s already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? &#039;xn--&#039; + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		&#039;version&#039;: &#039;1.4.1&#039;,
		/**
		 * An object of methods to convert from JavaScript&#039;s internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see &lt;https://mathiasbynens.be/notes/javascript-encoding&gt;
		 * @memberOf punycode
		 * @type Object
		 */
		&#039;ucs2&#039;: {
			&#039;decode&#039;: ucs2decode,
			&#039;encode&#039;: ucs2encode
		},
		&#039;decode&#039;: decode,
		&#039;encode&#039;: encode,
		&#039;toASCII&#039;: toASCII,
		&#039;toUnicode&#039;: toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == &#039;function&#039; &amp;&amp;
		typeof define.amd == &#039;object&#039; &amp;&amp;
		define.amd
	) {
		define(&#039;punycode&#039;, function() {
			return punycode;
		});
	} else if (freeExports &amp;&amp; freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) &amp;&amp; (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{}],41:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// &quot;Software&quot;), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

&#039;use strict&#039;;

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || &#039;&amp;&#039;;
  eq = eq || &#039;=&#039;;
  var obj = {};

  if (typeof qs !== &#039;string&#039; || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options &amp;&amp; typeof options.maxKeys === &#039;number&#039;) {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys &lt;= 0 means that we should not limit keys count
  if (maxKeys &gt; 0 &amp;&amp; len &gt; maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i &lt; len; ++i) {
    var x = qs[i].replace(regexp, &#039;%20&#039;),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx &gt;= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = &#039;&#039;;
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === &#039;[object Array]&#039;;
};

},{}],42:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// &quot;Software&quot;), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

&#039;use strict&#039;;

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case &#039;string&#039;:
      return v;

    case &#039;boolean&#039;:
      return v ? &#039;true&#039; : &#039;false&#039;;

    case &#039;number&#039;:
      return isFinite(v) ? v : &#039;&#039;;

    default:
      return &#039;&#039;;
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || &#039;&amp;&#039;;
  eq = eq || &#039;=&#039;;
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === &#039;object&#039;) {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return &#039;&#039;;
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === &#039;[object Array]&#039;;
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i &lt; xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],43:[function(require,module,exports){
&#039;use strict&#039;;

exports.decode = exports.parse = require(&#039;./decode&#039;);
exports.encode = exports.stringify = require(&#039;./encode&#039;);

},{&quot;./decode&quot;:41,&quot;./encode&quot;:42}],44:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// &quot;Software&quot;), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

&#039;use strict&#039;;

var punycode = require(&#039;punycode&#039;);
var util = require(&#039;./util&#039;);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = [&#039;&lt;&#039;, &#039;&gt;&#039;, &#039;&quot;&#039;, &#039;`&#039;, &#039; &#039;, &#039;\r&#039;, &#039;\n&#039;, &#039;\t&#039;],

    // RFC 2396: characters not allowed for various reasons.
    unwise = [&#039;{&#039;, &#039;}&#039;, &#039;|&#039;, &#039;\\&#039;, &#039;^&#039;, &#039;`&#039;].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = [&#039;\&#039;&#039;].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = [&#039;%&#039;, &#039;/&#039;, &#039;?&#039;, &#039;;&#039;, &#039;#&#039;].concat(autoEscape),
    hostEndingChars = [&#039;/&#039;, &#039;?&#039;, &#039;#&#039;],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow &quot;unsafe&quot; and &quot;unwise&quot; chars.
    unsafeProtocol = {
      &#039;javascript&#039;: true,
      &#039;javascript:&#039;: true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      &#039;javascript&#039;: true,
      &#039;javascript:&#039;: true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      &#039;http&#039;: true,
      &#039;https&#039;: true,
      &#039;ftp&#039;: true,
      &#039;gopher&#039;: true,
      &#039;file&#039;: true,
      &#039;http:&#039;: true,
      &#039;https:&#039;: true,
      &#039;ftp:&#039;: true,
      &#039;gopher:&#039;: true,
      &#039;file:&#039;: true
    },
    querystring = require(&#039;querystring&#039;);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url &amp;&amp; util.isObject(url) &amp;&amp; url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError(&quot;Parameter &#039;url&#039; must be a string, not &quot; + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf(&#039;?&#039;),
      splitter =
          (queryIndex !== -1 &amp;&amp; queryIndex &lt; url.indexOf(&#039;#&#039;)) ? &#039;?&#039; : &#039;#&#039;,
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, &#039;/&#039;);
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like &quot;  http://foo.com  \n&quot;
  rest = rest.trim();

  if (!slashesDenoteHost &amp;&amp; url.split(&#039;#&#039;).length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = &#039;&#039;;
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it&#039;s got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that&#039;s
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === &#039;//&#039;;
    if (slashes &amp;&amp; !(proto &amp;&amp; hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &amp;&amp;
      (slashes || (proto &amp;&amp; !slashedProtocol[proto]))) {

    // there&#039;s a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ =&gt; user:a@b host:c
    // http://a@b?@c =&gt; user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i &lt; hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 &amp;&amp; (hostEnd === -1 || hec &lt; hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf(&#039;@&#039;);
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d =&gt; host:b auth:a path:/c@d
      atSign = rest.lastIndexOf(&#039;@&#039;, hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i &lt; nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 &amp;&amp; (hostEnd === -1 || hec &lt; hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we&#039;ve indicated that there is a hostname,
    // so even if it&#039;s empty, it has to be present.
    this.hostname = this.hostname || &#039;&#039;;

    // if hostname begins with [ and ends with ]
    // assume that it&#039;s an IPv6 address.
    var ipv6Hostname = this.hostname[0] === &#039;[&#039; &amp;&amp;
        this.hostname[this.hostname.length - 1] === &#039;]&#039;;

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i &lt; l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = &#039;&#039;;
          for (var j = 0, k = part.length; j &lt; k; j++) {
            if (part.charCodeAt(j) &gt; 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += &#039;x&#039;;
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = &#039;/&#039; + notHost.join(&#039;.&#039;) + rest;
            }
            this.hostname = validParts.join(&#039;.&#039;);
            break;
          }
        }
      }
    }

    if (this.hostname.length &gt; hostnameMaxLen) {
      this.hostname = &#039;&#039;;
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of &quot;domain&quot;.
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn&#039;t matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? &#039;:&#039; + this.port : &#039;&#039;;
    var h = this.hostname || &#039;&#039;;
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== &#039;/&#039;) {
        rest = &#039;/&#039; + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any &quot;autoEscape&quot; chars get
    // escaped, even if encodeURIComponent doesn&#039;t think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i &lt; l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf(&#039;#&#039;);
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf(&#039;?&#039;);
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = &#039;&#039;;
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &amp;&amp;
      this.hostname &amp;&amp; !this.pathname) {
    this.pathname = &#039;/&#039;;
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || &#039;&#039;;
    var s = this.search || &#039;&#039;;
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it&#039;s an object, and not a string url.
  // If it&#039;s an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || &#039;&#039;;
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, &#039;:&#039;);
    auth += &#039;@&#039;;
  }

  var protocol = this.protocol || &#039;&#039;,
      pathname = this.pathname || &#039;&#039;,
      hash = this.hash || &#039;&#039;,
      host = false,
      query = &#039;&#039;;

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(&#039;:&#039;) === -1 ?
        this.hostname :
        &#039;[&#039; + this.hostname + &#039;]&#039;);
    if (this.port) {
      host += &#039;:&#039; + this.port;
    }
  }

  if (this.query &amp;&amp;
      util.isObject(this.query) &amp;&amp;
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query &amp;&amp; (&#039;?&#039; + query)) || &#039;&#039;;

  if (protocol &amp;&amp; protocol.substr(-1) !== &#039;:&#039;) protocol += &#039;:&#039;;

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) &amp;&amp; host !== false) {
    host = &#039;//&#039; + (host || &#039;&#039;);
    if (pathname &amp;&amp; pathname.charAt(0) !== &#039;/&#039;) pathname = &#039;/&#039; + pathname;
  } else if (!host) {
    host = &#039;&#039;;
  }

  if (hash &amp;&amp; hash.charAt(0) !== &#039;#&#039;) hash = &#039;#&#039; + hash;
  if (search &amp;&amp; search.charAt(0) !== &#039;?&#039;) search = &#039;?&#039; + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace(&#039;#&#039;, &#039;%23&#039;);

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk &lt; tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href=&quot;&quot; will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there&#039;s nothing left to do here.
  if (relative.href === &#039;&#039;) {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes &amp;&amp; !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk &lt; rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== &#039;protocol&#039;)
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &amp;&amp;
        result.hostname &amp;&amp; !result.pathname) {
      result.path = result.pathname = &#039;/&#039;;
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol &amp;&amp; relative.protocol !== result.protocol) {
    // if it&#039;s a known url protocol, then changing
    // the protocol does weird things
    // first, if it&#039;s not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that&#039;s known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v &lt; keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host &amp;&amp; !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || &#039;&#039;).split(&#039;/&#039;);
      while (relPath.length &amp;&amp; !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = &#039;&#039;;
      if (!relative.hostname) relative.hostname = &#039;&#039;;
      if (relPath[0] !== &#039;&#039;) relPath.unshift(&#039;&#039;);
      if (relPath.length &lt; 2) relPath.unshift(&#039;&#039;);
      result.pathname = relPath.join(&#039;/&#039;);
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || &#039;&#039;;
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || &#039;&#039;;
      var s = result.search || &#039;&#039;;
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname &amp;&amp; result.pathname.charAt(0) === &#039;/&#039;),
      isRelAbs = (
          relative.host ||
          relative.pathname &amp;&amp; relative.pathname.charAt(0) === &#039;/&#039;
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host &amp;&amp; relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname &amp;&amp; result.pathname.split(&#039;/&#039;) || [],
      relPath = relative.pathname &amp;&amp; relative.pathname.split(&#039;/&#039;) || [],
      psychotic = result.protocol &amp;&amp; !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = &#039;&#039;;
    result.port = null;
    if (result.host) {
      if (srcPath[0] === &#039;&#039;) srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = &#039;&#039;;
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === &#039;&#039;) relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs &amp;&amp; (relPath[0] === &#039;&#039; || srcPath[0] === &#039;&#039;);
  }

  if (isRelAbs) {
    // it&#039;s absolute.
    result.host = (relative.host || relative.host === &#039;&#039;) ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === &#039;&#039;) ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it&#039;s relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href=&#039;?foo&#039;.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject(&#039;mailto:local1@domain1&#039;, &#039;local2@domain2&#039;)
      var authInHost = result.host &amp;&amp; result.host.indexOf(&#039;@&#039;) &gt; 0 ?
                       result.host.split(&#039;@&#039;) : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : &#039;&#039;) +
                    (result.search ? result.search : &#039;&#039;);
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we&#039;ve already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = &#039;/&#039; + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length &gt; 1) &amp;&amp;
      (last === &#039;.&#039; || last === &#039;..&#039;) || last === &#039;&#039;);

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up &gt; 0
  var up = 0;
  for (var i = srcPath.length; i &gt;= 0; i--) {
    last = srcPath[i];
    if (last === &#039;.&#039;) {
      srcPath.splice(i, 1);
    } else if (last === &#039;..&#039;) {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs &amp;&amp; !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift(&#039;..&#039;);
    }
  }

  if (mustEndAbs &amp;&amp; srcPath[0] !== &#039;&#039; &amp;&amp;
      (!srcPath[0] || srcPath[0].charAt(0) !== &#039;/&#039;)) {
    srcPath.unshift(&#039;&#039;);
  }

  if (hasTrailingSlash &amp;&amp; (srcPath.join(&#039;/&#039;).substr(-1) !== &#039;/&#039;)) {
    srcPath.push(&#039;&#039;);
  }

  var isAbsolute = srcPath[0] === &#039;&#039; ||
      (srcPath[0] &amp;&amp; srcPath[0].charAt(0) === &#039;/&#039;);

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? &#039;&#039; :
                                    srcPath.length ? srcPath.shift() : &#039;&#039;;
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject(&#039;mailto:local1@domain1&#039;, &#039;local2@domain2&#039;)
    var authInHost = result.host &amp;&amp; result.host.indexOf(&#039;@&#039;) &gt; 0 ?
                     result.host.split(&#039;@&#039;) : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host &amp;&amp; srcPath.length);

  if (mustEndAbs &amp;&amp; !isAbsolute) {
    srcPath.unshift(&#039;&#039;);
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join(&#039;/&#039;);
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : &#039;&#039;) +
                  (result.search ? result.search : &#039;&#039;);
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== &#039;:&#039;) {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{&quot;./util&quot;:45,&quot;punycode&quot;:40,&quot;querystring&quot;:43}],45:[function(require,module,exports){
&#039;use strict&#039;;

module.exports = {
  isString: function(arg) {
    return typeof(arg) === &#039;string&#039;;
  },
  isObject: function(arg) {
    return typeof(arg) === &#039;object&#039; &amp;&amp; arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],46:[function(require,module,exports){

/**
 * slice() reference.
 */

var slice = Array.prototype.slice;

/**
 * Expose `co`.
 */

module.exports = co[&#039;default&#039;] = co.co = co;

/**
 * Wrap the given generator `fn` into a
 * function that returns a promise.
 * This is a separate function so that
 * every `co()` call doesn&#039;t create a new,
 * unnecessary closure.
 *
 * @param {GeneratorFunction} fn
 * @return {Function}
 * @api public
 */

co.wrap = function (fn) {
  createPromise.__generatorFunction__ = fn;
  return createPromise;
  function createPromise() {
    return co.call(this, fn.apply(this, arguments));
  }
};

/**
 * Execute the generator function or a generator
 * and return a promise.
 *
 * @param {Function} fn
 * @return {Promise}
 * @api public
 */

function co(gen) {
  var ctx = this;
  var args = slice.call(arguments, 1)

  // we wrap everything in a promise to avoid promise chaining,
  // which leads to memory leak errors.
  // see https://github.com/tj/co/issues/180
  return new Promise(function(resolve, reject) {
    if (typeof gen === &#039;function&#039;) gen = gen.apply(ctx, args);
    if (!gen || typeof gen.next !== &#039;function&#039;) return resolve(gen);

    onFulfilled();

    /**
     * @param {Mixed} res
     * @return {Promise}
     * @api private
     */

    function onFulfilled(res) {
      var ret;
      try {
        ret = gen.next(res);
      } catch (e) {
        return reject(e);
      }
      next(ret);
    }

    /**
     * @param {Error} err
     * @return {Promise}
     * @api private
     */

    function onRejected(err) {
      var ret;
      try {
        ret = gen.throw(err);
      } catch (e) {
        return reject(e);
      }
      next(ret);
    }

    /**
     * Get the next value in the generator,
     * return a promise.
     *
     * @param {Object} ret
     * @return {Promise}
     * @api private
     */

    function next(ret) {
      if (ret.done) return resolve(ret.value);
      var value = toPromise.call(ctx, ret.value);
      if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);
      return onRejected(new TypeError(&#039;You may only yield a function, promise, generator, array, or object, &#039;
        + &#039;but the following object was passed: &quot;&#039; + String(ret.value) + &#039;&quot;&#039;));
    }
  });
}

/**
 * Convert a `yield`ed value into a promise.
 *
 * @param {Mixed} obj
 * @return {Promise}
 * @api private
 */

function toPromise(obj) {
  if (!obj) return obj;
  if (isPromise(obj)) return obj;
  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
  if (&#039;function&#039; == typeof obj) return thunkToPromise.call(this, obj);
  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
  if (isObject(obj)) return objectToPromise.call(this, obj);
  return obj;
}

/**
 * Convert a thunk to a promise.
 *
 * @param {Function}
 * @return {Promise}
 * @api private
 */

function thunkToPromise(fn) {
  var ctx = this;
  return new Promise(function (resolve, reject) {
    fn.call(ctx, function (err, res) {
      if (err) return reject(err);
      if (arguments.length &gt; 2) res = slice.call(arguments, 1);
      resolve(res);
    });
  });
}

/**
 * Convert an array of &quot;yieldables&quot; to a promise.
 * Uses `Promise.all()` internally.
 *
 * @param {Array} obj
 * @return {Promise}
 * @api private
 */

function arrayToPromise(obj) {
  return Promise.all(obj.map(toPromise, this));
}

/**
 * Convert an object of &quot;yieldables&quot; to a promise.
 * Uses `Promise.all()` internally.
 *
 * @param {Object} obj
 * @return {Promise}
 * @api private
 */

function objectToPromise(obj){
  var results = new obj.constructor();
  var keys = Object.keys(obj);
  var promises = [];
  for (var i = 0; i &lt; keys.length; i++) {
    var key = keys[i];
    var promise = toPromise.call(this, obj[key]);
    if (promise &amp;&amp; isPromise(promise)) defer(promise, key);
    else results[key] = obj[key];
  }
  return Promise.all(promises).then(function () {
    return results;
  });

  function defer(promise, key) {
    // predefine the key in the result
    results[key] = undefined;
    promises.push(promise.then(function (res) {
      results[key] = res;
    }));
  }
}

/**
 * Check if `obj` is a promise.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isPromise(obj) {
  return &#039;function&#039; == typeof obj.then;
}

/**
 * Check if `obj` is a generator.
 *
 * @param {Mixed} obj
 * @return {Boolean}
 * @api private
 */

function isGenerator(obj) {
  return &#039;function&#039; == typeof obj.next &amp;&amp; &#039;function&#039; == typeof obj.throw;
}

/**
 * Check if `obj` is a generator function.
 *
 * @param {Mixed} obj
 * @return {Boolean}
 * @api private
 */
function isGeneratorFunction(obj) {
  var constructor = obj.constructor;
  if (!constructor) return false;
  if (&#039;GeneratorFunction&#039; === constructor.name || &#039;GeneratorFunction&#039; === constructor.displayName) return true;
  return isGenerator(constructor.prototype);
}

/**
 * Check for plain object.
 *
 * @param {Mixed} val
 * @return {Boolean}
 * @api private
 */

function isObject(val) {
  return Object == val.constructor;
}

},{}],47:[function(require,module,exports){
var json = typeof JSON !== &#039;undefined&#039; ? JSON : require(&#039;jsonify&#039;);

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === &#039;function&#039;) opts = { cmp: opts };
    var space = opts.space || &#039;&#039;;
    if (typeof space === &#039;number&#039;) space = Array(space+1).join(&#039; &#039;);
    var cycles = (typeof opts.cycles === &#039;boolean&#039;) ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp &amp;&amp; (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? (&#039;\n&#039; + new Array(level + 1).join(space)) : &#039;&#039;;
        var colonSeparator = space ? &#039;: &#039; : &#039;:&#039;;

        if (node &amp;&amp; node.toJSON &amp;&amp; typeof node.toJSON === &#039;function&#039;) {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== &#039;object&#039; || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i &lt; node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return &#039;[&#039; + out.join(&#039;,&#039;) + indent + &#039;]&#039;;
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify(&#039;__cycle__&#039;);
                throw new TypeError(&#039;Converting circular structure to JSON&#039;);
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp &amp;&amp; cmp(node));
            var out = [];
            for (var i = 0; i &lt; keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return &#039;{&#039; + out.join(&#039;,&#039;) + indent + &#039;}&#039;;
        }
    })({ &#039;&#039;: obj }, &#039;&#039;, obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === &#039;[object Array]&#039;;
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

},{&quot;jsonify&quot;:48}],48:[function(require,module,exports){
exports.parse = require(&#039;./lib/parse&#039;);
exports.stringify = require(&#039;./lib/stringify&#039;);

},{&quot;./lib/parse&quot;:49,&quot;./lib/stringify&quot;:50}],49:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        &#039;&quot;&#039;:  &#039;&quot;&#039;,
        &#039;\\&#039;: &#039;\\&#039;,
        &#039;/&#039;:  &#039;/&#039;,
        b:    &#039;\b&#039;,
        f:    &#039;\f&#039;,
        n:    &#039;\n&#039;,
        r:    &#039;\r&#039;,
        t:    &#039;\t&#039;
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    &#039;SyntaxError&#039;,
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c &amp;&amp; c !== ch) {
            error(&quot;Expected &#039;&quot; + c + &quot;&#039; instead of &#039;&quot; + ch + &quot;&#039;&quot;);
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = &#039;&#039;;
        
        if (ch === &#039;-&#039;) {
            string = &#039;-&#039;;
            next(&#039;-&#039;);
        }
        while (ch &gt;= &#039;0&#039; &amp;&amp; ch &lt;= &#039;9&#039;) {
            string += ch;
            next();
        }
        if (ch === &#039;.&#039;) {
            string += &#039;.&#039;;
            while (next() &amp;&amp; ch &gt;= &#039;0&#039; &amp;&amp; ch &lt;= &#039;9&#039;) {
                string += ch;
            }
        }
        if (ch === &#039;e&#039; || ch === &#039;E&#039;) {
            string += ch;
            next();
            if (ch === &#039;-&#039; || ch === &#039;+&#039;) {
                string += ch;
                next();
            }
            while (ch &gt;= &#039;0&#039; &amp;&amp; ch &lt;= &#039;9&#039;) {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error(&quot;Bad number&quot;);
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = &#039;&#039;,
            uffff;
        
        // When parsing for string values, we must look for &quot; and \ characters.
        if (ch === &#039;&quot;&#039;) {
            while (next()) {
                if (ch === &#039;&quot;&#039;) {
                    next();
                    return string;
                } else if (ch === &#039;\\&#039;) {
                    next();
                    if (ch === &#039;u&#039;) {
                        uffff = 0;
                        for (i = 0; i &lt; 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === &#039;string&#039;) {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error(&quot;Bad string&quot;);
    },

    white = function () {

// Skip whitespace.

        while (ch &amp;&amp; ch &lt;= &#039; &#039;) {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case &#039;t&#039;:
            next(&#039;t&#039;);
            next(&#039;r&#039;);
            next(&#039;u&#039;);
            next(&#039;e&#039;);
            return true;
        case &#039;f&#039;:
            next(&#039;f&#039;);
            next(&#039;a&#039;);
            next(&#039;l&#039;);
            next(&#039;s&#039;);
            next(&#039;e&#039;);
            return false;
        case &#039;n&#039;:
            next(&#039;n&#039;);
            next(&#039;u&#039;);
            next(&#039;l&#039;);
            next(&#039;l&#039;);
            return null;
        }
        error(&quot;Unexpected &#039;&quot; + ch + &quot;&#039;&quot;);
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === &#039;[&#039;) {
            next(&#039;[&#039;);
            white();
            if (ch === &#039;]&#039;) {
                next(&#039;]&#039;);
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === &#039;]&#039;) {
                    next(&#039;]&#039;);
                    return array;
                }
                next(&#039;,&#039;);
                white();
            }
        }
        error(&quot;Bad array&quot;);
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === &#039;{&#039;) {
            next(&#039;{&#039;);
            white();
            if (ch === &#039;}&#039;) {
                next(&#039;}&#039;);
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(&#039;:&#039;);
                if (Object.hasOwnProperty.call(object, key)) {
                    error(&#039;Duplicate key &quot;&#039; + key + &#039;&quot;&#039;);
                }
                object[key] = value();
                white();
                if (ch === &#039;}&#039;) {
                    next(&#039;}&#039;);
                    return object;
                }
                next(&#039;,&#039;);
                white();
            }
        }
        error(&quot;Bad object&quot;);
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case &#039;{&#039;:
        return object();
    case &#039;[&#039;:
        return array();
    case &#039;&quot;&#039;:
        return string();
    case &#039;-&#039;:
        return number();
    default:
        return ch &gt;= &#039;0&#039; &amp;&amp; ch &lt;= &#039;9&#039; ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = &#039; &#039;;
    result = value();
    white();
    if (ch) {
        error(&quot;Syntax error&quot;);
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === &#039;function&#039; ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value &amp;&amp; typeof value === &#039;object&#039;) {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({&#039;&#039;: result}, &#039;&#039;)) : result;
};

},{}],50:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\&quot;\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        &#039;\b&#039;: &#039;\\b&#039;,
        &#039;\t&#039;: &#039;\\t&#039;,
        &#039;\n&#039;: &#039;\\n&#039;,
        &#039;\f&#039;: &#039;\\f&#039;,
        &#039;\r&#039;: &#039;\\r&#039;,
        &#039;&quot;&#039; : &#039;\\&quot;&#039;,
        &#039;\\&#039;: &#039;\\\\&#039;
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? &#039;&quot;&#039; + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === &#039;string&#039; ? c :
            &#039;\\u&#039; + (&#039;0000&#039; + a.charCodeAt(0).toString(16)).slice(-4);
    }) + &#039;&quot;&#039; : &#039;&quot;&#039; + string + &#039;&quot;&#039;;
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value &amp;&amp; typeof value === &#039;object&#039; &amp;&amp;
            typeof value.toJSON === &#039;function&#039;) {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === &#039;function&#039;) {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value&#039;s type.
    switch (typeof value) {
        case &#039;string&#039;:
            return quote(value);
        
        case &#039;number&#039;:
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : &#039;null&#039;;
        
        case &#039;boolean&#039;:
        case &#039;null&#039;:
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce &#039;null&#039;. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case &#039;object&#039;:
            if (!value) return &#039;null&#039;;
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === &#039;[object Array]&#039;) {
                length = value.length;
                for (i = 0; i &lt; length; i += 1) {
                    partial[i] = str(i, value) || &#039;null&#039;;
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? &#039;[]&#039; : gap ?
                    &#039;[\n&#039; + gap + partial.join(&#039;,\n&#039; + gap) + &#039;\n&#039; + mind + &#039;]&#039; :
                    &#039;[&#039; + partial.join(&#039;,&#039;) + &#039;]&#039;;
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep &amp;&amp; typeof rep === &#039;object&#039;) {
                length = rep.length;
                for (i = 0; i &lt; length; i += 1) {
                    k = rep[i];
                    if (typeof k === &#039;string&#039;) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? &#039;: &#039; : &#039;:&#039;) + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? &#039;: &#039; : &#039;:&#039;) + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? &#039;{}&#039; : gap ?
            &#039;{\n&#039; + gap + partial.join(&#039;,\n&#039; + gap) + &#039;\n&#039; + mind + &#039;}&#039; :
            &#039;{&#039; + partial.join(&#039;,&#039;) + &#039;}&#039;;
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = &#039;&#039;;
    indent = &#039;&#039;;
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === &#039;number&#039;) {
        for (i = 0; i &lt; space; i += 1) {
            indent += &#039; &#039;;
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === &#039;string&#039;) {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer &amp;&amp; typeof replacer !== &#039;function&#039;
    &amp;&amp; (typeof replacer !== &#039;object&#039; || typeof replacer.length !== &#039;number&#039;)) {
        throw new Error(&#039;JSON.stringify&#039;);
    }
    
    // Make a fake root object containing our value under the key of &#039;&#039;.
    // Return the result of stringifying the value.
    return str(&#039;&#039;, {&#039;&#039;: value});
};

},{}],&quot;ajv&quot;:[function(require,module,exports){
&#039;use strict&#039;;

var compileSchema = require(&#039;./compile&#039;)
  , resolve = require(&#039;./compile/resolve&#039;)
  , Cache = require(&#039;./cache&#039;)
  , SchemaObject = require(&#039;./compile/schema_obj&#039;)
  , stableStringify = require(&#039;json-stable-stringify&#039;)
  , formats = require(&#039;./compile/formats&#039;)
  , rules = require(&#039;./compile/rules&#039;)
  , v5 = require(&#039;./v5&#039;)
  , util = require(&#039;./compile/util&#039;)
  , async = require(&#039;./async&#039;)
  , co = require(&#039;co&#039;);

module.exports = Ajv;

Ajv.prototype.compileAsync = async.compile;
Ajv.prototype.addKeyword = require(&#039;./keyword&#039;);
Ajv.ValidationError = require(&#039;./compile/validation_error&#039;);

var META_SCHEMA_ID = &#039;http://json-schema.org/draft-04/schema&#039;;
var SCHEMA_URI_FORMAT = /^(?:(?:[a-z][a-z0-9+-.]*:)?\/\/)?[^\s]*$/i;
function SCHEMA_URI_FORMAT_FUNC(str) {
  return SCHEMA_URI_FORMAT.test(str);
}

var META_IGNORE_OPTIONS = [ &#039;removeAdditional&#039;, &#039;useDefaults&#039;, &#039;coerceTypes&#039; ];

/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  var self = this;

  opts = this._opts = util.copy(opts) || {};
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);
  this._cache = opts.cache || new Cache;
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();

  // this is done on purpose, so that methods are bound to the instance
  // (without using bind) so that they can be used without the instance
  this.validate = validate;
  this.compile = compile;
  this.addSchema = addSchema;
  this.addMetaSchema = addMetaSchema;
  this.validateSchema = validateSchema;
  this.getSchema = getSchema;
  this.removeSchema = removeSchema;
  this.addFormat = addFormat;
  this.errorsText = errorsText;

  this._addSchema = _addSchema;
  this._compile = _compile;

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.async || opts.transpile) async.setup(opts);
  if (opts.beautify === true) opts.beautify = { indent_size: 2 };
  if (opts.errorDataPath == &#039;property&#039;) opts._errorDataPathProperty = true;
  if (opts.extendRefs === undefined) opts.extendRefs = true;
  this._metaOpts = getMetaSchemaOptions();

  if (opts.formats) addInitialFormats();
  addDraft4MetaSchema();
  if (opts.v5) v5.enable(this);
  if (typeof opts.meta == &#039;object&#039;) addMetaSchema(opts.meta);
  addInitialSchemas();


  /**
   * Validate data using schema
   * Schema will be compiled and cached (using serialized JSON as key. [json-stable-stringify](https://github.com/substack/json-stable-stringify) is used to serialize.
   * @param  {String|Object} schemaKeyRef key, ref or schema object
   * @param  {Any} data to be validated
   * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
   */
  function validate(schemaKeyRef, data) {
    var v;
    if (typeof schemaKeyRef == &#039;string&#039;) {
      v = getSchema(schemaKeyRef);
      if (!v) throw new Error(&#039;no schema with key or ref &quot;&#039; + schemaKeyRef + &#039;&quot;&#039;);
    } else {
      var schemaObj = _addSchema(schemaKeyRef);
      v = schemaObj.validate || _compile(schemaObj);
    }

    var valid = v(data);
    if (v.$async === true)
      return self._opts.async == &#039;*&#039; ? co(valid) : valid;
    self.errors = v.errors;
    return valid;
  }


  /**
   * Create validating function for passed schema.
   * @param  {Object} schema schema object
   * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
   * @return {Function} validating function
   */
  function compile(schema, _meta) {
    var schemaObj = _addSchema(schema, undefined, _meta);
    return schemaObj.validate || _compile(schemaObj);
  }


  /**
   * Adds schema to the instance.
   * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
   * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
   * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
   * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
   */
  function addSchema(schema, key, _skipValidation, _meta) {
    if (Array.isArray(schema)){
      for (var i=0; i&lt;schema.length; i++) addSchema(schema[i], undefined, _skipValidation, _meta);
      return;
    }
    // can key/id have # inside?
    key = resolve.normalizeId(key || schema.id);
    checkUnique(key);
    self._schemas[key] = _addSchema(schema, _skipValidation, _meta, true);
  }


  /**
   * Add schema that will be used to validate other schemas
   * options in META_IGNORE_OPTIONS are alway set to false
   * @param {Object} schema schema object
   * @param {String} key optional schema key
   * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
   */
  function addMetaSchema(schema, key, skipValidation) {
    addSchema(schema, key, skipValidation, true);
  }


  /**
   * Validate schema
   * @param {Object} schema schema to validate
   * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
   * @return {Boolean} true if schema is valid
   */
  function validateSchema(schema, throwOrLogError) {
    var $schema = schema.$schema || self._opts.defaultMeta || defaultMeta();
    var currentUriFormat = self._formats.uri;
    self._formats.uri = typeof currentUriFormat == &#039;function&#039;
                        ? SCHEMA_URI_FORMAT_FUNC
                        : SCHEMA_URI_FORMAT;
    var valid;
    try { valid = validate($schema, schema); }
    finally { self._formats.uri = currentUriFormat; }
    if (!valid &amp;&amp; throwOrLogError) {
      var message = &#039;schema is invalid: &#039; + errorsText();
      if (self._opts.validateSchema == &#039;log&#039;) console.error(message);
      else throw new Error(message);
    }
    return valid;
  }


  function defaultMeta() {
    var meta = self._opts.meta;
    self._opts.defaultMeta = typeof meta == &#039;object&#039;
                              ? meta.id || meta
                              : self._opts.v5
                                ? v5.META_SCHEMA_ID
                                : META_SCHEMA_ID;
    return self._opts.defaultMeta;
  }


  /**
   * Get compiled schema from the instance by `key` or `ref`.
   * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
   * @return {Function} schema validating function (with property `schema`).
   */
  function getSchema(keyRef) {
    var schemaObj = _getSchemaObj(keyRef);
    switch (typeof schemaObj) {
      case &#039;object&#039;: return schemaObj.validate || _compile(schemaObj);
      case &#039;string&#039;: return getSchema(schemaObj);
      case &#039;undefined&#039;: return _getSchemaFragment(keyRef);
    }
  }


  function _getSchemaFragment(ref) {
    var res = resolve.schema.call(self, { schema: {} }, ref);
    if (res) {
      var schema = res.schema
        , root = res.root
        , baseId = res.baseId;
      var v = compileSchema.call(self, schema, root, undefined, baseId);
      self._fragments[ref] = new SchemaObject({
        ref: ref,
        fragment: true,
        schema: schema,
        root: root,
        baseId: baseId,
        validate: v
      });
      return v;
    }
  }


  function _getSchemaObj(keyRef) {
    keyRef = resolve.normalizeId(keyRef);
    return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
  }


  /**
   * Remove cached schema(s).
   * If no parameter is passed all schemas but meta-schemas are removed.
   * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
   * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
   * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
   */
  function removeSchema(schemaKeyRef) {
    if (schemaKeyRef instanceof RegExp) {
      _removeAllSchemas(self._schemas, schemaKeyRef);
      _removeAllSchemas(self._refs, schemaKeyRef);
      return;
    }
    switch (typeof schemaKeyRef) {
      case &#039;undefined&#039;:
        _removeAllSchemas(self._schemas);
        _removeAllSchemas(self._refs);
        self._cache.clear();
        return;
      case &#039;string&#039;:
        var schemaObj = _getSchemaObj(schemaKeyRef);
        if (schemaObj) self._cache.del(schemaObj.jsonStr);
        delete self._schemas[schemaKeyRef];
        delete self._refs[schemaKeyRef];
        return;
      case &#039;object&#039;:
        var jsonStr = stableStringify(schemaKeyRef);
        self._cache.del(jsonStr);
        var id = schemaKeyRef.id;
        if (id) {
          id = resolve.normalizeId(id);
          delete self._schemas[id];
          delete self._refs[id];
        }
    }
  }


  function _removeAllSchemas(schemas, regex) {
    for (var keyRef in schemas) {
      var schemaObj = schemas[keyRef];
      if (!schemaObj.meta &amp;&amp; (!regex || regex.test(keyRef))) {
        self._cache.del(schemaObj.jsonStr);
        delete schemas[keyRef];
      }
    }
  }


  function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
    if (typeof schema != &#039;object&#039;) throw new Error(&#039;schema should be object&#039;);
    var jsonStr = stableStringify(schema);
    var cached = self._cache.get(jsonStr);
    if (cached) return cached;

    shouldAddSchema = shouldAddSchema || self._opts.addUsedSchema !== false;

    var id = resolve.normalizeId(schema.id);
    if (id &amp;&amp; shouldAddSchema) checkUnique(id);

    var willValidate = self._opts.validateSchema !== false &amp;&amp; !skipValidation;
    var recursiveMeta;
    if (willValidate &amp;&amp; !(recursiveMeta = schema.id &amp;&amp; schema.id == schema.$schema))
      validateSchema(schema, true);

    var localRefs = resolve.ids.call(self, schema);

    var schemaObj = new SchemaObject({
      id: id,
      schema: schema,
      localRefs: localRefs,
      jsonStr: jsonStr,
      meta: meta
    });

    if (id[0] != &#039;#&#039; &amp;&amp; shouldAddSchema) self._refs[id] = schemaObj;
    self._cache.put(jsonStr, schemaObj);

    if (willValidate &amp;&amp; recursiveMeta) validateSchema(schema, true);

    return schemaObj;
  }


  function _compile(schemaObj, root) {
    if (schemaObj.compiling) {
      schemaObj.validate = callValidate;
      callValidate.schema = schemaObj.schema;
      callValidate.errors = null;
      callValidate.root = root ? root : callValidate;
      if (schemaObj.schema.$async === true)
        callValidate.$async = true;
      return callValidate;
    }
    schemaObj.compiling = true;

    var currentOpts;
    if (schemaObj.meta) {
      currentOpts = self._opts;
      self._opts = self._metaOpts;
    }

    var v;
    try { v = compileSchema.call(self, schemaObj.schema, root, schemaObj.localRefs); }
    finally {
      schemaObj.compiling = false;
      if (schemaObj.meta) self._opts = currentOpts;
    }

    schemaObj.validate = v;
    schemaObj.refs = v.refs;
    schemaObj.refVal = v.refVal;
    schemaObj.root = v.root;
    return v;


    function callValidate() {
      var _validate = schemaObj.validate;
      var result = _validate.apply(null, arguments);
      callValidate.errors = _validate.errors;
      return result;
    }
  }


  /**
   * Convert array of error message objects to string
   * @param  {Array&lt;Object&gt;} errors optional array of validation errors, if not passed errors from the instance are used.
   * @param  {Object} options optional options with properties `separator` and `dataVar`.
   * @return {String} human readable string with all errors descriptions
   */
  function errorsText(errors, options) {
    errors = errors || self.errors;
    if (!errors) return &#039;No errors&#039;;
    options = options || {};
    var separator = options.separator === undefined ? &#039;, &#039; : options.separator;
    var dataVar = options.dataVar === undefined ? &#039;data&#039; : options.dataVar;

    var text = &#039;&#039;;
    for (var i=0; i&lt;errors.length; i++) {
      var e = errors[i];
      if (e) text += dataVar + e.dataPath + &#039; &#039; + e.message + separator;
    }
    return text.slice(0, -separator.length);
  }


  /**
   * Add custom format
   * @param {String} name format name
   * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
   */
  function addFormat(name, format) {
    if (typeof format == &#039;string&#039;) format = new RegExp(format);
    self._formats[name] = format;
  }


  function addDraft4MetaSchema() {
    if (self._opts.meta !== false) {
      var metaSchema = require(&#039;./refs/json-schema-draft-04.json&#039;);
      addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self._refs[&#039;http://json-schema.org/schema&#039;] = META_SCHEMA_ID;
    }
  }


  function addInitialSchemas() {
    var optsSchemas = self._opts.schemas;
    if (!optsSchemas) return;
    if (Array.isArray(optsSchemas)) addSchema(optsSchemas);
    else for (var key in optsSchemas) addSchema(optsSchemas[key], key);
  }


  function addInitialFormats() {
    for (var name in self._opts.formats) {
      var format = self._opts.formats[name];
      addFormat(name, format);
    }
  }


  function checkUnique(id) {
    if (self._schemas[id] || self._refs[id])
      throw new Error(&#039;schema with key or id &quot;&#039; + id + &#039;&quot; already exists&#039;);
  }


  function getMetaSchemaOptions() {
    var metaOpts = util.copy(self._opts);
    for (var i=0; i&lt;META_IGNORE_OPTIONS.length; i++)
      delete metaOpts[META_IGNORE_OPTIONS[i]];
    return metaOpts;
  }
}

},{&quot;./async&quot;:1,&quot;./cache&quot;:2,&quot;./compile&quot;:6,&quot;./compile/formats&quot;:5,&quot;./compile/resolve&quot;:7,&quot;./compile/rules&quot;:8,&quot;./compile/schema_obj&quot;:9,&quot;./compile/util&quot;:10,&quot;./compile/validation_error&quot;:11,&quot;./keyword&quot;:36,&quot;./refs/json-schema-draft-04.json&quot;:37,&quot;./v5&quot;:39,&quot;co&quot;:46,&quot;json-stable-stringify&quot;:47}]},{},[])(&quot;ajv&quot;)
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
