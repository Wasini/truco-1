<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/acorn/src/statement.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/acorn/src/statement.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">56.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">626</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">123.07</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.69</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import {types as tt} from &quot;./tokentype&quot;
import {Parser} from &quot;./state&quot;
import {lineBreak} from &quot;./whitespace&quot;

const pp = Parser.prototype

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp.parseTopLevel = function(node) {
  let first = true
  if (!node.body) node.body = []
  while (this.type !== tt.eof) {
    let stmt = this.parseStatement(true, true)
    node.body.push(stmt)
    if (first) {
      if (this.isUseStrict(stmt)) this.setStrict(true)
      first = false
    }
  }
  this.next()
  if (this.options.ecmaVersion &gt;= 6) {
    node.sourceType = this.options.sourceType
  }
  return this.finishNode(node, &quot;Program&quot;)
}

const loopLabel = {kind: &quot;loop&quot;}, switchLabel = {kind: &quot;switch&quot;}

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp.parseStatement = function(declaration, topLevel) {
  let starttype = this.type, node = this.startNode()

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case tt._debugger: return this.parseDebuggerStatement(node)
  case tt._do: return this.parseDoStatement(node)
  case tt._for: return this.parseForStatement(node)
  case tt._function:
    if (!declaration &amp;&amp; this.options.ecmaVersion &gt;= 6) this.unexpected()
    return this.parseFunctionStatement(node)
  case tt._class:
    if (!declaration) this.unexpected()
    return this.parseClass(node, true)
  case tt._if: return this.parseIfStatement(node)
  case tt._return: return this.parseReturnStatement(node)
  case tt._switch: return this.parseSwitchStatement(node)
  case tt._throw: return this.parseThrowStatement(node)
  case tt._try: return this.parseTryStatement(node)
  case tt._let: case tt._const: if (!declaration) this.unexpected() // NOTE: falls through to _var
  case tt._var: return this.parseVarStatement(node, starttype)
  case tt._while: return this.parseWhileStatement(node)
  case tt._with: return this.parseWithStatement(node)
  case tt.braceL: return this.parseBlock()
  case tt.semi: return this.parseEmptyStatement(node)
  case tt._export:
  case tt._import:
    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        this.raise(this.start, &quot;&#039;import&#039; and &#039;export&#039; may only appear at the top level&quot;)
      if (!this.inModule)
        this.raise(this.start, &quot;&#039;import&#039; and &#039;export&#039; may appear only with &#039;sourceType: module&#039;&quot;)
    }
    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node)

    // If the statement does not start with a statement keyword or a
    // brace, it&#039;s an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    let maybeName = this.value, expr = this.parseExpression()
    if (starttype === tt.name &amp;&amp; expr.type === &quot;Identifier&quot; &amp;&amp; this.eat(tt.colon))
      return this.parseLabeledStatement(node, maybeName, expr)
    else return this.parseExpressionStatement(node, expr)
  }
}

pp.parseBreakContinueStatement = function(node, keyword) {
  let isBreak = keyword == &quot;break&quot;
  this.next()
  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null
  else if (this.type !== tt.name) this.unexpected()
  else {
    node.label = this.parseIdent()
    this.semicolon()
  }

  // Verify that there is an actual destination to break or
  // continue to.
  for (var i = 0; i &lt; this.labels.length; ++i) {
    let lab = this.labels[i]
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null &amp;&amp; (isBreak || lab.kind === &quot;loop&quot;)) break
      if (node.label &amp;&amp; isBreak) break
    }
  }
  if (i === this.labels.length) this.raise(node.start, &quot;Unsyntactic &quot; + keyword)
  return this.finishNode(node, isBreak ? &quot;BreakStatement&quot; : &quot;ContinueStatement&quot;)
}

pp.parseDebuggerStatement = function(node) {
  this.next()
  this.semicolon()
  return this.finishNode(node, &quot;DebuggerStatement&quot;)
}

pp.parseDoStatement = function(node) {
  this.next()
  this.labels.push(loopLabel)
  node.body = this.parseStatement(false)
  this.labels.pop()
  this.expect(tt._while)
  node.test = this.parseParenExpression()
  if (this.options.ecmaVersion &gt;= 6)
    this.eat(tt.semi)
  else
    this.semicolon()
  return this.finishNode(node, &quot;DoWhileStatement&quot;)
}

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp.parseForStatement = function(node) {
  this.next()
  this.labels.push(loopLabel)
  this.expect(tt.parenL)
  if (this.type === tt.semi) return this.parseFor(node, null)
  if (this.type === tt._var || this.type === tt._let || this.type === tt._const) {
    let init = this.startNode(), varKind = this.type
    this.next()
    this.parseVar(init, true, varKind)
    this.finishNode(init, &quot;VariableDeclaration&quot;)
    if ((this.type === tt._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) &amp;&amp; init.declarations.length === 1 &amp;&amp;
        !(varKind !== tt._var &amp;&amp; init.declarations[0].init))
      return this.parseForIn(node, init)
    return this.parseFor(node, init)
  }
  let refDestructuringErrors = {shorthandAssign: 0, trailingComma: 0}
  let init = this.parseExpression(true, refDestructuringErrors)
  if (this.type === tt._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) {
    this.checkPatternErrors(refDestructuringErrors, true)
    this.toAssignable(init)
    this.checkLVal(init)
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true)
  }
  return this.parseFor(node, init)
}

pp.parseFunctionStatement = function(node) {
  this.next()
  return this.parseFunction(node, true)
}

pp.parseIfStatement = function(node) {
  this.next()
  node.test = this.parseParenExpression()
  node.consequent = this.parseStatement(false)
  node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null
  return this.finishNode(node, &quot;IfStatement&quot;)
}

pp.parseReturnStatement = function(node) {
  if (!this.inFunction &amp;&amp; !this.options.allowReturnOutsideFunction)
    this.raise(this.start, &quot;&#039;return&#039; outside of function&quot;)
  this.next()

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null
  else { node.argument = this.parseExpression(); this.semicolon() }
  return this.finishNode(node, &quot;ReturnStatement&quot;)
}

pp.parseSwitchStatement = function(node) {
  this.next()
  node.discriminant = this.parseParenExpression()
  node.cases = []
  this.expect(tt.braceL)
  this.labels.push(switchLabel)

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  for (var cur, sawDefault = false; this.type != tt.braceR;) {
    if (this.type === tt._case || this.type === tt._default) {
      let isCase = this.type === tt._case
      if (cur) this.finishNode(cur, &quot;SwitchCase&quot;)
      node.cases.push(cur = this.startNode())
      cur.consequent = []
      this.next()
      if (isCase) {
        cur.test = this.parseExpression()
      } else {
        if (sawDefault) this.raise(this.lastTokStart, &quot;Multiple default clauses&quot;)
        sawDefault = true
        cur.test = null
      }
      this.expect(tt.colon)
    } else {
      if (!cur) this.unexpected()
      cur.consequent.push(this.parseStatement(true))
    }
  }
  if (cur) this.finishNode(cur, &quot;SwitchCase&quot;)
  this.next() // Closing brace
  this.labels.pop()
  return this.finishNode(node, &quot;SwitchStatement&quot;)
}

pp.parseThrowStatement = function(node) {
  this.next()
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    this.raise(this.lastTokEnd, &quot;Illegal newline after throw&quot;)
  node.argument = this.parseExpression()
  this.semicolon()
  return this.finishNode(node, &quot;ThrowStatement&quot;)
}

// Reused empty array added for node fields that are always empty.

const empty = []

pp.parseTryStatement = function(node) {
  this.next()
  node.block = this.parseBlock()
  node.handler = null
  if (this.type === tt._catch) {
    let clause = this.startNode()
    this.next()
    this.expect(tt.parenL)
    clause.param = this.parseBindingAtom()
    this.checkLVal(clause.param, true)
    this.expect(tt.parenR)
    clause.body = this.parseBlock()
    node.handler = this.finishNode(clause, &quot;CatchClause&quot;)
  }
  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null
  if (!node.handler &amp;&amp; !node.finalizer)
    this.raise(node.start, &quot;Missing catch or finally clause&quot;)
  return this.finishNode(node, &quot;TryStatement&quot;)
}

pp.parseVarStatement = function(node, kind) {
  this.next()
  this.parseVar(node, false, kind)
  this.semicolon()
  return this.finishNode(node, &quot;VariableDeclaration&quot;)
}

pp.parseWhileStatement = function(node) {
  this.next()
  node.test = this.parseParenExpression()
  this.labels.push(loopLabel)
  node.body = this.parseStatement(false)
  this.labels.pop()
  return this.finishNode(node, &quot;WhileStatement&quot;)
}

pp.parseWithStatement = function(node) {
  if (this.strict) this.raise(this.start, &quot;&#039;with&#039; in strict mode&quot;)
  this.next()
  node.object = this.parseParenExpression()
  node.body = this.parseStatement(false)
  return this.finishNode(node, &quot;WithStatement&quot;)
}

pp.parseEmptyStatement = function(node) {
  this.next()
  return this.finishNode(node, &quot;EmptyStatement&quot;)
}

pp.parseLabeledStatement = function(node, maybeName, expr) {
  for (let i = 0; i &lt; this.labels.length; ++i)
    if (this.labels[i].name === maybeName) this.raise(expr.start, &quot;Label &#039;&quot; + maybeName + &quot;&#039; is already declared&quot;)
  let kind = this.type.isLoop ? &quot;loop&quot; : this.type === tt._switch ? &quot;switch&quot; : null
  for (let i = this.labels.length - 1; i &gt;= 0; i--) {
    let label = this.labels[i]
    if (label.statementStart == node.start) {
      label.statementStart = this.start;
      label.kind = kind;
    } else break;
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start})
  node.body = this.parseStatement(true)
  this.labels.pop()
  node.label = expr
  return this.finishNode(node, &quot;LabeledStatement&quot;)
}

pp.parseExpressionStatement = function(node, expr) {
  node.expression = expr
  this.semicolon()
  return this.finishNode(node, &quot;ExpressionStatement&quot;)
}

// Parse a semicolon-enclosed block of statements, handling `&quot;use
// strict&quot;` declarations when `allowStrict` is true (used for
// function bodies).

pp.parseBlock = function(allowStrict) {
  let node = this.startNode(), first = true, oldStrict
  node.body = []
  this.expect(tt.braceL)
  while (!this.eat(tt.braceR)) {
    let stmt = this.parseStatement(true)
    node.body.push(stmt)
    if (first &amp;&amp; allowStrict &amp;&amp; this.isUseStrict(stmt)) {
      oldStrict = this.strict
      this.setStrict(this.strict = true)
    }
    first = false
  }
  if (oldStrict === false) this.setStrict(false)
  return this.finishNode(node, &quot;BlockStatement&quot;)
}

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp.parseFor = function(node, init) {
  node.init = init
  this.expect(tt.semi)
  node.test = this.type === tt.semi ? null : this.parseExpression()
  this.expect(tt.semi)
  node.update = this.type === tt.parenR ? null : this.parseExpression()
  this.expect(tt.parenR)
  node.body = this.parseStatement(false)
  this.labels.pop()
  return this.finishNode(node, &quot;ForStatement&quot;)
}

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser&#039;s perspective.

pp.parseForIn = function(node, init) {
  let type = this.type === tt._in ? &quot;ForInStatement&quot; : &quot;ForOfStatement&quot;
  this.next()
  node.left = init
  node.right = this.parseExpression()
  this.expect(tt.parenR)
  node.body = this.parseStatement(false)
  this.labels.pop()
  return this.finishNode(node, type)
}

// Parse a list of variable declarations.

pp.parseVar = function(node, isFor, kind) {
  node.declarations = []
  node.kind = kind.keyword
  for (;;) {
    let decl = this.startNode()
    this.parseVarId(decl)
    if (this.eat(tt.eq)) {
      decl.init = this.parseMaybeAssign(isFor)
    } else if (kind === tt._const &amp;&amp; !(this.type === tt._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;)))) {
      this.unexpected()
    } else if (decl.id.type != &quot;Identifier&quot; &amp;&amp; !(isFor &amp;&amp; (this.type === tt._in || this.isContextual(&quot;of&quot;)))) {
      this.raise(this.lastTokEnd, &quot;Complex binding patterns require an initialization value&quot;)
    } else {
      decl.init = null
    }
    node.declarations.push(this.finishNode(decl, &quot;VariableDeclarator&quot;))
    if (!this.eat(tt.comma)) break
  }
  return node
}

pp.parseVarId = function(decl) {
  decl.id = this.parseBindingAtom()
  this.checkLVal(decl.id, true)
}

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp.parseFunction = function(node, isStatement, allowExpressionBody) {
  this.initFunction(node)
  if (this.options.ecmaVersion &gt;= 6)
    node.generator = this.eat(tt.star)
  if (isStatement || this.type === tt.name)
    node.id = this.parseIdent()
  this.parseFunctionParams(node)
  this.parseFunctionBody(node, allowExpressionBody)
  return this.finishNode(node, isStatement ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot;)
}

pp.parseFunctionParams = function(node) {
  this.expect(tt.parenL)
  node.params = this.parseBindingList(tt.parenR, false, false, true)
}

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp.parseClass = function(node, isStatement) {
  this.next()
  this.parseClassId(node, isStatement)
  this.parseClassSuper(node)
  let classBody = this.startNode()
  let hadConstructor = false
  classBody.body = []
  this.expect(tt.braceL)
  while (!this.eat(tt.braceR)) {
    if (this.eat(tt.semi)) continue
    let method = this.startNode()
    let isGenerator = this.eat(tt.star)
    let isMaybeStatic = this.type === tt.name &amp;&amp; this.value === &quot;static&quot;
    this.parsePropertyName(method)
    method.static = isMaybeStatic &amp;&amp; this.type !== tt.parenL
    if (method.static) {
      if (isGenerator) this.unexpected()
      isGenerator = this.eat(tt.star)
      this.parsePropertyName(method)
    }
    method.kind = &quot;method&quot;
    let isGetSet = false
    if (!method.computed) {
      let {key} = method
      if (!isGenerator &amp;&amp; key.type === &quot;Identifier&quot; &amp;&amp; this.type !== tt.parenL &amp;&amp; (key.name === &quot;get&quot; || key.name === &quot;set&quot;)) {
        isGetSet = true
        method.kind = key.name
        key = this.parsePropertyName(method)
      }
      if (!method.static &amp;&amp; (key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;constructor&quot; ||
          key.type === &quot;Literal&quot; &amp;&amp; key.value === &quot;constructor&quot;)) {
        if (hadConstructor) this.raise(key.start, &quot;Duplicate constructor in the same class&quot;)
        if (isGetSet) this.raise(key.start, &quot;Constructor can&#039;t have get/set modifier&quot;)
        if (isGenerator) this.raise(key.start, &quot;Constructor can&#039;t be a generator&quot;)
        method.kind = &quot;constructor&quot;
        hadConstructor = true
      }
    }
    this.parseClassMethod(classBody, method, isGenerator)
    if (isGetSet) {
      let paramCount = method.kind === &quot;get&quot; ? 0 : 1
      if (method.value.params.length !== paramCount) {
        let start = method.value.start
        if (method.kind === &quot;get&quot;)
          this.raise(start, &quot;getter should have no params&quot;);
        else
          this.raise(start, &quot;setter should have exactly one param&quot;)
      }
      if (method.kind === &quot;set&quot; &amp;&amp; method.value.params[0].type === &quot;RestElement&quot;)
        this.raise(method.value.params[0].start, &quot;Setter cannot use rest params&quot;)
    }
  }
  node.body = this.finishNode(classBody, &quot;ClassBody&quot;)
  return this.finishNode(node, isStatement ? &quot;ClassDeclaration&quot; : &quot;ClassExpression&quot;)
}

pp.parseClassMethod = function(classBody, method, isGenerator) {
  method.value = this.parseMethod(isGenerator)
  classBody.body.push(this.finishNode(method, &quot;MethodDefinition&quot;))
}

pp.parseClassId = function(node, isStatement) {
  node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null
}

pp.parseClassSuper = function(node) {
  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null
}

// Parses module export declaration.

pp.parseExport = function(node) {
  this.next()
  // export * from &#039;...&#039;
  if (this.eat(tt.star)) {
    this.expectContextual(&quot;from&quot;)
    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
    this.semicolon()
    return this.finishNode(node, &quot;ExportAllDeclaration&quot;)
  }
  if (this.eat(tt._default)) { // export default ...
    let expr = this.parseMaybeAssign()
    let needsSemi = true
    if (expr.type == &quot;FunctionExpression&quot; ||
        expr.type == &quot;ClassExpression&quot;) {
      needsSemi = false
      if (expr.id) {
        expr.type = expr.type == &quot;FunctionExpression&quot;
          ? &quot;FunctionDeclaration&quot;
          : &quot;ClassDeclaration&quot;
      }
    }
    node.declaration = expr
    if (needsSemi) this.semicolon()
    return this.finishNode(node, &quot;ExportDefaultDeclaration&quot;)
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true)
    node.specifiers = []
    node.source = null
  } else { // export { x, y as z } [from &#039;...&#039;]
    node.declaration = null
    node.specifiers = this.parseExportSpecifiers()
    if (this.eatContextual(&quot;from&quot;)) {
      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
    } else {
      // check for keywords used as local names
      for (let i = 0; i &lt; node.specifiers.length; i++) {
        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {
          this.unexpected(node.specifiers[i].local.start)
        }
      }

      node.source = null
    }
    this.semicolon()
  }
  return this.finishNode(node, &quot;ExportNamedDeclaration&quot;)
}

pp.shouldParseExportStatement = function() {
  return this.type.keyword
}

// Parses a comma-separated list of module exports.

pp.parseExportSpecifiers = function() {
  let nodes = [], first = true
  // export { x, y as z } [from &#039;...&#039;]
  this.expect(tt.braceL)
  while (!this.eat(tt.braceR)) {
    if (!first) {
      this.expect(tt.comma)
      if (this.afterTrailingComma(tt.braceR)) break
    } else first = false

    let node = this.startNode()
    node.local = this.parseIdent(this.type === tt._default)
    node.exported = this.eatContextual(&quot;as&quot;) ? this.parseIdent(true) : node.local
    nodes.push(this.finishNode(node, &quot;ExportSpecifier&quot;))
  }
  return nodes
}

// Parses import declaration.

pp.parseImport = function(node) {
  this.next()
  // import &#039;...&#039;
  if (this.type === tt.string) {
    node.specifiers = empty
    node.source = this.parseExprAtom()
  } else {
    node.specifiers = this.parseImportSpecifiers()
    this.expectContextual(&quot;from&quot;)
    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
  }
  this.semicolon()
  return this.finishNode(node, &quot;ImportDeclaration&quot;)
}

// Parses a comma-separated list of module imports.

pp.parseImportSpecifiers = function() {
  let nodes = [], first = true
  if (this.type === tt.name) {
    // import defaultObj, { x, y as z } from &#039;...&#039;
    let node = this.startNode()
    node.local = this.parseIdent()
    this.checkLVal(node.local, true)
    nodes.push(this.finishNode(node, &quot;ImportDefaultSpecifier&quot;))
    if (!this.eat(tt.comma)) return nodes
  }
  if (this.type === tt.star) {
    let node = this.startNode()
    this.next()
    this.expectContextual(&quot;as&quot;)
    node.local = this.parseIdent()
    this.checkLVal(node.local, true)
    nodes.push(this.finishNode(node, &quot;ImportNamespaceSpecifier&quot;))
    return nodes
  }
  this.expect(tt.braceL)
  while (!this.eat(tt.braceR)) {
    if (!first) {
      this.expect(tt.comma)
      if (this.afterTrailingComma(tt.braceR)) break
    } else first = false

    let node = this.startNode()
    node.imported = this.parseIdent(true)
    if (this.eatContextual(&quot;as&quot;)) {
      node.local = this.parseIdent()
    } else {
      node.local = node.imported
      if (this.isKeyword(node.local.name)) this.unexpected(node.local.start)
      if (this.reservedWordsStrict.test(node.local.name)) this.raise(node.local.start, &quot;The keyword &#039;&quot; + node.local.name + &quot;&#039; is reserved&quot;)
    }
    this.checkLVal(node.local, true)
    nodes.push(this.finishNode(node, &quot;ImportSpecifier&quot;))
  }
  return nodes
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
