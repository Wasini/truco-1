<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/chai/lib/chai/core/assertions.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/chai/lib/chai/core/assertions.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.30</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1860</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">99.63</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.19</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */

  [ &#039;to&#039;, &#039;be&#039;, &#039;been&#039;
  , &#039;is&#039;, &#039;and&#039;, &#039;has&#039;, &#039;have&#039;
  , &#039;with&#039;, &#039;that&#039;, &#039;which&#039;, &#039;at&#039;
  , &#039;of&#039;, &#039;same&#039; ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal(&#039;bar&#039;);
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: &#039;baz&#039; }).to.have.property(&#039;foo&#039;)
   *       .and.not.equal(&#039;bar&#039;);
   *
   * @name not
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;not&#039;, function () {
    flag(this, &#039;negate&#039;, true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: &#039;baz&#039; });
   *     expect({ foo: { bar: { baz: &#039;quux&#039; } } })
   *       .to.have.deep.property(&#039;foo.bar.baz&#039;, &#039;quux&#039;);
   *
   * `.deep.property` special characters can be escaped
   * by adding two slashes before the `.` or `[]`.
   *
   *     var deepCss = { &#039;.link&#039;: { &#039;[target]&#039;: 42 }};
   *     expect(deepCss).to.have.deep.property(&#039;\\.link.\\[target\\]&#039;, 42);
   *
   * @name deep
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;deep&#039;, function () {
    flag(this, &#039;deep&#039;, true);
  });

  /**
   * ### .any
   *
   * Sets the `any` flag, (opposite of the `all` flag)
   * later used in the `keys` assertion.
   *
   *     expect(foo).to.have.any.keys(&#039;bar&#039;, &#039;baz&#039;);
   *
   * @name any
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;any&#039;, function () {
    flag(this, &#039;any&#039;, true);
    flag(this, &#039;all&#039;, false)
  });


  /**
   * ### .all
   *
   * Sets the `all` flag (opposite of the `any` flag)
   * later used by the `keys` assertion.
   *
   *     expect(foo).to.have.all.keys(&#039;bar&#039;, &#039;baz&#039;);
   *
   * @name all
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;all&#039;, function () {
    flag(this, &#039;all&#039;, true);
    flag(this, &#039;any&#039;, false);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value&#039;s
   * type.
   *
   *     // typeof
   *     expect(&#039;test&#039;).to.be.a(&#039;string&#039;);
   *     expect({ foo: &#039;bar&#039; }).to.be.an(&#039;object&#039;);
   *     expect(null).to.be.a(&#039;null&#039;);
   *     expect(undefined).to.be.an(&#039;undefined&#039;);
   *     expect(new Error).to.be.an(&#039;error&#039;);
   *     expect(new Promise).to.be.a(&#039;promise&#039;);
   *     expect(new Float32Array()).to.be.a(&#039;float32array&#039;);
   *     expect(Symbol()).to.be.a(&#039;symbol&#039;);
   *
   *     // es6 overrides
   *     expect({[Symbol.toStringTag]:()=&gt;&#039;foo&#039;}).to.be.a(&#039;foo&#039;);
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    type = type.toLowerCase();
    var obj = flag(this, &#039;object&#039;)
      , article = ~[ &#039;a&#039;, &#039;e&#039;, &#039;i&#039;, &#039;o&#039;, &#039;u&#039; ].indexOf(type.charAt(0)) ? &#039;an &#039; : &#039;a &#039;;

    this.assert(
        type === _.type(obj)
      , &#039;expected #{this} to be &#039; + article + type
      , &#039;expected #{this} not to be &#039; + article + type
    );
  }

  Assertion.addChainableMethod(&#039;an&#039;, an);
  Assertion.addChainableMethod(&#039;a&#039;, an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contains` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect(&#039;foobar&#039;).to.contain(&#039;foo&#039;);
   *     expect({ foo: &#039;bar&#039;, hello: &#039;universe&#039; }).to.include.keys(&#039;foo&#039;);
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, &#039;contains&#039;, true);
  }

  function include (val, msg) {
    _.expectTypes(this, [&#039;array&#039;, &#039;object&#039;, &#039;string&#039;]);

    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    var expected = false;

    if (_.type(obj) === &#039;array&#039; &amp;&amp; _.type(val) === &#039;object&#039;) {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === &#039;object&#039;) {
      if (!flag(this, &#039;negate&#039;)) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {};
      for (var k in val) subset[k] = obj[k];
      expected = _.eql(subset, val);
    } else {
      expected = (obj != undefined) &amp;&amp; ~obj.indexOf(val);
    }
    this.assert(
        expected
      , &#039;expected #{this} to include &#039; + _.inspect(val)
      , &#039;expected #{this} to not include &#039; + _.inspect(val));
  }

  Assertion.addChainableMethod(&#039;include&#039;, include, includeChainingBehavior);
  Assertion.addChainableMethod(&#039;contain&#039;, include, includeChainingBehavior);
  Assertion.addChainableMethod(&#039;contains&#039;, include, includeChainingBehavior);
  Assertion.addChainableMethod(&#039;includes&#039;, include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect(&#039;everything&#039;).to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;ok&#039;, function () {
    this.assert(
        flag(this, &#039;object&#039;)
      , &#039;expected #{this} to be truthy&#039;
      , &#039;expected #{this} to be falsy&#039;);
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;true&#039;, function () {
    this.assert(
        true === flag(this, &#039;object&#039;)
      , &#039;expected #{this} to be true&#039;
      , &#039;expected #{this} to be false&#039;
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;false&#039;, function () {
    this.assert(
        false === flag(this, &#039;object&#039;)
      , &#039;expected #{this} to be false&#039;
      , &#039;expected #{this} to be true&#039;
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).to.not.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;null&#039;, function () {
    this.assert(
        null === flag(this, &#039;object&#039;)
      , &#039;expected #{this} to be null&#039;
      , &#039;expected #{this} not to be null&#039;
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;undefined&#039;, function () {
    this.assert(
        undefined === flag(this, &#039;object&#039;)
      , &#039;expected #{this} to be undefined&#039;
      , &#039;expected #{this} not to be undefined&#039;
    );
  });

  /**
   * ### .NaN
   * Asserts that the target is `NaN`.
   *
   *     expect(&#039;foo&#039;).to.be.NaN;
   *     expect(4).not.to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;NaN&#039;, function () {
    this.assert(
        isNaN(flag(this, &#039;object&#039;))
        , &#039;expected #{this} to be NaN&#039;
        , &#039;expected #{this} not to be NaN&#039;
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = &#039;hi&#039;
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;exist&#039;, function () {
    this.assert(
        null != flag(this, &#039;object&#039;)
      , &#039;expected #{this} to exist&#039;
      , &#039;expected #{this} to not exist&#039;
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target&#039;s length is `0`. For arrays and strings, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect(&#039;&#039;).to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;empty&#039;, function () {
    var obj = flag(this, &#039;object&#039;)
      , expected = obj;

    if (Array.isArray(obj) || &#039;string&#039; === typeof object) {
      expected = obj.length;
    } else if (typeof obj === &#039;object&#039;) {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , &#039;expected #{this} to be empty&#039;
      , &#039;expected #{this} not to be empty&#039;
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, &#039;object&#039;)
      , type = Object.prototype.toString.call(obj);
    this.assert(
        &#039;[object Arguments]&#039; === type
      , &#039;expected #{this} to be arguments but got &#039; + type
      , &#039;expected #{this} to not be arguments&#039;
    );
  }

  Assertion.addProperty(&#039;arguments&#039;, checkArguments);
  Assertion.addProperty(&#039;Arguments&#039;, checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect(&#039;hello&#039;).to.equal(&#039;hello&#039;);
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: &#039;bar&#039; }).to.not.equal({ foo: &#039;bar&#039; });
   *     expect({ foo: &#039;bar&#039; }).to.deep.equal({ foo: &#039;bar&#039; });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    if (flag(this, &#039;deep&#039;)) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , &#039;expected #{this} to equal #{exp}&#039;
        , &#039;expected #{this} to not equal #{exp}&#039;
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod(&#039;equal&#039;, assertEqual);
  Assertion.addMethod(&#039;equals&#039;, assertEqual);
  Assertion.addMethod(&#039;eq&#039;, assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: &#039;bar&#039; }).to.eql({ foo: &#039;bar&#039; });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    this.assert(
        _.eql(obj, flag(this, &#039;object&#039;))
      , &#039;expected #{this} to deeply equal #{exp}&#039;
      , &#039;expected #{this} to not deeply equal #{exp}&#039;
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod(&#039;eql&#039;, assertEql);
  Assertion.addMethod(&#039;eqls&#039;, assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#039;foo&#039;).to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    if (flag(this, &#039;doLength&#039;)) {
      new Assertion(obj, msg).to.have.property(&#039;length&#039;);
      var len = obj.length;
      this.assert(
          len &gt; n
        , &#039;expected #{this} to have a length above #{exp} but got #{act}&#039;
        , &#039;expected #{this} to not have a length above #{exp}&#039;
        , n
        , len
      );
    } else {
      this.assert(
          obj &gt; n
        , &#039;expected #{this} to be above &#039; + n
        , &#039;expected #{this} to be at most &#039; + n
      );
    }
  }

  Assertion.addMethod(&#039;above&#039;, assertAbove);
  Assertion.addMethod(&#039;gt&#039;, assertAbove);
  Assertion.addMethod(&#039;greaterThan&#039;, assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#039;foo&#039;).to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    if (flag(this, &#039;doLength&#039;)) {
      new Assertion(obj, msg).to.have.property(&#039;length&#039;);
      var len = obj.length;
      this.assert(
          len &gt;= n
        , &#039;expected #{this} to have a length at least #{exp} but got #{act}&#039;
        , &#039;expected #{this} to have a length below #{exp}&#039;
        , n
        , len
      );
    } else {
      this.assert(
          obj &gt;= n
        , &#039;expected #{this} to be at least &#039; + n
        , &#039;expected #{this} to be below &#039; + n
      );
    }
  }

  Assertion.addMethod(&#039;least&#039;, assertLeast);
  Assertion.addMethod(&#039;gte&#039;, assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#039;foo&#039;).to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    if (flag(this, &#039;doLength&#039;)) {
      new Assertion(obj, msg).to.have.property(&#039;length&#039;);
      var len = obj.length;
      this.assert(
          len &lt; n
        , &#039;expected #{this} to have a length below #{exp} but got #{act}&#039;
        , &#039;expected #{this} to not have a length below #{exp}&#039;
        , n
        , len
      );
    } else {
      this.assert(
          obj &lt; n
        , &#039;expected #{this} to be below &#039; + n
        , &#039;expected #{this} to be at least &#039; + n
      );
    }
  }

  Assertion.addMethod(&#039;below&#039;, assertBelow);
  Assertion.addMethod(&#039;lt&#039;, assertBelow);
  Assertion.addMethod(&#039;lessThan&#039;, assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#039;foo&#039;).to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    if (flag(this, &#039;doLength&#039;)) {
      new Assertion(obj, msg).to.have.property(&#039;length&#039;);
      var len = obj.length;
      this.assert(
          len &lt;= n
        , &#039;expected #{this} to have a length at most #{exp} but got #{act}&#039;
        , &#039;expected #{this} to have a length above #{exp}&#039;
        , n
        , len
      );
    } else {
      this.assert(
          obj &lt;= n
        , &#039;expected #{this} to be at most &#039; + n
        , &#039;expected #{this} to be above &#039; + n
      );
    }
  }

  Assertion.addMethod(&#039;most&#039;, assertMost);
  Assertion.addMethod(&#039;lte&#039;, assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#039;foo&#039;).to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod(&#039;within&#039;, function (start, finish, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;)
      , range = start + &#039;..&#039; + finish;
    if (flag(this, &#039;doLength&#039;)) {
      new Assertion(obj, msg).to.have.property(&#039;length&#039;);
      var len = obj.length;
      this.assert(
          len &gt;= start &amp;&amp; len &lt;= finish
        , &#039;expected #{this} to have a length within &#039; + range
        , &#039;expected #{this} to not have a length within &#039; + range
      );
    } else {
      this.assert(
          obj &gt;= start &amp;&amp; obj &lt;= finish
        , &#039;expected #{this} to be within &#039; + range
        , &#039;expected #{this} to not be within &#039; + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea(&#039;chai&#039;);
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, &#039;object&#039;) instanceof constructor
      , &#039;expected #{this} to be an instance of &#039; + name
      , &#039;expected #{this} to not be an instance of &#039; + name
    );
  };

  Assertion.addMethod(&#039;instanceof&#039;, assertInstanceOf);
  Assertion.addMethod(&#039;instanceOf&#039;, assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: &#039;bar&#039; };
   *     expect(obj).to.have.property(&#039;foo&#039;);
   *     expect(obj).to.have.property(&#039;foo&#039;, &#039;bar&#039;);
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: &#039;matcha&#039; }
   *       , teas: [ &#039;chai&#039;, &#039;matcha&#039;, { tea: &#039;konacha&#039; } ]
   *     };
   *
   *     expect(deepObj).to.have.deep.property(&#039;green.tea&#039;, &#039;matcha&#039;);
   *     expect(deepObj).to.have.deep.property(&#039;teas[1]&#039;, &#039;matcha&#039;);
   *     expect(deepObj).to.have.deep.property(&#039;teas[2].tea&#039;, &#039;konacha&#039;);
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ &#039;chai&#039;, &#039;matcha&#039;, &#039;konacha&#039; ]
   *       , [ { tea: &#039;chai&#039; }
   *         , { tea: &#039;matcha&#039; }
   *         , { tea: &#039;konacha&#039; } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property(&#039;[0][1]&#039;, &#039;matcha&#039;);
   *     expect(arr).to.have.deep.property(&#039;[1][2].tea&#039;, &#039;konacha&#039;);
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property(&#039;foo&#039;)
   *       .that.is.a(&#039;string&#039;);
   *     expect(deepObj).to.have.property(&#039;green&#039;)
   *       .that.is.an(&#039;object&#039;)
   *       .that.deep.equals({ tea: &#039;matcha&#039; });
   *     expect(deepObj).to.have.property(&#039;teas&#039;)
   *       .that.is.an(&#039;array&#039;)
   *       .with.deep.property(&#039;[2]&#039;)
   *         .that.deep.equals({ tea: &#039;konacha&#039; });
   *
   * Note that dots and bracket in `name` must be backslash-escaped when
   * the `deep` flag is set, while they must NOT be escaped when the `deep`
   * flag is not set.
   *
   *     // simple referencing
   *     var css = { &#039;.link[target]&#039;: 42 };
   *     expect(css).to.have.property(&#039;.link[target]&#039;, 42);
   *
   *     // deep referencing
   *     var deepCss = { &#039;.link&#039;: { &#039;[target]&#039;: 42 }};
   *     expect(deepCss).to.have.deep.property(&#039;\\.link.\\[target\\]&#039;, 42);
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod(&#039;property&#039;, function (name, val, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);

    var isDeep = !!flag(this, &#039;deep&#039;)
      , descriptor = isDeep ? &#039;deep property &#039; : &#039;property &#039;
      , negate = flag(this, &#039;negate&#039;)
      , obj = flag(this, &#039;object&#039;)
      , pathInfo = isDeep ? _.getPathInfo(name, obj) : null
      , hasProperty = isDeep
        ? pathInfo.exists
        : _.hasProperty(name, obj)
      , value = isDeep
        ? pathInfo.value
        : obj[name];

    if (negate &amp;&amp; arguments.length &gt; 1) {
      if (undefined === value) {
        msg = (msg != null) ? msg + &#039;: &#039; : &#039;&#039;;
        throw new Error(msg + _.inspect(obj) + &#039; has no &#039; + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          hasProperty
        , &#039;expected #{this} to have a &#039; + descriptor + _.inspect(name)
        , &#039;expected #{this} to not have &#039; + descriptor + _.inspect(name));
    }

    if (arguments.length &gt; 1) {
      this.assert(
          val === value
        , &#039;expected #{this} to have a &#039; + descriptor + _.inspect(name) + &#039; of #{exp}, but got #{act}&#039;
        , &#039;expected #{this} to not have a &#039; + descriptor + _.inspect(name) + &#039; of #{act}&#039;
        , val
        , value
      );
    }

    flag(this, &#039;object&#039;, value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect(&#039;test&#039;).to.have.ownProperty(&#039;length&#039;);
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    this.assert(
        obj.hasOwnProperty(name)
      , &#039;expected #{this} to have own property &#039; + _.inspect(name)
      , &#039;expected #{this} to not have own property &#039; + _.inspect(name)
    );
  }

  Assertion.addMethod(&#039;ownProperty&#039;, assertOwnProperty);
  Assertion.addMethod(&#039;haveOwnProperty&#039;, assertOwnProperty);

  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, message]])
   *
   * Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.
   *
   *     expect(&#039;test&#039;).to.have.ownPropertyDescriptor(&#039;length&#039;);
   *     expect(&#039;test&#039;).to.have.ownPropertyDescriptor(&#039;length&#039;, { enumerable: false, configurable: false, writable: false, value: 4 });
   *     expect(&#039;test&#039;).not.to.have.ownPropertyDescriptor(&#039;length&#039;, { enumerable: false, configurable: false, writable: false, value: 3 });
   *     expect(&#039;test&#039;).ownPropertyDescriptor(&#039;length&#039;).to.have.property(&#039;enumerable&#039;, false);
   *     expect(&#039;test&#039;).ownPropertyDescriptor(&#039;length&#039;).to.have.keys(&#039;value&#039;);
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnPropertyDescriptor (name, descriptor, msg) {
    if (typeof descriptor === &#039;string&#039;) {
      msg = descriptor;
      descriptor = null;
    }
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
    if (actualDescriptor &amp;&amp; descriptor) {
      this.assert(
          _.eql(descriptor, actualDescriptor)
        , &#039;expected the own property descriptor for &#039; + _.inspect(name) + &#039; on #{this} to match &#039; + _.inspect(descriptor) + &#039;, got &#039; + _.inspect(actualDescriptor)
        , &#039;expected the own property descriptor for &#039; + _.inspect(name) + &#039; on #{this} to not match &#039; + _.inspect(descriptor)
        , descriptor
        , actualDescriptor
        , true
      );
    } else {
      this.assert(
          actualDescriptor
        , &#039;expected #{this} to have an own property descriptor for &#039; + _.inspect(name)
        , &#039;expected #{this} to not have an own property descriptor for &#039; + _.inspect(name)
      );
    }
    flag(this, &#039;object&#039;, actualDescriptor);
  }

  Assertion.addMethod(&#039;ownPropertyDescriptor&#039;, assertOwnPropertyDescriptor);
  Assertion.addMethod(&#039;haveOwnPropertyDescriptor&#039;, assertOwnPropertyDescriptor);

  /**
   * ### .length
   *
   * Sets the `doLength` flag later used as a chain precursor to a value
   * comparison for the `length` property.
   *
   *     expect(&#039;foo&#039;).to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect(&#039;foo&#039;).to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect(&#039;foo&#039;).to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * *Deprecation notice:* Using `length` as an assertion will be deprecated
   * in version 2.4.0 and removed in 3.0.0. Code using the old style of
   * asserting for `length` property value using `length(value)` should be
   * switched to use `lengthOf(value)` instead.
   *
   * @name length
   * @namespace BDD
   * @api public
   */

  /**
   * ### .lengthOf(value[, message])
   *
   * Asserts that the target&#039;s `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.lengthOf(3);
   *     expect(&#039;foobar&#039;).to.have.lengthOf(6);
   *
   * @name lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertLengthChain () {
    flag(this, &#039;doLength&#039;, true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    new Assertion(obj, msg).to.have.property(&#039;length&#039;);
    var len = obj.length;

    this.assert(
        len == n
      , &#039;expected #{this} to have a length of #{exp} but got #{act}&#039;
      , &#039;expected #{this} to not have a length of #{act}&#039;
      , n
      , len
    );
  }

  Assertion.addChainableMethod(&#039;length&#039;, assertLength, assertLengthChain);
  Assertion.addMethod(&#039;lengthOf&#039;, assertLength);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect(&#039;foobar&#039;).to.match(/^foo/);
   *
   * @name match
   * @alias matches
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */
  function assertMatch(re, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    this.assert(
        re.exec(obj)
      , &#039;expected #{this} to match &#039; + re
      , &#039;expected #{this} not to match &#039; + re
    );
  }

  Assertion.addMethod(&#039;match&#039;, assertMatch);
  Assertion.addMethod(&#039;matches&#039;, assertMatch);

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect(&#039;foobar&#039;).to.have.string(&#039;bar&#039;);
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod(&#039;string&#039;, function (str, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    new Assertion(obj, msg).is.a(&#039;string&#039;);

    this.assert(
        ~obj.indexOf(str)
      , &#039;expected #{this} to contain &#039; + _.inspect(str)
      , &#039;expected #{this} to not contain &#039; + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target contains any or all of the passed-in keys.
   * Use in combination with `any`, `all`, `contains`, or `have` will affect
   * what will pass.
   *
   * When used in conjunction with `any`, at least one key that is passed
   * in must exist in the target object. This is regardless whether or not
   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`
   * should be used in the assertion. If neither are used, the assertion is
   * defaulted to `all`.
   *
   * When both `all` and `contain` are used, the target object must have at
   * least all of the passed-in keys but may have more keys not listed.
   *
   * When both `all` and `have` are used, the target object must both contain
   * all of the passed-in keys AND the number of keys in the target object must
   * match the number of keys passed in (in other words, a target object must
   * have all and only all of the passed-in keys).
   *
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys(&#039;foo&#039;, &#039;baz&#039;);
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys(&#039;foo&#039;);
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(&#039;bar&#039;, &#039;baz&#039;);
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys([&#039;foo&#039;]);
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({&#039;foo&#039;: 6});
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys([&#039;bar&#039;, &#039;foo&#039;]);
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({&#039;bar&#039;: 6, &#039;foo&#039;: 7});
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys([&#039;bar&#039;, &#039;foo&#039;]);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({&#039;bar&#039;: 6});
   *
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, &#039;object&#039;)
      , str
      , ok = true
      , mixedArgsMsg = &#039;keys must be given single argument of Array|Object|String, or multiple String arguments&#039;;

    switch (_.type(keys)) {
      case &quot;array&quot;:
        if (arguments.length &gt; 1) throw (new Error(mixedArgsMsg));
        break;
      case &quot;object&quot;:
        if (arguments.length &gt; 1) throw (new Error(mixedArgsMsg));
        keys = Object.keys(keys);
        break;
      default:
        keys = Array.prototype.slice.call(arguments);
    }

    if (!keys.length) throw new Error(&#039;keys required&#039;);

    var actual = Object.keys(obj)
      , expected = keys
      , len = keys.length
      , any = flag(this, &#039;any&#039;)
      , all = flag(this, &#039;all&#039;);

    if (!any &amp;&amp; !all) {
      all = true;
    }

    // Has any
    if (any) {
      var intersection = expected.filter(function(key) {
        return ~actual.indexOf(key);
      });
      ok = intersection.length &gt; 0;
    }

    // Has all
    if (all) {
      ok = keys.every(function(key){
        return ~actual.indexOf(key);
      });
      if (!flag(this, &#039;negate&#039;) &amp;&amp; !flag(this, &#039;contains&#039;)) {
        ok = ok &amp;&amp; keys.length == actual.length;
      }
    }

    // Key string
    if (len &gt; 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      if (all) {
        str = keys.join(&#039;, &#039;) + &#039;, and &#039; + last;
      }
      if (any) {
        str = keys.join(&#039;, &#039;) + &#039;, or &#039; + last;
      }
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len &gt; 1 ? &#039;keys &#039; : &#039;key &#039;) + str;

    // Have / include
    str = (flag(this, &#039;contains&#039;) ? &#039;contain &#039; : &#039;have &#039;) + str;

    // Assertion
    this.assert(
        ok
      , &#039;expected #{this} to &#039; + str
      , &#039;expected #{this} to not &#039; + str
      , expected.slice(0).sort()
      , actual.sort()
      , true
    );
  }

  Assertion.addMethod(&#039;keys&#039;, assertKeys);
  Assertion.addMethod(&#039;key&#039;, assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error&#039;s message.
   *
   *     var err = new ReferenceError(&#039;This is a bad function.&#039;);
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw(&#039;good function&#039;);
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    new Assertion(obj, msg).is.a(&#039;function&#039;);

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor &amp;&amp; (constructor instanceof RegExp || &#039;string&#039; === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor &amp;&amp; constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === &#039;function&#039;) {
      name = constructor.prototype.name;
      if (!name || (name === &#039;Error&#039; &amp;&amp; constructor !== Error)) {
        name = constructor.name || (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , &#039;expected #{this} to throw #{exp} but #{act} was thrown&#039;
          , &#039;expected #{this} to not throw #{exp}&#039;
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, &#039;object&#039;, err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , &#039;expected #{this} to throw #{exp} but #{act} was thrown&#039;
          , &#039;expected #{this} to not throw #{exp} but #{act} was thrown&#039;
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, &#039;object&#039;, err);
          return this;
        }
      }

      // next, check message
      var message = &#039;error&#039; === _.type(err) &amp;&amp; &quot;message&quot; in err
        ? err.message
        : &#039;&#039; + err;

      if ((message != null) &amp;&amp; errMsg &amp;&amp; errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , &#039;expected #{this} to throw error matching #{exp} but got #{act}&#039;
          , &#039;expected #{this} to throw error not matching #{exp}&#039;
          , errMsg
          , message
        );

        flag(this, &#039;object&#039;, err);
        return this;
      } else if ((message != null) &amp;&amp; errMsg &amp;&amp; &#039;string&#039; === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , &#039;expected #{this} to throw error including #{exp} but got #{act}&#039;
          , &#039;expected #{this} to throw error not including #{act}&#039;
          , errMsg
          , message
        );

        flag(this, &#039;object&#039;, err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = &#039;&#039;
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? &#039;#{exp}&#039; //_.inspect(desiredError)
          : &#039;an error&#039;;

    if (thrown) {
      actuallyGot = &#039; but #{act} was thrown&#039;
    }

    this.assert(
        thrown === true
      , &#039;expected #{this} to throw &#039; + expectedThrown + actuallyGot
      , &#039;expected #{this} to not throw &#039; + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, &#039;object&#039;, thrownError);
  };

  Assertion.addMethod(&#039;throw&#039;, assertThrows);
  Assertion.addMethod(&#039;throws&#039;, assertThrows);
  Assertion.addMethod(&#039;Throw&#039;, assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo(&#039;bar&#039;);
   *     expect(obj).to.respondTo(&#039;bar&#039;);
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo(&#039;baz&#039;);
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function respondTo (method, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;)
      , itself = flag(this, &#039;itself&#039;)
      , context = (&#039;function&#039; === _.type(obj) &amp;&amp; !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        &#039;function&#039; === typeof context
      , &#039;expected #{this} to respond to &#039; + _.inspect(method)
      , &#039;expected #{this} to not respond to &#039; + _.inspect(method)
    );
  }

  Assertion.addMethod(&#039;respondTo&#039;, respondTo);
  Assertion.addMethod(&#039;respondsTo&#039;, respondTo);

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo(&#039;bar&#039;);
   *     expect(Foo).itself.not.to.respondTo(&#039;baz&#039;);
   *
   * @name itself
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;itself&#039;, function () {
    flag(this, &#039;itself&#039;, true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num &gt; 0; });
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function satisfy (matcher, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    var result = matcher(obj);
    this.assert(
        result
      , &#039;expected #{this} to satisfy &#039; + _.objDisplay(matcher)
      , &#039;expected #{this} to not satisfy&#039; + _.objDisplay(matcher)
      , this.negate ? false : true
      , result
    );
  }

  Assertion.addMethod(&#039;satisfy&#039;, satisfy);
  Assertion.addMethod(&#039;satisfies&#039;, satisfy);

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function closeTo(expected, delta, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);

    new Assertion(obj, msg).is.a(&#039;number&#039;);
    if (_.type(expected) !== &#039;number&#039; || _.type(delta) !== &#039;number&#039;) {
      throw new Error(&#039;the arguments to closeTo or approximately must be numbers&#039;);
    }

    this.assert(
        Math.abs(obj - expected) &lt;= delta
      , &#039;expected #{this} to be close to &#039; + expected + &#039; +/- &#039; + delta
      , &#039;expected #{this} not to be close to &#039; + expected + &#039; +/- &#039; + delta
    );
  }

  Assertion.addMethod(&#039;closeTo&#039;, closeTo);
  Assertion.addMethod(&#039;approximately&#039;, closeTo);

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod(&#039;members&#039;, function (subset, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);

    new Assertion(obj).to.be.an(&#039;array&#039;);
    new Assertion(subset).to.be.an(&#039;array&#039;);

    var cmp = flag(this, &#039;deep&#039;) ? _.eql : undefined;

    if (flag(this, &#039;contains&#039;)) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , &#039;expected #{this} to be a superset of #{act}&#039;
        , &#039;expected #{this} to not be a superset of #{act}&#039;
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) &amp;&amp; isSubsetOf(subset, obj, cmp)
        , &#039;expected #{this} to have the same members as #{act}&#039;
        , &#039;expected #{this} to not have the same members as #{act}&#039;
        , obj
        , subset
    );
  });

  /**
   * ### .oneOf(list)
   *
   * Assert that a value appears somewhere in the top level of array `list`.
   *
   *     expect(&#039;a&#039;).to.be.oneOf([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;]);
   *     expect(9).to.not.be.oneOf([&#039;z&#039;]);
   *     expect([3]).to.not.be.oneOf([1, 2, [3]]);
   *
   *     var three = [3];
   *     // for object-types, contents are not compared
   *     expect(three).to.not.be.oneOf([1, 2, [3]]);
   *     // comparing references works
   *     expect(three).to.be.oneOf([1, 2, three]);
   *
   * @name oneOf
   * @param {Array&lt;*&gt;} list
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function oneOf (list, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var expected = flag(this, &#039;object&#039;);
    new Assertion(list).to.be.an(&#039;array&#039;);

    this.assert(
        list.indexOf(expected) &gt; -1
      , &#039;expected #{this} to be one of #{exp}&#039;
      , &#039;expected #{this} to not be one of #{exp}&#039;
      , list
      , expected
    );
  }

  Assertion.addMethod(&#039;oneOf&#039;, oneOf);


  /**
   * ### .change(function)
   *
   * Asserts that a function changes an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 3 };
   *     var noChangeFn = function() { return &#039;foo&#039; + &#039;bar&#039;; }
   *     expect(fn).to.change(obj, &#039;val&#039;);
   *     expect(noChangeFn).to.not.change(obj, &#039;val&#039;)
   *
   * @name change
   * @alias changes
   * @alias Change
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertChanges (object, prop, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var fn = flag(this, &#039;object&#039;);
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a(&#039;function&#039;);

    var initial = object[prop];
    fn();

    this.assert(
      initial !== object[prop]
      , &#039;expected .&#039; + prop + &#039; to change&#039;
      , &#039;expected .&#039; + prop + &#039; to not change&#039;
    );
  }

  Assertion.addChainableMethod(&#039;change&#039;, assertChanges);
  Assertion.addChainableMethod(&#039;changes&#039;, assertChanges);

  /**
   * ### .increase(function)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     expect(fn).to.increase(obj, &#039;val&#039;);
   *
   * @name increase
   * @alias increases
   * @alias Increase
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertIncreases (object, prop, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var fn = flag(this, &#039;object&#039;);
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a(&#039;function&#039;);

    var initial = object[prop];
    fn();

    this.assert(
      object[prop] - initial &gt; 0
      , &#039;expected .&#039; + prop + &#039; to increase&#039;
      , &#039;expected .&#039; + prop + &#039; to not increase&#039;
    );
  }

  Assertion.addChainableMethod(&#039;increase&#039;, assertIncreases);
  Assertion.addChainableMethod(&#039;increases&#039;, assertIncreases);

  /**
   * ### .decrease(function)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     expect(fn).to.decrease(obj, &#039;val&#039;);
   *
   * @name decrease
   * @alias decreases
   * @alias Decrease
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertDecreases (object, prop, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var fn = flag(this, &#039;object&#039;);
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a(&#039;function&#039;);

    var initial = object[prop];
    fn();

    this.assert(
      object[prop] - initial &lt; 0
      , &#039;expected .&#039; + prop + &#039; to decrease&#039;
      , &#039;expected .&#039; + prop + &#039; to not decrease&#039;
    );
  }

  Assertion.addChainableMethod(&#039;decrease&#039;, assertDecreases);
  Assertion.addChainableMethod(&#039;decreases&#039;, assertDecreases);

  /**
   * ### .extensible
   *
   * Asserts that the target is extensible (can have new properties added to
   * it).
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect({}).to.be.extensible;
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;extensible&#039;, function() {
    var obj = flag(this, &#039;object&#039;);

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isExtensible;

    try {
      isExtensible = Object.isExtensible(obj);
    } catch (err) {
      if (err instanceof TypeError) isExtensible = false;
      else throw err;
    }

    this.assert(
      isExtensible
      , &#039;expected #{this} to be extensible&#039;
      , &#039;expected #{this} to not be extensible&#039;
    );
  });

  /**
   * ### .sealed
   *
   * Asserts that the target is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect({}).to.not.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;sealed&#039;, function() {
    var obj = flag(this, &#039;object&#039;);

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isSealed;

    try {
      isSealed = Object.isSealed(obj);
    } catch (err) {
      if (err instanceof TypeError) isSealed = true;
      else throw err;
    }

    this.assert(
      isSealed
      , &#039;expected #{this} to be sealed&#039;
      , &#039;expected #{this} to not be sealed&#039;
    );
  });

  /**
   * ### .frozen
   *
   * Asserts that the target is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect({}).to.not.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;frozen&#039;, function() {
    var obj = flag(this, &#039;object&#039;);

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isFrozen;

    try {
      isFrozen = Object.isFrozen(obj);
    } catch (err) {
      if (err instanceof TypeError) isFrozen = true;
      else throw err;
    }

    this.assert(
      isFrozen
      , &#039;expected #{this} to be frozen&#039;
      , &#039;expected #{this} to not be frozen&#039;
    );
  });
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
