<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/bluebird/js/main/promisify.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/bluebird/js/main/promisify.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">306</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">55.54</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.77</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
module.exports = function(Promise, INTERNAL) {
var THIS = {};
var util = require(&quot;./util.js&quot;);
var nodebackForPromise = require(&quot;./promise_resolver.js&quot;)
    ._nodebackForPromise;
var withAppended = util.withAppended;
var maybeWrapAsError = util.maybeWrapAsError;
var canEvaluate = util.canEvaluate;
var TypeError = require(&quot;./errors&quot;).TypeError;
var defaultSuffix = &quot;Async&quot;;
var defaultPromisified = {__isPromisified__: true};
var noCopyProps = [
    &quot;arity&quot;,    &quot;length&quot;,
    &quot;name&quot;,
    &quot;arguments&quot;,
    &quot;caller&quot;,
    &quot;callee&quot;,
    &quot;prototype&quot;,
    &quot;__isPromisified__&quot;
];
var noCopyPropsPattern = new RegExp(&quot;^(?:&quot; + noCopyProps.join(&quot;|&quot;) + &quot;)$&quot;);

var defaultFilter = function(name) {
    return util.isIdentifier(name) &amp;&amp;
        name.charAt(0) !== &quot;_&quot; &amp;&amp;
        name !== &quot;constructor&quot;;
};

function propsFilter(key) {
    return !noCopyPropsPattern.test(key);
}

function isPromisified(fn) {
    try {
        return fn.__isPromisified__ === true;
    }
    catch (e) {
        return false;
    }
}

function hasPromisified(obj, key, suffix) {
    var val = util.getDataPropertyOrDefault(obj, key + suffix,
                                            defaultPromisified);
    return val ? isPromisified(val) : false;
}
function checkValid(ret, suffix, suffixRegexp) {
    for (var i = 0; i &lt; ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, &quot;&quot;);
            for (var j = 0; j &lt; ret.length; j += 2) {
                if (ret[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError(&quot;Cannot promisify an API that has normal methods with &#039;%s&#039;-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a&quot;
                        .replace(&quot;%s&quot;, suffix));
                }
            }
        }
    }
}

function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
    var keys = util.inheritedDataKeys(obj);
    var ret = [];
    for (var i = 0; i &lt; keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter === defaultFilter
            ? true : defaultFilter(key, value, obj);
        if (typeof value === &quot;function&quot; &amp;&amp;
            !isPromisified(value) &amp;&amp;
            !hasPromisified(obj, key, suffix) &amp;&amp;
            filter(key, value, obj, passesDefaultFilter)) {
            ret.push(key, value);
        }
    }
    checkValid(ret, suffix, suffixRegexp);
    return ret;
}

var escapeIdentRegex = function(str) {
    return str.replace(/([$])/, &quot;\\$&quot;);
};

var makeNodePromisifiedEval;
if (!false) {
var switchCaseArgumentOrder = function(likelyArgumentCount) {
    var ret = [likelyArgumentCount];
    var min = Math.max(0, likelyArgumentCount - 1 - 3);
    for(var i = likelyArgumentCount - 1; i &gt;= min; --i) {
        ret.push(i);
    }
    for(var i = likelyArgumentCount + 1; i &lt;= 3; ++i) {
        ret.push(i);
    }
    return ret;
};

var argumentSequence = function(argumentCount) {
    return util.filledRange(argumentCount, &quot;_arg&quot;, &quot;&quot;);
};

var parameterDeclaration = function(parameterCount) {
    return util.filledRange(
        Math.max(parameterCount, 3), &quot;_arg&quot;, &quot;&quot;);
};

var parameterCount = function(fn) {
    if (typeof fn.length === &quot;number&quot;) {
        return Math.max(Math.min(fn.length, 1023 + 1), 0);
    }
    return 0;
};

makeNodePromisifiedEval =
function(callback, receiver, originalName, fn) {
    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
    var shouldProxyThis = typeof callback === &quot;string&quot; || receiver === THIS;

    function generateCallForArgumentCount(count) {
        var args = argumentSequence(count).join(&quot;, &quot;);
        var comma = count &gt; 0 ? &quot;, &quot; : &quot;&quot;;
        var ret;
        if (shouldProxyThis) {
            ret = &quot;ret = callback.call(this, {{args}}, nodeback); break;\n&quot;;
        } else {
            ret = receiver === undefined
                ? &quot;ret = callback({{args}}, nodeback); break;\n&quot;
                : &quot;ret = callback.call(receiver, {{args}}, nodeback); break;\n&quot;;
        }
        return ret.replace(&quot;{{args}}&quot;, args).replace(&quot;, &quot;, comma);
    }

    function generateArgumentSwitchCase() {
        var ret = &quot;&quot;;
        for (var i = 0; i &lt; argumentOrder.length; ++i) {
            ret += &quot;case &quot; + argumentOrder[i] +&quot;:&quot; +
                generateCallForArgumentCount(argumentOrder[i]);
        }

        ret += &quot;                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i &lt; len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        &quot;.replace(&quot;[CodeForCall]&quot;, (shouldProxyThis
                                ? &quot;ret = callback.apply(this, args);\n&quot;
                                : &quot;ret = callback.apply(receiver, args);\n&quot;));
        return ret;
    }

    var getFunctionCode = typeof callback === &quot;string&quot;
                                ? (&quot;this != null ? this[&#039;&quot;+callback+&quot;&#039;] : fn&quot;)
                                : &quot;fn&quot;;

    return new Function(&quot;Promise&quot;,
                        &quot;fn&quot;,
                        &quot;receiver&quot;,
                        &quot;withAppended&quot;,
                        &quot;maybeWrapAsError&quot;,
                        &quot;nodebackForPromise&quot;,
                        &quot;tryCatch&quot;,
                        &quot;errorObj&quot;,
                        &quot;notEnumerableProp&quot;,
                        &quot;INTERNAL&quot;,&quot;&#039;use strict&#039;;                            \n\
        var ret = function (Parameters) {                                    \n\
            &#039;use strict&#039;;                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise);                      \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, &#039;__isPromisified__&#039;, true);                   \n\
        return ret;                                                          \n\
        &quot;
        .replace(&quot;Parameters&quot;, parameterDeclaration(newParameterCount))
        .replace(&quot;[CodeForSwitchCase]&quot;, generateArgumentSwitchCase())
        .replace(&quot;[GetFunctionCode]&quot;, getFunctionCode))(
            Promise,
            fn,
            receiver,
            withAppended,
            maybeWrapAsError,
            nodebackForPromise,
            util.tryCatch,
            util.errorObj,
            util.notEnumerableProp,
            INTERNAL
        );
};
}

function makeNodePromisifiedClosure(callback, receiver, _, fn) {
    var defaultThis = (function() {return this;})();
    var method = callback;
    if (typeof method === &quot;string&quot;) {
        callback = fn;
    }
    function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        var promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        var cb = typeof method === &quot;string&quot; &amp;&amp; this !== defaultThis
            ? this[method] : callback;
        var fn = nodebackForPromise(promise);
        try {
            cb.apply(_receiver, withAppended(arguments, fn));
        } catch(e) {
            promise._rejectCallback(maybeWrapAsError(e), true, true);
        }
        return promise;
    }
    util.notEnumerableProp(promisified, &quot;__isPromisified__&quot;, true);
    return promisified;
}

var makeNodePromisified = canEvaluate
    ? makeNodePromisifiedEval
    : makeNodePromisifiedClosure;

function promisifyAll(obj, suffix, filter, promisifier) {
    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + &quot;$&quot;);
    var methods =
        promisifiableMethods(obj, suffix, suffixRegexp, filter);

    for (var i = 0, len = methods.length; i &lt; len; i+= 2) {
        var key = methods[i];
        var fn = methods[i+1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
            obj[promisifiedKey] =
                makeNodePromisified(key, THIS, key, fn, suffix);
        } else {
            var promisified = promisifier(fn, function() {
                return makeNodePromisified(key, THIS, key, fn, suffix);
            });
            util.notEnumerableProp(promisified, &quot;__isPromisified__&quot;, true);
            obj[promisifiedKey] = promisified;
        }
    }
    util.toFastProperties(obj);
    return obj;
}

function promisify(callback, receiver) {
    return makeNodePromisified(callback, receiver, undefined, callback);
}

Promise.promisify = function (fn, receiver) {
    if (typeof fn !== &quot;function&quot;) {
        throw new TypeError(&quot;fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a&quot;);
    }
    if (isPromisified(fn)) {
        return fn;
    }
    var ret = promisify(fn, arguments.length &lt; 2 ? THIS : receiver);
    util.copyDescriptors(fn, ret, propsFilter);
    return ret;
};

Promise.promisifyAll = function (target, options) {
    if (typeof target !== &quot;function&quot; &amp;&amp; typeof target !== &quot;object&quot;) {
        throw new TypeError(&quot;the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a&quot;);
    }
    options = Object(options);
    var suffix = options.suffix;
    if (typeof suffix !== &quot;string&quot;) suffix = defaultSuffix;
    var filter = options.filter;
    if (typeof filter !== &quot;function&quot;) filter = defaultFilter;
    var promisifier = options.promisifier;
    if (typeof promisifier !== &quot;function&quot;) promisifier = makeNodePromisified;

    if (!util.isIdentifier(suffix)) {
        throw new RangeError(&quot;suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a&quot;);
    }

    var keys = util.inheritedDataKeys(target);
    for (var i = 0; i &lt; keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== &quot;constructor&quot; &amp;&amp;
            util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier);
            promisifyAll(value, suffix, filter, promisifier);
        }
    }

    return promisifyAll(target, suffix, filter, promisifier);
};
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
