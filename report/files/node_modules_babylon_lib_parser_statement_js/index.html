<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/babylon/lib/parser/statement.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/babylon/lib/parser/statement.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.37</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1043</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">116.69</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">14.82</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

var _types = require(&quot;../tokenizer/types&quot;);

var _index = require(&quot;./index&quot;);

var _index2 = _interopRequireDefault(_index);

var _whitespace = require(&quot;../util/whitespace&quot;);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

var pp = _index2.default.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

/* eslint indent: 0 */
/* eslint max-len: 0 */

pp.parseTopLevel = function (file, program) {
  program.sourceType = this.options.sourceType;

  this.parseBlockBody(program, true, true, _types.types.eof);

  file.program = this.finishNode(program, &quot;Program&quot;);
  file.comments = this.state.comments;
  file.tokens = this.state.tokens;

  return this.finishNode(file, &quot;File&quot;);
};

var loopLabel = { kind: &quot;loop&quot; },
    switchLabel = { kind: &quot;switch&quot; };

// TODO

pp.stmtToDirective = function (stmt) {
  var expr = stmt.expression;

  var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
  var directive = this.startNodeAt(stmt.start, stmt.loc.start);

  var raw = this.input.slice(expr.start, expr.end);
  var val = directiveLiteral.value = raw.slice(1, -1); // remove quotes

  this.addExtra(directiveLiteral, &quot;raw&quot;, raw);
  this.addExtra(directiveLiteral, &quot;rawValue&quot;, val);

  directive.value = this.finishNodeAt(directiveLiteral, &quot;DirectiveLiteral&quot;, expr.end, expr.loc.end);

  return this.finishNodeAt(directive, &quot;Directive&quot;, stmt.end, stmt.loc.end);
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp.parseStatement = function (declaration, topLevel) {
  if (this.match(_types.types.at)) {
    this.parseDecorators(true);
  }

  var starttype = this.state.type,
      node = this.startNode();

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
    case _types.types._break:case _types.types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case _types.types._debugger:
      return this.parseDebuggerStatement(node);
    case _types.types._do:
      return this.parseDoStatement(node);
    case _types.types._for:
      return this.parseForStatement(node);
    case _types.types._function:
      if (!declaration) this.unexpected();
      return this.parseFunctionStatement(node);

    case _types.types._class:
      if (!declaration) this.unexpected();
      this.takeDecorators(node);
      return this.parseClass(node, true);

    case _types.types._if:
      return this.parseIfStatement(node);
    case _types.types._return:
      return this.parseReturnStatement(node);
    case _types.types._switch:
      return this.parseSwitchStatement(node);
    case _types.types._throw:
      return this.parseThrowStatement(node);
    case _types.types._try:
      return this.parseTryStatement(node);

    case _types.types._let:
    case _types.types._const:
      if (!declaration) this.unexpected(); // NOTE: falls through to _var

    case _types.types._var:
      return this.parseVarStatement(node, starttype);

    case _types.types._while:
      return this.parseWhileStatement(node);
    case _types.types._with:
      return this.parseWithStatement(node);
    case _types.types.braceL:
      return this.parseBlock();
    case _types.types.semi:
      return this.parseEmptyStatement(node);
    case _types.types._export:
    case _types.types._import:
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.state.start, &quot;&#039;import&#039; and &#039;export&#039; may only appear at the top level&quot;);
        }

        if (!this.inModule) {
          this.raise(this.state.start, &quot;&#039;import&#039; and &#039;export&#039; may appear only with &#039;sourceType: module&#039;&quot;);
        }
      }
      return starttype === _types.types._import ? this.parseImport(node) : this.parseExport(node);

    case _types.types.name:
      if (this.state.value === &quot;async&quot;) {
        // peek ahead and see if next token is a function
        var state = this.state.clone();
        this.next();
        if (this.match(_types.types._function) &amp;&amp; !this.canInsertSemicolon()) {
          this.expect(_types.types._function);
          return this.parseFunction(node, true, false, true);
        } else {
          this.state = state;
        }
      }
  }

  // If the statement does not start with a statement keyword or a
  // brace, it&#039;s an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
  var maybeName = this.state.value;
  var expr = this.parseExpression();

  if (starttype === _types.types.name &amp;&amp; expr.type === &quot;Identifier&quot; &amp;&amp; this.eat(_types.types.colon)) {
    return this.parseLabeledStatement(node, maybeName, expr);
  } else {
    return this.parseExpressionStatement(node, expr);
  }
};

pp.takeDecorators = function (node) {
  if (this.state.decorators.length) {
    node.decorators = this.state.decorators;
    this.state.decorators = [];
  }
};

pp.parseDecorators = function (allowExport) {
  while (this.match(_types.types.at)) {
    this.state.decorators.push(this.parseDecorator());
  }

  if (allowExport &amp;&amp; this.match(_types.types._export)) {
    return;
  }

  if (!this.match(_types.types._class)) {
    this.raise(this.state.start, &quot;Leading decorators must be attached to a class declaration&quot;);
  }
};

pp.parseDecorator = function () {
  if (!this.hasPlugin(&quot;decorators&quot;)) {
    this.unexpected();
  }
  var node = this.startNode();
  this.next();
  node.expression = this.parseMaybeAssign();
  return this.finishNode(node, &quot;Decorator&quot;);
};

pp.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword === &quot;break&quot;;
  this.next();

  if (this.isLineTerminator()) {
    node.label = null;
  } else if (!this.match(_types.types.name)) {
    this.unexpected();
  } else {
    node.label = this.parseIdentifier();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = void 0;
  for (i = 0; i &lt; this.state.labels.length; ++i) {
    var lab = this.state.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null &amp;&amp; (isBreak || lab.kind === &quot;loop&quot;)) break;
      if (node.label &amp;&amp; isBreak) break;
    }
  }
  if (i === this.state.labels.length) this.raise(node.start, &quot;Unsyntactic &quot; + keyword);
  return this.finishNode(node, isBreak ? &quot;BreakStatement&quot; : &quot;ContinueStatement&quot;);
};

pp.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, &quot;DebuggerStatement&quot;);
};

pp.parseDoStatement = function (node) {
  this.next();
  this.state.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  this.expect(_types.types._while);
  node.test = this.parseParenExpression();
  this.eat(_types.types.semi);
  return this.finishNode(node, &quot;DoWhileStatement&quot;);
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp.parseForStatement = function (node) {
  this.next();
  this.state.labels.push(loopLabel);

  var forAwait = false;
  if (this.hasPlugin(&quot;asyncGenerators&quot;) &amp;&amp; this.state.inAsync &amp;&amp; this.isContextual(&quot;await&quot;)) {
    forAwait = true;
    this.next();
  }
  this.expect(_types.types.parenL);

  if (this.match(_types.types.semi)) {
    if (forAwait) {
      this.unexpected();
    }
    return this.parseFor(node, null);
  }

  if (this.match(_types.types._var) || this.match(_types.types._let) || this.match(_types.types._const)) {
    var _init = this.startNode(),
        varKind = this.state.type;
    this.next();
    this.parseVar(_init, true, varKind);
    this.finishNode(_init, &quot;VariableDeclaration&quot;);

    if (this.match(_types.types._in) || this.isContextual(&quot;of&quot;)) {
      if (_init.declarations.length === 1 &amp;&amp; !_init.declarations[0].init) {
        return this.parseForIn(node, _init, forAwait);
      }
    }
    if (forAwait) {
      this.unexpected();
    }
    return this.parseFor(node, _init);
  }

  var refShorthandDefaultPos = { start: 0 };
  var init = this.parseExpression(true, refShorthandDefaultPos);
  if (this.match(_types.types._in) || this.isContextual(&quot;of&quot;)) {
    this.toAssignable(init);
    this.checkLVal(init);
    return this.parseForIn(node, init, forAwait);
  } else if (refShorthandDefaultPos.start) {
    this.unexpected(refShorthandDefaultPos.start);
  }
  if (forAwait) {
    this.unexpected();
  }
  return this.parseFor(node, init);
};

pp.parseFunctionStatement = function (node) {
  this.next();
  return this.parseFunction(node, true);
};

pp.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(false);
  node.alternate = this.eat(_types.types._else) ? this.parseStatement(false) : null;
  return this.finishNode(node, &quot;IfStatement&quot;);
};

pp.parseReturnStatement = function (node) {
  if (!this.state.inFunction &amp;&amp; !this.options.allowReturnOutsideFunction) {
    this.raise(this.state.start, &quot;&#039;return&#039; outside of function&quot;);
  }

  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.isLineTerminator()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }

  return this.finishNode(node, &quot;ReturnStatement&quot;);
};

pp.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(_types.types.braceL);
  this.state.labels.push(switchLabel);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur = void 0;
  for (var sawDefault; !this.match(_types.types.braceR);) {
    if (this.match(_types.types._case) || this.match(_types.types._default)) {
      var isCase = this.match(_types.types._case);
      if (cur) this.finishNode(cur, &quot;SwitchCase&quot;);
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) this.raise(this.state.lastTokStart, &quot;Multiple default clauses&quot;);
        sawDefault = true;
        cur.test = null;
      }
      this.expect(_types.types.colon);
    } else {
      if (cur) {
        cur.consequent.push(this.parseStatement(true));
      } else {
        this.unexpected();
      }
    }
  }
  if (cur) this.finishNode(cur, &quot;SwitchCase&quot;);
  this.next(); // Closing brace
  this.state.labels.pop();
  return this.finishNode(node, &quot;SwitchStatement&quot;);
};

pp.parseThrowStatement = function (node) {
  this.next();
  if (_whitespace.lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) this.raise(this.state.lastTokEnd, &quot;Illegal newline after throw&quot;);
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, &quot;ThrowStatement&quot;);
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp.parseTryStatement = function (node) {
  this.next();

  node.block = this.parseBlock();
  node.handler = null;

  if (this.match(_types.types._catch)) {
    var clause = this.startNode();
    this.next();

    this.expect(_types.types.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true, Object.create(null));
    this.expect(_types.types.parenR);

    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, &quot;CatchClause&quot;);
  }

  node.guardedHandlers = empty;
  node.finalizer = this.eat(_types.types._finally) ? this.parseBlock() : null;

  if (!node.handler &amp;&amp; !node.finalizer) {
    this.raise(node.start, &quot;Missing catch or finally clause&quot;);
  }

  return this.finishNode(node, &quot;TryStatement&quot;);
};

pp.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, &quot;VariableDeclaration&quot;);
};

pp.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.state.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, &quot;WhileStatement&quot;);
};

pp.parseWithStatement = function (node) {
  if (this.state.strict) this.raise(this.state.start, &quot;&#039;with&#039; in strict mode&quot;);
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, &quot;WithStatement&quot;);
};

pp.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, &quot;EmptyStatement&quot;);
};

pp.parseLabeledStatement = function (node, maybeName, expr) {
  for (var _iterator = this.state.labels, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i &gt;= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var _label = _ref;

    if (_label.name === maybeName) {
      this.raise(expr.start, &quot;Label &#039;&quot; + maybeName + &quot;&#039; is already declared&quot;);
    }
  }

  var kind = this.state.type.isLoop ? &quot;loop&quot; : this.match(_types.types._switch) ? &quot;switch&quot; : null;
  for (var i = this.state.labels.length - 1; i &gt;= 0; i--) {
    var label = this.state.labels[i];
    if (label.statementStart === node.start) {
      label.statementStart = this.state.start;
      label.kind = kind;
    } else {
      break;
    }
  }

  this.state.labels.push({ name: maybeName, kind: kind, statementStart: this.state.start });
  node.body = this.parseStatement(true);
  this.state.labels.pop();
  node.label = expr;
  return this.finishNode(node, &quot;LabeledStatement&quot;);
};

pp.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, &quot;ExpressionStatement&quot;);
};

// Parse a semicolon-enclosed block of statements, handling `&quot;use
// strict&quot;` declarations when `allowStrict` is true (used for
// function bodies).

pp.parseBlock = function (allowDirectives) {
  var node = this.startNode();
  this.expect(_types.types.braceL);
  this.parseBlockBody(node, allowDirectives, false, _types.types.braceR);
  return this.finishNode(node, &quot;BlockStatement&quot;);
};

// TODO

pp.parseBlockBody = function (node, allowDirectives, topLevel, end) {
  node.body = [];
  node.directives = [];

  var parsedNonDirective = false;
  var oldStrict = void 0;
  var octalPosition = void 0;

  while (!this.eat(end)) {
    if (!parsedNonDirective &amp;&amp; this.state.containsOctal &amp;&amp; !octalPosition) {
      octalPosition = this.state.octalPosition;
    }

    var stmt = this.parseStatement(true, topLevel);

    if (allowDirectives &amp;&amp; !parsedNonDirective &amp;&amp; stmt.type === &quot;ExpressionStatement&quot; &amp;&amp; stmt.expression.type === &quot;StringLiteral&quot; &amp;&amp; !stmt.expression.extra.parenthesized) {
      var directive = this.stmtToDirective(stmt);
      node.directives.push(directive);

      if (oldStrict === undefined &amp;&amp; directive.value.value === &quot;use strict&quot;) {
        oldStrict = this.state.strict;
        this.setStrict(true);

        if (octalPosition) {
          this.raise(octalPosition, &quot;Octal literal in strict mode&quot;);
        }
      }

      continue;
    }

    parsedNonDirective = true;
    node.body.push(stmt);
  }

  if (oldStrict === false) {
    this.setStrict(false);
  }
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp.parseFor = function (node, init) {
  node.init = init;
  this.expect(_types.types.semi);
  node.test = this.match(_types.types.semi) ? null : this.parseExpression();
  this.expect(_types.types.semi);
  node.update = this.match(_types.types.parenR) ? null : this.parseExpression();
  this.expect(_types.types.parenR);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, &quot;ForStatement&quot;);
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser&#039;s perspective.

pp.parseForIn = function (node, init, forAwait) {
  var type = void 0;
  if (forAwait) {
    this.eatContextual(&quot;of&quot;);
    type = &quot;ForAwaitStatement&quot;;
  } else {
    type = this.match(_types.types._in) ? &quot;ForInStatement&quot; : &quot;ForOfStatement&quot;;
    this.next();
  }
  node.left = init;
  node.right = this.parseExpression();
  this.expect(_types.types.parenR);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, type);
};

// Parse a list of variable declarations.

pp.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind.keyword;
  for (;;) {
    var decl = this.startNode();
    this.parseVarHead(decl);
    if (this.eat(_types.types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === _types.types._const &amp;&amp; !(this.match(_types.types._in) || this.isContextual(&quot;of&quot;))) {
      this.unexpected();
    } else if (decl.id.type !== &quot;Identifier&quot; &amp;&amp; !(isFor &amp;&amp; (this.match(_types.types._in) || this.isContextual(&quot;of&quot;)))) {
      this.raise(this.state.lastTokEnd, &quot;Complex binding patterns require an initialization value&quot;);
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, &quot;VariableDeclarator&quot;));
    if (!this.eat(_types.types.comma)) break;
  }
  return node;
};

pp.parseVarHead = function (decl) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, true);
};

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp.parseFunction = function (node, isStatement, allowExpressionBody, isAsync, optionalId) {
  var oldInMethod = this.state.inMethod;
  this.state.inMethod = false;

  this.initFunction(node, isAsync);

  if (this.match(_types.types.star)) {
    if (node.async &amp;&amp; !this.hasPlugin(&quot;asyncGenerators&quot;)) {
      this.unexpected();
    } else {
      node.generator = true;
      this.next();
    }
  }

  if (isStatement &amp;&amp; !optionalId &amp;&amp; !this.match(_types.types.name) &amp;&amp; !this.match(_types.types._yield)) {
    this.unexpected();
  }

  if (this.match(_types.types.name) || this.match(_types.types._yield)) {
    node.id = this.parseBindingIdentifier();
  }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);

  this.state.inMethod = oldInMethod;

  return this.finishNode(node, isStatement ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot;);
};

pp.parseFunctionParams = function (node) {
  this.expect(_types.types.parenL);
  node.params = this.parseBindingList(_types.types.parenR);
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp.parseClass = function (node, isStatement, optionalId) {
  this.next();
  this.parseClassId(node, isStatement, optionalId);
  this.parseClassSuper(node);
  this.parseClassBody(node);
  return this.finishNode(node, isStatement ? &quot;ClassDeclaration&quot; : &quot;ClassExpression&quot;);
};

pp.isClassProperty = function () {
  return this.match(_types.types.eq) || this.isLineTerminator();
};

pp.isClassMutatorStarter = function () {
  return false;
};

pp.parseClassBody = function (node) {
  // class bodies are implicitly strict
  var oldStrict = this.state.strict;
  this.state.strict = true;

  var hadConstructorCall = false;
  var hadConstructor = false;
  var decorators = [];
  var classBody = this.startNode();

  classBody.body = [];

  this.expect(_types.types.braceL);

  while (!this.eat(_types.types.braceR)) {
    if (this.eat(_types.types.semi)) {
      continue;
    }

    if (this.match(_types.types.at)) {
      decorators.push(this.parseDecorator());
      continue;
    }

    var method = this.startNode();

    // steal the decorators if there are any
    if (decorators.length) {
      method.decorators = decorators;
      decorators = [];
    }

    var isConstructorCall = false;
    var isMaybeStatic = this.match(_types.types.name) &amp;&amp; this.state.value === &quot;static&quot;;
    var isGenerator = this.eat(_types.types.star);
    var isGetSet = false;
    var isAsync = false;

    this.parsePropertyName(method);

    method.static = isMaybeStatic &amp;&amp; !this.match(_types.types.parenL);
    if (method.static) {
      if (isGenerator) this.unexpected();
      isGenerator = this.eat(_types.types.star);
      this.parsePropertyName(method);
    }

    if (!isGenerator &amp;&amp; method.key.type === &quot;Identifier&quot; &amp;&amp; !method.computed) {
      if (this.isClassProperty()) {
        classBody.body.push(this.parseClassProperty(method));
        continue;
      }

      if (this.hasPlugin(&quot;classConstructorCall&quot;) &amp;&amp; method.key.name === &quot;call&quot; &amp;&amp; this.match(_types.types.name) &amp;&amp; this.state.value === &quot;constructor&quot;) {
        isConstructorCall = true;
        this.parsePropertyName(method);
      }
    }

    var isAsyncMethod = !this.match(_types.types.parenL) &amp;&amp; !method.computed &amp;&amp; method.key.type === &quot;Identifier&quot; &amp;&amp; method.key.name === &quot;async&quot;;
    if (isAsyncMethod) {
      if (this.hasPlugin(&quot;asyncGenerators&quot;) &amp;&amp; this.eat(_types.types.star)) isGenerator = true;
      isAsync = true;
      this.parsePropertyName(method);
    }

    method.kind = &quot;method&quot;;

    if (!method.computed) {
      var key = method.key;

      // handle get/set methods
      // eg. class Foo { get bar() {} set bar() {} }

      if (!isAsync &amp;&amp; !isGenerator &amp;&amp; !this.isClassMutatorStarter() &amp;&amp; key.type === &quot;Identifier&quot; &amp;&amp; !this.match(_types.types.parenL) &amp;&amp; (key.name === &quot;get&quot; || key.name === &quot;set&quot;)) {
        isGetSet = true;
        method.kind = key.name;
        key = this.parsePropertyName(method);
      }

      // disallow invalid constructors
      var isConstructor = !isConstructorCall &amp;&amp; !method.static &amp;&amp; (key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;constructor&quot; || key.type === &quot;StringLiteral&quot; &amp;&amp; key.value === &quot;constructor&quot;);
      if (isConstructor) {
        if (hadConstructor) this.raise(key.start, &quot;Duplicate constructor in the same class&quot;);
        if (isGetSet) this.raise(key.start, &quot;Constructor can&#039;t have get/set modifier&quot;);
        if (isGenerator) this.raise(key.start, &quot;Constructor can&#039;t be a generator&quot;);
        if (isAsync) this.raise(key.start, &quot;Constructor can&#039;t be an async function&quot;);
        method.kind = &quot;constructor&quot;;
        hadConstructor = true;
      }

      // disallow static prototype method
      var isStaticPrototype = method.static &amp;&amp; (key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;prototype&quot; || key.type === &quot;StringLiteral&quot; &amp;&amp; key.value === &quot;prototype&quot;);
      if (isStaticPrototype) {
        this.raise(key.start, &quot;Classes may not have static property named prototype&quot;);
      }
    }

    // convert constructor to a constructor call
    if (isConstructorCall) {
      if (hadConstructorCall) this.raise(method.start, &quot;Duplicate constructor call in the same class&quot;);
      method.kind = &quot;constructorCall&quot;;
      hadConstructorCall = true;
    }

    // disallow decorators on class constructors
    if ((method.kind === &quot;constructor&quot; || method.kind === &quot;constructorCall&quot;) &amp;&amp; method.decorators) {
      this.raise(method.start, &quot;You can&#039;t attach decorators to a class constructor&quot;);
    }

    this.parseClassMethod(classBody, method, isGenerator, isAsync);

    // get methods aren&#039;t allowed to have any parameters
    // set methods must have exactly 1 parameter
    if (isGetSet) {
      var paramCount = method.kind === &quot;get&quot; ? 0 : 1;
      if (method.params.length !== paramCount) {
        var start = method.start;
        if (method.kind === &quot;get&quot;) {
          this.raise(start, &quot;getter should have no params&quot;);
        } else {
          this.raise(start, &quot;setter should have exactly one param&quot;);
        }
      }
    }
  }

  if (decorators.length) {
    this.raise(this.state.start, &quot;You have trailing decorators with no method&quot;);
  }

  node.body = this.finishNode(classBody, &quot;ClassBody&quot;);

  this.state.strict = oldStrict;
};

pp.parseClassProperty = function (node) {
  if (this.match(_types.types.eq)) {
    if (!this.hasPlugin(&quot;classProperties&quot;)) this.unexpected();
    this.next();
    node.value = this.parseMaybeAssign();
  } else {
    node.value = null;
  }
  this.semicolon();
  return this.finishNode(node, &quot;ClassProperty&quot;);
};

pp.parseClassMethod = function (classBody, method, isGenerator, isAsync) {
  this.parseMethod(method, isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, &quot;ClassMethod&quot;));
};

pp.parseClassId = function (node, isStatement, optionalId) {
  if (this.match(_types.types.name)) {
    node.id = this.parseIdentifier();
  } else {
    if (optionalId || !isStatement) {
      node.id = null;
    } else {
      this.unexpected();
    }
  }
};

pp.parseClassSuper = function (node) {
  node.superClass = this.eat(_types.types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp.parseExport = function (node) {
  this.next();
  // export * from &#039;...&#039;
  if (this.match(_types.types.star)) {
    var specifier = this.startNode();
    this.next();
    if (this.hasPlugin(&quot;exportExtensions&quot;) &amp;&amp; this.eatContextual(&quot;as&quot;)) {
      specifier.exported = this.parseIdentifier();
      node.specifiers = [this.finishNode(specifier, &quot;ExportNamespaceSpecifier&quot;)];
      this.parseExportSpecifiersMaybe(node);
      this.parseExportFrom(node, true);
    } else {
      this.parseExportFrom(node, true);
      return this.finishNode(node, &quot;ExportAllDeclaration&quot;);
    }
  } else if (this.hasPlugin(&quot;exportExtensions&quot;) &amp;&amp; this.isExportDefaultSpecifier()) {
    var _specifier = this.startNode();
    _specifier.exported = this.parseIdentifier(true);
    node.specifiers = [this.finishNode(_specifier, &quot;ExportDefaultSpecifier&quot;)];
    if (this.match(_types.types.comma) &amp;&amp; this.lookahead().type === _types.types.star) {
      this.expect(_types.types.comma);
      var _specifier2 = this.startNode();
      this.expect(_types.types.star);
      this.expectContextual(&quot;as&quot;);
      _specifier2.exported = this.parseIdentifier();
      node.specifiers.push(this.finishNode(_specifier2, &quot;ExportNamespaceSpecifier&quot;));
    } else {
      this.parseExportSpecifiersMaybe(node);
    }
    this.parseExportFrom(node, true);
  } else if (this.eat(_types.types._default)) {
    // export default ...
    var expr = this.startNode();
    var needsSemi = false;
    if (this.eat(_types.types._function)) {
      expr = this.parseFunction(expr, true, false, false, true);
    } else if (this.match(_types.types._class)) {
      expr = this.parseClass(expr, true, true);
    } else {
      needsSemi = true;
      expr = this.parseMaybeAssign();
    }
    node.declaration = expr;
    if (needsSemi) this.semicolon();
    this.checkExport(node);
    return this.finishNode(node, &quot;ExportDefaultDeclaration&quot;);
  } else if (this.state.type.keyword || this.shouldParseExportDeclaration()) {
    node.specifiers = [];
    node.source = null;
    node.declaration = this.parseExportDeclaration(node);
  } else {
    // export { x, y as z } [from &#039;...&#039;]
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers();
    this.parseExportFrom(node);
  }
  this.checkExport(node);
  return this.finishNode(node, &quot;ExportNamedDeclaration&quot;);
};

pp.parseExportDeclaration = function () {
  return this.parseStatement(true);
};

pp.isExportDefaultSpecifier = function () {
  if (this.match(_types.types.name)) {
    return this.state.value !== &quot;type&quot; &amp;&amp; this.state.value !== &quot;async&quot; &amp;&amp; this.state.value !== &quot;interface&quot;;
  }

  if (!this.match(_types.types._default)) {
    return false;
  }

  var lookahead = this.lookahead();
  return lookahead.type === _types.types.comma || lookahead.type === _types.types.name &amp;&amp; lookahead.value === &quot;from&quot;;
};

pp.parseExportSpecifiersMaybe = function (node) {
  if (this.eat(_types.types.comma)) {
    node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());
  }
};

pp.parseExportFrom = function (node, expect) {
  if (this.eatContextual(&quot;from&quot;)) {
    node.source = this.match(_types.types.string) ? this.parseExprAtom() : this.unexpected();
    this.checkExport(node);
  } else {
    if (expect) {
      this.unexpected();
    } else {
      node.source = null;
    }
  }

  this.semicolon();
};

pp.shouldParseExportDeclaration = function () {
  return this.isContextual(&quot;async&quot;);
};

pp.checkExport = function (node) {
  if (this.state.decorators.length) {
    var isClass = node.declaration &amp;&amp; (node.declaration.type === &quot;ClassDeclaration&quot; || node.declaration.type === &quot;ClassExpression&quot;);
    if (!node.declaration || !isClass) {
      this.raise(node.start, &quot;You can only use decorators on an export when exporting a class&quot;);
    }
    this.takeDecorators(node.declaration);
  }
};

// Parses a comma-separated list of module exports.

pp.parseExportSpecifiers = function () {
  var nodes = [];
  var first = true;
  var needsFrom = void 0;

  // export { x, y as z } [from &#039;...&#039;]
  this.expect(_types.types.braceL);

  while (!this.eat(_types.types.braceR)) {
    if (first) {
      first = false;
    } else {
      this.expect(_types.types.comma);
      if (this.eat(_types.types.braceR)) break;
    }

    var isDefault = this.match(_types.types._default);
    if (isDefault &amp;&amp; !needsFrom) needsFrom = true;

    var node = this.startNode();
    node.local = this.parseIdentifier(isDefault);
    node.exported = this.eatContextual(&quot;as&quot;) ? this.parseIdentifier(true) : node.local.__clone();
    nodes.push(this.finishNode(node, &quot;ExportSpecifier&quot;));
  }

  // https://github.com/ember-cli/ember-cli/pull/3739
  if (needsFrom &amp;&amp; !this.isContextual(&quot;from&quot;)) {
    this.unexpected();
  }

  return nodes;
};

// Parses import declaration.

pp.parseImport = function (node) {
  this.next();

  // import &#039;...&#039;
  if (this.match(_types.types.string)) {
    node.specifiers = [];
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = [];
    this.parseImportSpecifiers(node);
    this.expectContextual(&quot;from&quot;);
    node.source = this.match(_types.types.string) ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, &quot;ImportDeclaration&quot;);
};

// Parses a comma-separated list of module imports.

pp.parseImportSpecifiers = function (node) {
  var first = true;
  if (this.match(_types.types.name)) {
    // import defaultObj, { x, y as z } from &#039;...&#039;
    var startPos = this.state.start,
        startLoc = this.state.startLoc;
    node.specifiers.push(this.parseImportSpecifierDefault(this.parseIdentifier(), startPos, startLoc));
    if (!this.eat(_types.types.comma)) return;
  }

  if (this.match(_types.types.star)) {
    var specifier = this.startNode();
    this.next();
    this.expectContextual(&quot;as&quot;);
    specifier.local = this.parseIdentifier();
    this.checkLVal(specifier.local, true);
    node.specifiers.push(this.finishNode(specifier, &quot;ImportNamespaceSpecifier&quot;));
    return;
  }

  this.expect(_types.types.braceL);
  while (!this.eat(_types.types.braceR)) {
    if (first) {
      first = false;
    } else {
      this.expect(_types.types.comma);
      if (this.eat(_types.types.braceR)) break;
    }

    var _specifier3 = this.startNode();
    _specifier3.imported = this.parseIdentifier(true);
    _specifier3.local = this.eatContextual(&quot;as&quot;) ? this.parseIdentifier() : _specifier3.imported.__clone();
    this.checkLVal(_specifier3.local, true);
    node.specifiers.push(this.finishNode(_specifier3, &quot;ImportSpecifier&quot;));
  }
};

pp.parseImportSpecifierDefault = function (id, startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.local = id;
  this.checkLVal(node.local, true);
  return this.finishNode(node, &quot;ImportDefaultSpecifier&quot;);
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
