<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/acorn/src/walk/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/acorn/src/walk/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">73.89</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">340</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">124.29</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.94</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// AST walker module for Mozilla Parser API compatible trees

// A simple walk is one where you simply specify callbacks to be
// called on specific nodes. The last two arguments are optional. A
// simple use would be
//
//     walk.simple(myTree, {
//         Expression: function(node) { ... }
//     });
//
// to do something with all expressions. All Parser API node types
// can be used to identify node types, as well as Expression,
// Statement, and ScopeBody, which denote categories of nodes.
//
// The base argument can be used to pass a custom (recursive)
// walker, and state can be used to give this walked an initial
// state.

export function simple(node, visitors, base, state, override) {
  if (!base) base = exports.base
  ;(function c(node, st, override) {
    let type = override || node.type, found = visitors[type]
    base[type](node, st, c)
    if (found) found(node, st)
  })(node, state, override)
}

// An ancestor walk builds up an array of ancestor nodes (including
// the current node) and passes them to the callback as the state parameter.
export function ancestor(node, visitors, base, state) {
  if (!base) base = exports.base
  if (!state) state = []
  ;(function c(node, st, override) {
    let type = override || node.type, found = visitors[type]
    if (node != st[st.length - 1]) {
      st = st.slice()
      st.push(node)
    }
    base[type](node, st, c)
    if (found) found(node, st)
  })(node, state)
}

// A recursive walk is one where your functions override the default
// walkers. They can modify and replace the state parameter that&#039;s
// threaded through the walk, and can opt how and whether to walk
// their child nodes (by calling their third argument on these
// nodes).
export function recursive(node, state, funcs, base, override) {
  let visitor = funcs ? exports.make(funcs, base) : base
  ;(function c(node, st, override) {
    visitor[override || node.type](node, st, c)
  })(node, state, override)
}

function makeTest(test) {
  if (typeof test == &quot;string&quot;)
    return type =&gt; type == test
  else if (!test)
    return () =&gt; true
  else
    return test
}

class Found {
  constructor(node, state) { this.node = node; this.state = state }
}

// Find a node with a given start, end, and type (all are optional,
// null can be used as wildcard). Returns a {node, state} object, or
// undefined when it doesn&#039;t find a matching node.
export function findNodeAt(node, start, end, test, base, state) {
  test = makeTest(test)
  if (!base) base = exports.base
  try {
    ;(function c(node, st, override) {
      let type = override || node.type
      if ((start == null || node.start &lt;= start) &amp;&amp;
          (end == null || node.end &gt;= end))
        base[type](node, st, c)
      if ((start == null || node.start == start) &amp;&amp;
          (end == null || node.end == end) &amp;&amp;
          test(type, node))
        throw new Found(node, st)
    })(node, state)
  } catch (e) {
    if (e instanceof Found) return e
    throw e
  }
}

// Find the innermost node of a given type that contains the given
// position. Interface similar to findNodeAt.
export function findNodeAround(node, pos, test, base, state) {
  test = makeTest(test)
  if (!base) base = exports.base
  try {
    ;(function c(node, st, override) {
      let type = override || node.type
      if (node.start &gt; pos || node.end &lt; pos) return
      base[type](node, st, c)
      if (test(type, node)) throw new Found(node, st)
    })(node, state)
  } catch (e) {
    if (e instanceof Found) return e
    throw e
  }
}

// Find the outermost matching node after a given position.
export function findNodeAfter(node, pos, test, base, state) {
  test = makeTest(test)
  if (!base) base = exports.base
  try {
    ;(function c(node, st, override) {
      if (node.end &lt; pos) return
      let type = override || node.type
      if (node.start &gt;= pos &amp;&amp; test(type, node)) throw new Found(node, st)
      base[type](node, st, c)
    })(node, state)
  } catch (e) {
    if (e instanceof Found) return e
    throw e
  }
}

// Find the outermost matching node before a given position.
export function findNodeBefore(node, pos, test, base, state) {
  test = makeTest(test)
  if (!base) base = exports.base
  let max
  ;(function c(node, st, override) {
    if (node.start &gt; pos) return
    let type = override || node.type
    if (node.end &lt;= pos &amp;&amp; (!max || max.node.end &lt; node.end) &amp;&amp; test(type, node))
      max = new Found(node, st)
    base[type](node, st, c)
  })(node, state)
  return max
}

// Used to create a custom walker. Will fill in all missing node
// type properties with the defaults.
export function make(funcs, base) {
  if (!base) base = exports.base
  let visitor = {}
  for (var type in base) visitor[type] = base[type]
  for (var type in funcs) visitor[type] = funcs[type]
  return visitor
}

function skipThrough(node, st, c) { c(node, st) }
function ignore(_node, _st, _c) {}

// Node walkers.

export const base = {}

base.Program = base.BlockStatement = (node, st, c) =&gt; {
  for (let i = 0; i &lt; node.body.length; ++i)
    c(node.body[i], st, &quot;Statement&quot;)
}
base.Statement = skipThrough
base.EmptyStatement = ignore
base.ExpressionStatement = base.ParenthesizedExpression =
  (node, st, c) =&gt; c(node.expression, st, &quot;Expression&quot;)
base.IfStatement = (node, st, c) =&gt; {
  c(node.test, st, &quot;Expression&quot;)
  c(node.consequent, st, &quot;Statement&quot;)
  if (node.alternate) c(node.alternate, st, &quot;Statement&quot;)
}
base.LabeledStatement = (node, st, c) =&gt; c(node.body, st, &quot;Statement&quot;)
base.BreakStatement = base.ContinueStatement = ignore
base.WithStatement = (node, st, c) =&gt; {
  c(node.object, st, &quot;Expression&quot;)
  c(node.body, st, &quot;Statement&quot;)
}
base.SwitchStatement = (node, st, c) =&gt; {
  c(node.discriminant, st, &quot;Expression&quot;)
  for (let i = 0; i &lt; node.cases.length; ++i) {
    let cs = node.cases[i]
    if (cs.test) c(cs.test, st, &quot;Expression&quot;)
    for (let j = 0; j &lt; cs.consequent.length; ++j)
      c(cs.consequent[j], st, &quot;Statement&quot;)
  }
}
base.ReturnStatement = base.YieldExpression = (node, st, c) =&gt; {
  if (node.argument) c(node.argument, st, &quot;Expression&quot;)
}
base.ThrowStatement = base.SpreadElement =
  (node, st, c) =&gt; c(node.argument, st, &quot;Expression&quot;)
base.TryStatement = (node, st, c) =&gt; {
  c(node.block, st, &quot;Statement&quot;)
  if (node.handler) {
    c(node.handler.param, st, &quot;Pattern&quot;)
    c(node.handler.body, st, &quot;ScopeBody&quot;)
  }
  if (node.finalizer) c(node.finalizer, st, &quot;Statement&quot;)
}
base.WhileStatement = base.DoWhileStatement = (node, st, c) =&gt; {
  c(node.test, st, &quot;Expression&quot;)
  c(node.body, st, &quot;Statement&quot;)
}
base.ForStatement = (node, st, c) =&gt; {
  if (node.init) c(node.init, st, &quot;ForInit&quot;)
  if (node.test) c(node.test, st, &quot;Expression&quot;)
  if (node.update) c(node.update, st, &quot;Expression&quot;)
  c(node.body, st, &quot;Statement&quot;)
}
base.ForInStatement = base.ForOfStatement = (node, st, c) =&gt; {
  c(node.left, st, &quot;ForInit&quot;)
  c(node.right, st, &quot;Expression&quot;)
  c(node.body, st, &quot;Statement&quot;)
}
base.ForInit = (node, st, c) =&gt; {
  if (node.type == &quot;VariableDeclaration&quot;) c(node, st)
  else c(node, st, &quot;Expression&quot;)
}
base.DebuggerStatement = ignore

base.FunctionDeclaration = (node, st, c) =&gt; c(node, st, &quot;Function&quot;)
base.VariableDeclaration = (node, st, c) =&gt; {
  for (let i = 0; i &lt; node.declarations.length; ++i)
    c(node.declarations[i], st)
}
base.VariableDeclarator = (node, st, c) =&gt; {
  c(node.id, st, &quot;Pattern&quot;)
  if (node.init) c(node.init, st, &quot;Expression&quot;)
}

base.Function = (node, st, c) =&gt; {
  if (node.id) c(node.id, st, &quot;Pattern&quot;)
  for (let i = 0; i &lt; node.params.length; i++)
    c(node.params[i], st, &quot;Pattern&quot;)
  c(node.body, st, node.expression ? &quot;ScopeExpression&quot; : &quot;ScopeBody&quot;)
}
// FIXME drop these node types in next major version
// (They are awkward, and in ES6 every block can be a scope.)
base.ScopeBody = (node, st, c) =&gt; c(node, st, &quot;Statement&quot;)
base.ScopeExpression = (node, st, c) =&gt; c(node, st, &quot;Expression&quot;)

base.Pattern = (node, st, c) =&gt; {
  if (node.type == &quot;Identifier&quot;)
    c(node, st, &quot;VariablePattern&quot;)
  else if (node.type == &quot;MemberExpression&quot;)
    c(node, st, &quot;MemberPattern&quot;)
  else
    c(node, st)
}
base.VariablePattern = ignore
base.MemberPattern = skipThrough
base.RestElement = (node, st, c) =&gt; c(node.argument, st, &quot;Pattern&quot;)
base.ArrayPattern =  (node, st, c) =&gt; {
  for (let i = 0; i &lt; node.elements.length; ++i) {
    let elt = node.elements[i]
    if (elt) c(elt, st, &quot;Pattern&quot;)
  }
}
base.ObjectPattern = (node, st, c) =&gt; {
  for (let i = 0; i &lt; node.properties.length; ++i)
    c(node.properties[i].value, st, &quot;Pattern&quot;)
}

base.Expression = skipThrough
base.ThisExpression = base.Super = base.MetaProperty = ignore
base.ArrayExpression = (node, st, c) =&gt; {
  for (let i = 0; i &lt; node.elements.length; ++i) {
    let elt = node.elements[i]
    if (elt) c(elt, st, &quot;Expression&quot;)
  }
}
base.ObjectExpression = (node, st, c) =&gt; {
  for (let i = 0; i &lt; node.properties.length; ++i)
    c(node.properties[i], st)
}
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration
base.SequenceExpression = base.TemplateLiteral = (node, st, c) =&gt; {
  for (let i = 0; i &lt; node.expressions.length; ++i)
    c(node.expressions[i], st, &quot;Expression&quot;)
}
base.UnaryExpression = base.UpdateExpression = (node, st, c) =&gt; {
  c(node.argument, st, &quot;Expression&quot;)
}
base.BinaryExpression = base.LogicalExpression = (node, st, c) =&gt; {
  c(node.left, st, &quot;Expression&quot;)
  c(node.right, st, &quot;Expression&quot;)
}
base.AssignmentExpression = base.AssignmentPattern = (node, st, c) =&gt; {
  c(node.left, st, &quot;Pattern&quot;)
  c(node.right, st, &quot;Expression&quot;)
}
base.ConditionalExpression = (node, st, c) =&gt; {
  c(node.test, st, &quot;Expression&quot;)
  c(node.consequent, st, &quot;Expression&quot;)
  c(node.alternate, st, &quot;Expression&quot;)
}
base.NewExpression = base.CallExpression = (node, st, c) =&gt; {
  c(node.callee, st, &quot;Expression&quot;)
  if (node.arguments) for (let i = 0; i &lt; node.arguments.length; ++i)
    c(node.arguments[i], st, &quot;Expression&quot;)
}
base.MemberExpression = (node, st, c) =&gt; {
  c(node.object, st, &quot;Expression&quot;)
  if (node.computed) c(node.property, st, &quot;Expression&quot;)
}
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = (node, st, c) =&gt; {
  if (node.declaration)
    c(node.declaration, st, node.type == &quot;ExportNamedDeclaration&quot; || node.declaration.id ? &quot;Statement&quot; : &quot;Expression&quot;)
  if (node.source) c(node.source, st, &quot;Expression&quot;)
}
base.ExportAllDeclaration = (node, st, c) =&gt; {
  c(node.source, st, &quot;Expression&quot;)
}
base.ImportDeclaration = (node, st, c) =&gt; {
  for (let i = 0; i &lt; node.specifiers.length; i++)
    c(node.specifiers[i], st)
  c(node.source, st, &quot;Expression&quot;)
}
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore

base.TaggedTemplateExpression = (node, st, c) =&gt; {
  c(node.tag, st, &quot;Expression&quot;)
  c(node.quasi, st)
}
base.ClassDeclaration = base.ClassExpression = (node, st, c) =&gt; c(node, st, &quot;Class&quot;)
base.Class = (node, st, c) =&gt; {
  if (node.id) c(node.id, st, &quot;Pattern&quot;)
  if (node.superClass) c(node.superClass, st, &quot;Expression&quot;)
  for (let i = 0; i &lt; node.body.body.length; i++)
    c(node.body.body[i], st)
}
base.MethodDefinition = base.Property = (node, st, c) =&gt; {
  if (node.computed) c(node.key, st, &quot;Expression&quot;)
  c(node.value, st, &quot;Expression&quot;)
}
base.ComprehensionExpression = (node, st, c) =&gt; {
  for (let i = 0; i &lt; node.blocks.length; i++)
    c(node.blocks[i].right, st, &quot;Expression&quot;)
  c(node.body, st, &quot;Expression&quot;)
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
