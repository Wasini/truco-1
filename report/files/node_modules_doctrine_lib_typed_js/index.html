<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/doctrine/lib/typed.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/doctrine/lib/typed.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">50.16</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1270</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">109.39</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.26</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * @fileoverview Type expression parser.
 * @author Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;
 * @author Dan Tao &lt;daniel.tao@gmail.com&gt;
 * @author Andrew Eisenberg &lt;andrew@eisenberg.as&gt;
 */

// &quot;typed&quot;, the Type Expression Parser for doctrine.

(function () {
    &#039;use strict&#039;;

    var Syntax,
        Token,
        source,
        length,
        index,
        previous,
        token,
        value,
        esutils,
        utility;

    esutils = require(&#039;esutils&#039;);
    utility = require(&#039;./utility&#039;);

    Syntax = {
        NullableLiteral: &#039;NullableLiteral&#039;,
        AllLiteral: &#039;AllLiteral&#039;,
        NullLiteral: &#039;NullLiteral&#039;,
        UndefinedLiteral: &#039;UndefinedLiteral&#039;,
        VoidLiteral: &#039;VoidLiteral&#039;,
        UnionType: &#039;UnionType&#039;,
        ArrayType: &#039;ArrayType&#039;,
        RecordType: &#039;RecordType&#039;,
        FieldType: &#039;FieldType&#039;,
        FunctionType: &#039;FunctionType&#039;,
        ParameterType: &#039;ParameterType&#039;,
        RestType: &#039;RestType&#039;,
        NonNullableType: &#039;NonNullableType&#039;,
        OptionalType: &#039;OptionalType&#039;,
        NullableType: &#039;NullableType&#039;,
        NameExpression: &#039;NameExpression&#039;,
        TypeApplication: &#039;TypeApplication&#039;,
        StringLiteralType: &#039;StringLiteralType&#039;,
        NumericLiteralType: &#039;NumericLiteralType&#039;
    };

    Token = {
        ILLEGAL: 0,    // ILLEGAL
        DOT_LT: 1,     // .&lt;
        REST: 2,       // ...
        LT: 3,         // &lt;
        GT: 4,         // &gt;
        LPAREN: 5,     // (
        RPAREN: 6,     // )
        LBRACE: 7,     // {
        RBRACE: 8,     // }
        LBRACK: 9,    // [
        RBRACK: 10,    // ]
        COMMA: 11,     // ,
        COLON: 12,     // :
        STAR: 13,      // *
        PIPE: 14,      // |
        QUESTION: 15,  // ?
        BANG: 16,      // !
        EQUAL: 17,     // =
        NAME: 18,      // name token
        STRING: 19,    // string
        NUMBER: 20,    // number
        EOF: 21
    };

    function isTypeName(ch) {
        return &#039;&gt;&lt;(){}[],:*|?!=&#039;.indexOf(String.fromCharCode(ch)) === -1 &amp;&amp; !esutils.code.isWhiteSpace(ch) &amp;&amp; !esutils.code.isLineTerminator(ch);
    }

    function Context(previous, index, token, value) {
        this._previous = previous;
        this._index = index;
        this._token = token;
        this._value = value;
    }

    Context.prototype.restore = function () {
        previous = this._previous;
        index = this._index;
        token = this._token;
        value = this._value;
    };

    Context.save = function () {
        return new Context(previous, index, token, value);
    };

    function advance() {
        var ch = source.charAt(index);
        index += 1;
        return ch;
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === &#039;u&#039;) ? 4 : 2;
        for (i = 0; i &lt; len; ++i) {
            if (index &lt; length &amp;&amp; esutils.code.isHexDigit(source.charCodeAt(index))) {
                ch = advance();
                code = code * 16 + &#039;0123456789abcdef&#039;.indexOf(ch.toLowerCase());
            } else {
                return &#039;&#039;;
            }
        }
        return String.fromCharCode(code);
    }

    function scanString() {
        var str = &#039;&#039;, quote, ch, code, unescaped, restore; //TODO review removal octal = false
        quote = source.charAt(index);
        ++index;

        while (index &lt; length) {
            ch = advance();

            if (ch === quote) {
                quote = &#039;&#039;;
                break;
            } else if (ch === &#039;\\&#039;) {
                ch = advance();
                if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case &#039;n&#039;:
                        str += &#039;\n&#039;;
                        break;
                    case &#039;r&#039;:
                        str += &#039;\r&#039;;
                        break;
                    case &#039;t&#039;:
                        str += &#039;\t&#039;;
                        break;
                    case &#039;u&#039;:
                    case &#039;x&#039;:
                        restore = index;
                        unescaped = scanHexEscape(ch);
                        if (unescaped) {
                            str += unescaped;
                        } else {
                            index = restore;
                            str += ch;
                        }
                        break;
                    case &#039;b&#039;:
                        str += &#039;\b&#039;;
                        break;
                    case &#039;f&#039;:
                        str += &#039;\f&#039;;
                        break;
                    case &#039;v&#039;:
                        str += &#039;\v&#039;;
                        break;

                    default:
                        if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {
                            code = &#039;01234567&#039;.indexOf(ch);

                            // \0 is not octal escape sequence
                            // Deprecating unused code. TODO review removal
                            //if (code !== 0) {
                            //    octal = true;
                            //}

                            if (index &lt; length &amp;&amp; esutils.code.isOctalDigit(source.charCodeAt(index))) {
                                //TODO Review Removal octal = true;
                                code = code * 8 + &#039;01234567&#039;.indexOf(advance());

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if (&#039;0123&#039;.indexOf(ch) &gt;= 0 &amp;&amp;
                                        index &lt; length &amp;&amp;
                                        esutils.code.isOctalDigit(source.charCodeAt(index))) {
                                    code = code * 8 + &#039;01234567&#039;.indexOf(advance());
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    if (ch ===  &#039;\r&#039; &amp;&amp; source.charCodeAt(index) === 0x0A  /* &#039;\n&#039; */) {
                        ++index;
                    }
                }
            } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== &#039;&#039;) {
            utility.throwError(&#039;unexpected quote&#039;);
        }

        value = str;
        return Token.STRING;
    }

    function scanNumber() {
        var number, ch;

        number = &#039;&#039;;
        ch = source.charCodeAt(index);

        if (ch !== 0x2E  /* &#039;.&#039; */) {
            number = advance();
            ch = source.charCodeAt(index);

            if (number === &#039;0&#039;) {
                if (ch === 0x78  /* &#039;x&#039; */ || ch === 0x58  /* &#039;X&#039; */) {
                    number += advance();
                    while (index &lt; length) {
                        ch = source.charCodeAt(index);
                        if (!esutils.code.isHexDigit(ch)) {
                            break;
                        }
                        number += advance();
                    }

                    if (number.length &lt;= 2) {
                        // only 0x
                        utility.throwError(&#039;unexpected token&#039;);
                    }

                    if (index &lt; length) {
                        ch = source.charCodeAt(index);
                        if (esutils.code.isIdentifierStartES5(ch)) {
                            utility.throwError(&#039;unexpected token&#039;);
                        }
                    }
                    value = parseInt(number, 16);
                    return Token.NUMBER;
                }

                if (esutils.code.isOctalDigit(ch)) {
                    number += advance();
                    while (index &lt; length) {
                        ch = source.charCodeAt(index);
                        if (!esutils.code.isOctalDigit(ch)) {
                            break;
                        }
                        number += advance();
                    }

                    if (index &lt; length) {
                        ch = source.charCodeAt(index);
                        if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {
                            utility.throwError(&#039;unexpected token&#039;);
                        }
                    }
                    value = parseInt(number, 8);
                    return Token.NUMBER;
                }

                if (esutils.code.isDecimalDigit(ch)) {
                    utility.throwError(&#039;unexpected token&#039;);
                }
            }

            while (index &lt; length) {
                ch = source.charCodeAt(index);
                if (!esutils.code.isDecimalDigit(ch)) {
                    break;
                }
                number += advance();
            }
        }

        if (ch === 0x2E  /* &#039;.&#039; */) {
            number += advance();
            while (index &lt; length) {
                ch = source.charCodeAt(index);
                if (!esutils.code.isDecimalDigit(ch)) {
                    break;
                }
                number += advance();
            }
        }

        if (ch === 0x65  /* &#039;e&#039; */ || ch === 0x45  /* &#039;E&#039; */) {
            number += advance();

            ch = source.charCodeAt(index);
            if (ch === 0x2B  /* &#039;+&#039; */ || ch === 0x2D  /* &#039;-&#039; */) {
                number += advance();
            }

            ch = source.charCodeAt(index);
            if (esutils.code.isDecimalDigit(ch)) {
                number += advance();
                while (index &lt; length) {
                    ch = source.charCodeAt(index);
                    if (!esutils.code.isDecimalDigit(ch)) {
                        break;
                    }
                    number += advance();
                }
            } else {
                utility.throwError(&#039;unexpected token&#039;);
            }
        }

        if (index &lt; length) {
            ch = source.charCodeAt(index);
            if (esutils.code.isIdentifierStartES5(ch)) {
                utility.throwError(&#039;unexpected token&#039;);
            }
        }

        value = parseFloat(number);
        return Token.NUMBER;
    }


    function scanTypeName() {
        var ch, ch2;

        value = advance();
        while (index &lt; length &amp;&amp; isTypeName(source.charCodeAt(index))) {
            ch = source.charCodeAt(index);
            if (ch === 0x2E  /* &#039;.&#039; */) {
                if ((index + 1) &gt;= length) {
                    return Token.ILLEGAL;
                }
                ch2 = source.charCodeAt(index + 1);
                if (ch2 === 0x3C  /* &#039;&lt;&#039; */) {
                    break;
                }
            }
            value += advance();
        }
        return Token.NAME;
    }

    function next() {
        var ch;

        previous = index;

        while (index &lt; length &amp;&amp; esutils.code.isWhiteSpace(source.charCodeAt(index))) {
            advance();
        }
        if (index &gt;= length) {
            token = Token.EOF;
            return token;
        }

        ch = source.charCodeAt(index);
        switch (ch) {
        case 0x27:  /* &#039;&#039;&#039; */
        case 0x22:  /* &#039;&quot;&#039; */
            token = scanString();
            return token;

        case 0x3A:  /* &#039;:&#039; */
            advance();
            token = Token.COLON;
            return token;

        case 0x2C:  /* &#039;,&#039; */
            advance();
            token = Token.COMMA;
            return token;

        case 0x28:  /* &#039;(&#039; */
            advance();
            token = Token.LPAREN;
            return token;

        case 0x29:  /* &#039;)&#039; */
            advance();
            token = Token.RPAREN;
            return token;

        case 0x5B:  /* &#039;[&#039; */
            advance();
            token = Token.LBRACK;
            return token;

        case 0x5D:  /* &#039;]&#039; */
            advance();
            token = Token.RBRACK;
            return token;

        case 0x7B:  /* &#039;{&#039; */
            advance();
            token = Token.LBRACE;
            return token;

        case 0x7D:  /* &#039;}&#039; */
            advance();
            token = Token.RBRACE;
            return token;

        case 0x2E:  /* &#039;.&#039; */
            if (index + 1 &lt; length) {
                ch = source.charCodeAt(index + 1);
                if (ch === 0x3C  /* &#039;&lt;&#039; */) {
                    advance();  // &#039;.&#039;
                    advance();  // &#039;&lt;&#039;
                    token = Token.DOT_LT;
                    return token;
                }

                if (ch === 0x2E  /* &#039;.&#039; */ &amp;&amp; index + 2 &lt; length &amp;&amp; source.charCodeAt(index + 2) === 0x2E  /* &#039;.&#039; */) {
                    advance();  // &#039;.&#039;
                    advance();  // &#039;.&#039;
                    advance();  // &#039;.&#039;
                    token = Token.REST;
                    return token;
                }

                if (esutils.code.isDecimalDigit(ch)) {
                    token = scanNumber();
                    return token;
                }
            }
            token = Token.ILLEGAL;
            return token;

        case 0x3C:  /* &#039;&lt;&#039; */
            advance();
            token = Token.LT;
            return token;

        case 0x3E:  /* &#039;&gt;&#039; */
            advance();
            token = Token.GT;
            return token;

        case 0x2A:  /* &#039;*&#039; */
            advance();
            token = Token.STAR;
            return token;

        case 0x7C:  /* &#039;|&#039; */
            advance();
            token = Token.PIPE;
            return token;

        case 0x3F:  /* &#039;?&#039; */
            advance();
            token = Token.QUESTION;
            return token;

        case 0x21:  /* &#039;!&#039; */
            advance();
            token = Token.BANG;
            return token;

        case 0x3D:  /* &#039;=&#039; */
            advance();
            token = Token.EQUAL;
            return token;

        case 0x2D: /* &#039;-&#039; */
            token = scanNumber();
            return token;

        default:
            if (esutils.code.isDecimalDigit(ch)) {
                token = scanNumber();
                return token;
            }

            // type string permits following case,
            //
            // namespace.module.MyClass
            //
            // this reduced 1 token TK_NAME
            utility.assert(isTypeName(ch));
            token = scanTypeName();
            return token;
        }
    }

    function consume(target, text) {
        utility.assert(token === target, text || &#039;consumed token not matched&#039;);
        next();
    }

    function expect(target, message) {
        if (token !== target) {
            utility.throwError(message || &#039;unexpected token&#039;);
        }
        next();
    }

    // UnionType := &#039;(&#039; TypeUnionList &#039;)&#039;
    //
    // TypeUnionList :=
    //     &lt;&lt;empty&gt;&gt;
    //   | NonemptyTypeUnionList
    //
    // NonemptyTypeUnionList :=
    //     TypeExpression
    //   | TypeExpression &#039;|&#039; NonemptyTypeUnionList
    function parseUnionType() {
        var elements;
        consume(Token.LPAREN, &#039;UnionType should start with (&#039;);
        elements = [];
        if (token !== Token.RPAREN) {
            while (true) {
                elements.push(parseTypeExpression());
                if (token === Token.RPAREN) {
                    break;
                }
                expect(Token.PIPE);
            }
        }
        consume(Token.RPAREN, &#039;UnionType should end with )&#039;);
        return {
            type: Syntax.UnionType,
            elements: elements
        };
    }

    // ArrayType := &#039;[&#039; ElementTypeList &#039;]&#039;
    //
    // ElementTypeList :=
    //     &lt;&lt;empty&gt;&gt;
    //  | TypeExpression
    //  | &#039;...&#039; TypeExpression
    //  | TypeExpression &#039;,&#039; ElementTypeList
    function parseArrayType() {
        var elements;
        consume(Token.LBRACK, &#039;ArrayType should start with [&#039;);
        elements = [];
        while (token !== Token.RBRACK) {
            if (token === Token.REST) {
                consume(Token.REST);
                elements.push({
                    type: Syntax.RestType,
                    expression: parseTypeExpression()
                });
                break;
            } else {
                elements.push(parseTypeExpression());
            }
            if (token !== Token.RBRACK) {
                expect(Token.COMMA);
            }
        }
        expect(Token.RBRACK);
        return {
            type: Syntax.ArrayType,
            elements: elements
        };
    }

    function parseFieldName() {
        var v = value;
        if (token === Token.NAME || token === Token.STRING) {
            next();
            return v;
        }

        if (token === Token.NUMBER) {
            consume(Token.NUMBER);
            return String(v);
        }

        utility.throwError(&#039;unexpected token&#039;);
    }

    // FieldType :=
    //     FieldName
    //   | FieldName &#039;:&#039; TypeExpression
    //
    // FieldName :=
    //     NameExpression
    //   | StringLiteral
    //   | NumberLiteral
    //   | ReservedIdentifier
    function parseFieldType() {
        var key;

        key = parseFieldName();
        if (token === Token.COLON) {
            consume(Token.COLON);
            return {
                type: Syntax.FieldType,
                key: key,
                value: parseTypeExpression()
            };
        }
        return {
            type: Syntax.FieldType,
            key: key,
            value: null
        };
    }

    // RecordType := &#039;{&#039; FieldTypeList &#039;}&#039;
    //
    // FieldTypeList :=
    //     &lt;&lt;empty&gt;&gt;
    //   | FieldType
    //   | FieldType &#039;,&#039; FieldTypeList
    function parseRecordType() {
        var fields;

        consume(Token.LBRACE, &#039;RecordType should start with {&#039;);
        fields = [];
        if (token === Token.COMMA) {
            consume(Token.COMMA);
        } else {
            while (token !== Token.RBRACE) {
                fields.push(parseFieldType());
                if (token !== Token.RBRACE) {
                    expect(Token.COMMA);
                }
            }
        }
        expect(Token.RBRACE);
        return {
            type: Syntax.RecordType,
            fields: fields
        };
    }

    // NameExpression :=
    //    Identifier
    //  | TagIdentifier &#039;:&#039; Identifier
    //
    // Tag identifier is one of &quot;module&quot;, &quot;external&quot; or &quot;event&quot;
    // Identifier is the same as Token.NAME, including any dots, something like
    // namespace.module.MyClass
    function parseNameExpression() {
        var name = value;
        expect(Token.NAME);

        if (token === Token.COLON &amp;&amp; (
                name === &#039;module&#039; ||
                name === &#039;external&#039; ||
                name === &#039;event&#039;)) {
            consume(Token.COLON);
            name += &#039;:&#039; + value;
            expect(Token.NAME);
        }

        return {
            type: Syntax.NameExpression,
            name: name
        };
    }

    // TypeExpressionList :=
    //     TopLevelTypeExpression
    //   | TopLevelTypeExpression &#039;,&#039; TypeExpressionList
    function parseTypeExpressionList() {
        var elements = [];

        elements.push(parseTop());
        while (token === Token.COMMA) {
            consume(Token.COMMA);
            elements.push(parseTop());
        }
        return elements;
    }

    // TypeName :=
    //     NameExpression
    //   | NameExpression TypeApplication
    //
    // TypeApplication :=
    //     &#039;.&lt;&#039; TypeExpressionList &#039;&gt;&#039;
    //   | &#039;&lt;&#039; TypeExpressionList &#039;&gt;&#039;   // this is extension of doctrine
    function parseTypeName() {
        var expr, applications;

        expr = parseNameExpression();
        if (token === Token.DOT_LT || token === Token.LT) {
            next();
            applications = parseTypeExpressionList();
            expect(Token.GT);
            return {
                type: Syntax.TypeApplication,
                expression: expr,
                applications: applications
            };
        }
        return expr;
    }

    // ResultType :=
    //     &lt;&lt;empty&gt;&gt;
    //   | &#039;:&#039; void
    //   | &#039;:&#039; TypeExpression
    //
    // BNF is above
    // but, we remove &lt;&lt;empty&gt;&gt; pattern, so token is always TypeToken::COLON
    function parseResultType() {
        consume(Token.COLON, &#039;ResultType should start with :&#039;);
        if (token === Token.NAME &amp;&amp; value === &#039;void&#039;) {
            consume(Token.NAME);
            return {
                type: Syntax.VoidLiteral
            };
        }
        return parseTypeExpression();
    }

    // ParametersType :=
    //     RestParameterType
    //   | NonRestParametersType
    //   | NonRestParametersType &#039;,&#039; RestParameterType
    //
    // RestParameterType :=
    //     &#039;...&#039;
    //     &#039;...&#039; Identifier
    //
    // NonRestParametersType :=
    //     ParameterType &#039;,&#039; NonRestParametersType
    //   | ParameterType
    //   | OptionalParametersType
    //
    // OptionalParametersType :=
    //     OptionalParameterType
    //   | OptionalParameterType, OptionalParametersType
    //
    // OptionalParameterType := ParameterType=
    //
    // ParameterType := TypeExpression | Identifier &#039;:&#039; TypeExpression
    //
    // Identifier is &quot;new&quot; or &quot;this&quot;
    function parseParametersType() {
        var params = [], optionalSequence = false, expr, rest = false;

        while (token !== Token.RPAREN) {
            if (token === Token.REST) {
                // RestParameterType
                consume(Token.REST);
                rest = true;
            }

            expr = parseTypeExpression();
            if (expr.type === Syntax.NameExpression &amp;&amp; token === Token.COLON) {
                // Identifier &#039;:&#039; TypeExpression
                consume(Token.COLON);
                expr = {
                    type: Syntax.ParameterType,
                    name: expr.name,
                    expression: parseTypeExpression()
                };
            }
            if (token === Token.EQUAL) {
                consume(Token.EQUAL);
                expr = {
                    type: Syntax.OptionalType,
                    expression: expr
                };
                optionalSequence = true;
            } else {
                if (optionalSequence) {
                    utility.throwError(&#039;unexpected token&#039;);
                }
            }
            if (rest) {
                expr = {
                    type: Syntax.RestType,
                    expression: expr
                };
            }
            params.push(expr);
            if (token !== Token.RPAREN) {
                expect(Token.COMMA);
            }
        }
        return params;
    }

    // FunctionType := &#039;function&#039; FunctionSignatureType
    //
    // FunctionSignatureType :=
    //   | TypeParameters &#039;(&#039; &#039;)&#039; ResultType
    //   | TypeParameters &#039;(&#039; ParametersType &#039;)&#039; ResultType
    //   | TypeParameters &#039;(&#039; &#039;this&#039; &#039;:&#039; TypeName &#039;)&#039; ResultType
    //   | TypeParameters &#039;(&#039; &#039;this&#039; &#039;:&#039; TypeName &#039;,&#039; ParametersType &#039;)&#039; ResultType
    function parseFunctionType() {
        var isNew, thisBinding, params, result, fnType;
        utility.assert(token === Token.NAME &amp;&amp; value === &#039;function&#039;, &#039;FunctionType should start with \&#039;function\&#039;&#039;);
        consume(Token.NAME);

        // Google Closure Compiler is not implementing TypeParameters.
        // So we do not. if we don&#039;t get &#039;(&#039;, we see it as error.
        expect(Token.LPAREN);

        isNew = false;
        params = [];
        thisBinding = null;
        if (token !== Token.RPAREN) {
            // ParametersType or &#039;this&#039;
            if (token === Token.NAME &amp;&amp;
                    (value === &#039;this&#039; || value === &#039;new&#039;)) {
                // &#039;this&#039; or &#039;new&#039;
                // &#039;new&#039; is Closure Compiler extension
                isNew = value === &#039;new&#039;;
                consume(Token.NAME);
                expect(Token.COLON);
                thisBinding = parseTypeName();
                if (token === Token.COMMA) {
                    consume(Token.COMMA);
                    params = parseParametersType();
                }
            } else {
                params = parseParametersType();
            }
        }

        expect(Token.RPAREN);

        result = null;
        if (token === Token.COLON) {
            result = parseResultType();
        }

        fnType = {
            type: Syntax.FunctionType,
            params: params,
            result: result
        };
        if (thisBinding) {
            // avoid adding null &#039;new&#039; and &#039;this&#039; properties
            fnType[&#039;this&#039;] = thisBinding;
            if (isNew) {
                fnType[&#039;new&#039;] = true;
            }
        }
        return fnType;
    }

    // BasicTypeExpression :=
    //     &#039;*&#039;
    //   | &#039;null&#039;
    //   | &#039;undefined&#039;
    //   | TypeName
    //   | FunctionType
    //   | UnionType
    //   | RecordType
    //   | ArrayType
    function parseBasicTypeExpression() {
        var context;
        switch (token) {
        case Token.STAR:
            consume(Token.STAR);
            return {
                type: Syntax.AllLiteral
            };

        case Token.LPAREN:
            return parseUnionType();

        case Token.LBRACK:
            return parseArrayType();

        case Token.LBRACE:
            return parseRecordType();

        case Token.NAME:
            if (value === &#039;null&#039;) {
                consume(Token.NAME);
                return {
                    type: Syntax.NullLiteral
                };
            }

            if (value === &#039;undefined&#039;) {
                consume(Token.NAME);
                return {
                    type: Syntax.UndefinedLiteral
                };
            }

            context = Context.save();
            if (value === &#039;function&#039;) {
                try {
                    return parseFunctionType();
                } catch (e) {
                    context.restore();
                }
            }

            return parseTypeName();

        case Token.STRING:
            next();
            return {
                type: Syntax.StringLiteralType,
                value: value
            };

        case Token.NUMBER:
            next();
            return {
                type: Syntax.NumericLiteralType,
                value: value
            };

        default:
            utility.throwError(&#039;unexpected token&#039;);
        }
    }

    // TypeExpression :=
    //     BasicTypeExpression
    //   | &#039;?&#039; BasicTypeExpression
    //   | &#039;!&#039; BasicTypeExpression
    //   | BasicTypeExpression &#039;?&#039;
    //   | BasicTypeExpression &#039;!&#039;
    //   | &#039;?&#039;
    //   | BasicTypeExpression &#039;[]&#039;
    function parseTypeExpression() {
        var expr;

        if (token === Token.QUESTION) {
            consume(Token.QUESTION);
            if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE ||
                    token === Token.RPAREN || token === Token.PIPE || token === Token.EOF ||
                    token === Token.RBRACK || token === Token.GT) {
                return {
                    type: Syntax.NullableLiteral
                };
            }
            return {
                type: Syntax.NullableType,
                expression: parseBasicTypeExpression(),
                prefix: true
            };
        }

        if (token === Token.BANG) {
            consume(Token.BANG);
            return {
                type: Syntax.NonNullableType,
                expression: parseBasicTypeExpression(),
                prefix: true
            };
        }

        expr = parseBasicTypeExpression();
        if (token === Token.BANG) {
            consume(Token.BANG);
            return {
                type: Syntax.NonNullableType,
                expression: expr,
                prefix: false
            };
        }

        if (token === Token.QUESTION) {
            consume(Token.QUESTION);
            return {
                type: Syntax.NullableType,
                expression: expr,
                prefix: false
            };
        }

        if (token === Token.LBRACK) {
            consume(Token.LBRACK);
            expect(Token.RBRACK, &#039;expected an array-style type declaration (&#039; + value + &#039;[])&#039;);
            return {
                type: Syntax.TypeApplication,
                expression: {
                    type: Syntax.NameExpression,
                    name: &#039;Array&#039;
                },
                applications: [expr]
            };
        }

        return expr;
    }

    // TopLevelTypeExpression :=
    //      TypeExpression
    //    | TypeUnionList
    //
    // This rule is Google Closure Compiler extension, not ES4
    // like,
    //   { number | string }
    // If strict to ES4, we should write it as
    //   { (number|string) }
    function parseTop() {
        var expr, elements;

        expr = parseTypeExpression();
        if (token !== Token.PIPE) {
            return expr;
        }

        elements = [expr];
        consume(Token.PIPE);
        while (true) {
            elements.push(parseTypeExpression());
            if (token !== Token.PIPE) {
                break;
            }
            consume(Token.PIPE);
        }

        return {
            type: Syntax.UnionType,
            elements: elements
        };
    }

    function parseTopParamType() {
        var expr;

        if (token === Token.REST) {
            consume(Token.REST);
            return {
                type: Syntax.RestType,
                expression: parseTop()
            };
        }

        expr = parseTop();
        if (token === Token.EQUAL) {
            consume(Token.EQUAL);
            return {
                type: Syntax.OptionalType,
                expression: expr
            };
        }

        return expr;
    }

    function parseType(src, opt) {
        var expr;

        source = src;
        length = source.length;
        index = 0;
        previous = 0;

        next();
        expr = parseTop();

        if (opt &amp;&amp; opt.midstream) {
            return {
                expression: expr,
                index: previous
            };
        }

        if (token !== Token.EOF) {
            utility.throwError(&#039;not reach to EOF&#039;);
        }

        return expr;
    }

    function parseParamType(src, opt) {
        var expr;

        source = src;
        length = source.length;
        index = 0;
        previous = 0;

        next();
        expr = parseTopParamType();

        if (opt &amp;&amp; opt.midstream) {
            return {
                expression: expr,
                index: previous
            };
        }

        if (token !== Token.EOF) {
            utility.throwError(&#039;not reach to EOF&#039;);
        }

        return expr;
    }

    function stringifyImpl(node, compact, topLevel) {
        var result, i, iz;

        switch (node.type) {
        case Syntax.NullableLiteral:
            result = &#039;?&#039;;
            break;

        case Syntax.AllLiteral:
            result = &#039;*&#039;;
            break;

        case Syntax.NullLiteral:
            result = &#039;null&#039;;
            break;

        case Syntax.UndefinedLiteral:
            result = &#039;undefined&#039;;
            break;

        case Syntax.VoidLiteral:
            result = &#039;void&#039;;
            break;

        case Syntax.UnionType:
            if (!topLevel) {
                result = &#039;(&#039;;
            } else {
                result = &#039;&#039;;
            }

            for (i = 0, iz = node.elements.length; i &lt; iz; ++i) {
                result += stringifyImpl(node.elements[i], compact);
                if ((i + 1) !== iz) {
                    result += &#039;|&#039;;
                }
            }

            if (!topLevel) {
                result += &#039;)&#039;;
            }
            break;

        case Syntax.ArrayType:
            result = &#039;[&#039;;
            for (i = 0, iz = node.elements.length; i &lt; iz; ++i) {
                result += stringifyImpl(node.elements[i], compact);
                if ((i + 1) !== iz) {
                    result += compact ? &#039;,&#039; : &#039;, &#039;;
                }
            }
            result += &#039;]&#039;;
            break;

        case Syntax.RecordType:
            result = &#039;{&#039;;
            for (i = 0, iz = node.fields.length; i &lt; iz; ++i) {
                result += stringifyImpl(node.fields[i], compact);
                if ((i + 1) !== iz) {
                    result += compact ? &#039;,&#039; : &#039;, &#039;;
                }
            }
            result += &#039;}&#039;;
            break;

        case Syntax.FieldType:
            if (node.value) {
                result = node.key + (compact ? &#039;:&#039; : &#039;: &#039;) + stringifyImpl(node.value, compact);
            } else {
                result = node.key;
            }
            break;

        case Syntax.FunctionType:
            result = compact ? &#039;function(&#039; : &#039;function (&#039;;

            if (node[&#039;this&#039;]) {
                if (node[&#039;new&#039;]) {
                    result += (compact ? &#039;new:&#039; : &#039;new: &#039;);
                } else {
                    result += (compact ? &#039;this:&#039; : &#039;this: &#039;);
                }

                result += stringifyImpl(node[&#039;this&#039;], compact);

                if (node.params.length !== 0) {
                    result += compact ? &#039;,&#039; : &#039;, &#039;;
                }
            }

            for (i = 0, iz = node.params.length; i &lt; iz; ++i) {
                result += stringifyImpl(node.params[i], compact);
                if ((i + 1) !== iz) {
                    result += compact ? &#039;,&#039; : &#039;, &#039;;
                }
            }

            result += &#039;)&#039;;

            if (node.result) {
                result += (compact ? &#039;:&#039; : &#039;: &#039;) + stringifyImpl(node.result, compact);
            }
            break;

        case Syntax.ParameterType:
            result = node.name + (compact ? &#039;:&#039; : &#039;: &#039;) + stringifyImpl(node.expression, compact);
            break;

        case Syntax.RestType:
            result = &#039;...&#039;;
            if (node.expression) {
                result += stringifyImpl(node.expression, compact);
            }
            break;

        case Syntax.NonNullableType:
            if (node.prefix) {
                result = &#039;!&#039; + stringifyImpl(node.expression, compact);
            } else {
                result = stringifyImpl(node.expression, compact) + &#039;!&#039;;
            }
            break;

        case Syntax.OptionalType:
            result = stringifyImpl(node.expression, compact) + &#039;=&#039;;
            break;

        case Syntax.NullableType:
            if (node.prefix) {
                result = &#039;?&#039; + stringifyImpl(node.expression, compact);
            } else {
                result = stringifyImpl(node.expression, compact) + &#039;?&#039;;
            }
            break;

        case Syntax.NameExpression:
            result = node.name;
            break;

        case Syntax.TypeApplication:
            result = stringifyImpl(node.expression, compact) + &#039;.&lt;&#039;;
            for (i = 0, iz = node.applications.length; i &lt; iz; ++i) {
                result += stringifyImpl(node.applications[i], compact);
                if ((i + 1) !== iz) {
                    result += compact ? &#039;,&#039; : &#039;, &#039;;
                }
            }
            result += &#039;&gt;&#039;;
            break;

        case Syntax.StringLiteralType:
            result = &#039;&quot;&#039; + node.value + &#039;&quot;&#039;;
            break;

        case Syntax.NumericLiteralType:
            result = String(node.value);
            break;

        default:
            utility.throwError(&#039;Unknown type &#039; + node.type);
        }

        return result;
    }

    function stringify(node, options) {
        if (options == null) {
            options = {};
        }
        return stringifyImpl(node, options.compact, options.topLevel);
    }

    exports.parseType = parseType;
    exports.parseParamType = parseParamType;
    exports.stringify = stringify;
    exports.Syntax = Syntax;
}());
/* vim: set sw=4 ts=4 et tw=80 : */</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
