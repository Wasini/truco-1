<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/acorn-jsx/node_modules/acorn/src/tokentype.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/acorn-jsx/node_modules/acorn/src/tokentype.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.82</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">147</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">15.07</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.74</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

export class TokenType {
  constructor(label, conf = {}) {
    this.label = label
    this.keyword = conf.keyword
    this.beforeExpr = !!conf.beforeExpr
    this.startsExpr = !!conf.startsExpr
    this.isLoop = !!conf.isLoop
    this.isAssign = !!conf.isAssign
    this.prefix = !!conf.prefix
    this.postfix = !!conf.postfix
    this.binop = conf.binop || null
    this.updateContext = null
  }
}

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
const beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true}

// Map keyword names to token types.

export const keywords = {}

// Succinct definitions of keyword token types
function kw(name, options = {}) {
  options.keyword = name
  return keywords[name] = new TokenType(name, options)
}

export const types = {
  num: new TokenType(&quot;num&quot;, startsExpr),
  regexp: new TokenType(&quot;regexp&quot;, startsExpr),
  string: new TokenType(&quot;string&quot;, startsExpr),
  name: new TokenType(&quot;name&quot;, startsExpr),
  eof: new TokenType(&quot;eof&quot;),

  // Punctuation token types.
  bracketL: new TokenType(&quot;[&quot;, {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType(&quot;]&quot;),
  braceL: new TokenType(&quot;{&quot;, {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType(&quot;}&quot;),
  parenL: new TokenType(&quot;(&quot;, {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(&quot;)&quot;),
  comma: new TokenType(&quot;,&quot;, beforeExpr),
  semi: new TokenType(&quot;;&quot;, beforeExpr),
  colon: new TokenType(&quot;:&quot;, beforeExpr),
  dot: new TokenType(&quot;.&quot;),
  question: new TokenType(&quot;?&quot;, beforeExpr),
  arrow: new TokenType(&quot;=&gt;&quot;, beforeExpr),
  template: new TokenType(&quot;template&quot;),
  ellipsis: new TokenType(&quot;...&quot;, beforeExpr),
  backQuote: new TokenType(&quot;`&quot;, startsExpr),
  dollarBraceL: new TokenType(&quot;${&quot;, {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType(&quot;=&quot;, {beforeExpr: true, isAssign: true}),
  assign: new TokenType(&quot;_=&quot;, {beforeExpr: true, isAssign: true}),
  incDec: new TokenType(&quot;++/--&quot;, {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType(&quot;prefix&quot;, {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop(&quot;||&quot;, 1),
  logicalAND: binop(&quot;&amp;&amp;&quot;, 2),
  bitwiseOR: binop(&quot;|&quot;, 3),
  bitwiseXOR: binop(&quot;^&quot;, 4),
  bitwiseAND: binop(&quot;&amp;&quot;, 5),
  equality: binop(&quot;==/!=&quot;, 6),
  relational: binop(&quot;&lt;/&gt;&quot;, 7),
  bitShift: binop(&quot;&lt;&lt;/&gt;&gt;&quot;, 8),
  plusMin: new TokenType(&quot;+/-&quot;, {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop(&quot;%&quot;, 10),
  star: binop(&quot;*&quot;, 10),
  slash: binop(&quot;/&quot;, 10),
  starstar: new TokenType(&quot;**&quot;, {beforeExpr: true}),

  // Keyword token types.
  _break: kw(&quot;break&quot;),
  _case: kw(&quot;case&quot;, beforeExpr),
  _catch: kw(&quot;catch&quot;),
  _continue: kw(&quot;continue&quot;),
  _debugger: kw(&quot;debugger&quot;),
  _default: kw(&quot;default&quot;, beforeExpr),
  _do: kw(&quot;do&quot;, {isLoop: true, beforeExpr: true}),
  _else: kw(&quot;else&quot;, beforeExpr),
  _finally: kw(&quot;finally&quot;),
  _for: kw(&quot;for&quot;, {isLoop: true}),
  _function: kw(&quot;function&quot;, startsExpr),
  _if: kw(&quot;if&quot;),
  _return: kw(&quot;return&quot;, beforeExpr),
  _switch: kw(&quot;switch&quot;),
  _throw: kw(&quot;throw&quot;, beforeExpr),
  _try: kw(&quot;try&quot;),
  _var: kw(&quot;var&quot;),
  _const: kw(&quot;const&quot;),
  _while: kw(&quot;while&quot;, {isLoop: true}),
  _with: kw(&quot;with&quot;),
  _new: kw(&quot;new&quot;, {beforeExpr: true, startsExpr: true}),
  _this: kw(&quot;this&quot;, startsExpr),
  _super: kw(&quot;super&quot;, startsExpr),
  _class: kw(&quot;class&quot;),
  _extends: kw(&quot;extends&quot;, beforeExpr),
  _export: kw(&quot;export&quot;),
  _import: kw(&quot;import&quot;),
  _null: kw(&quot;null&quot;, startsExpr),
  _true: kw(&quot;true&quot;, startsExpr),
  _false: kw(&quot;false&quot;, startsExpr),
  _in: kw(&quot;in&quot;, {beforeExpr: true, binop: 7}),
  _instanceof: kw(&quot;instanceof&quot;, {beforeExpr: true, binop: 7}),
  _typeof: kw(&quot;typeof&quot;, {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw(&quot;void&quot;, {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw(&quot;delete&quot;, {beforeExpr: true, prefix: true, startsExpr: true})
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
