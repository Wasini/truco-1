<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/chai/chai.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/chai/chai.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">68.13</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">6142</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">161.94</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">34.65</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function(f){if(typeof exports===&quot;object&quot;&amp;&amp;typeof module!==&quot;undefined&quot;){module.exports=f()}else if(typeof define===&quot;function&quot;&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==&quot;undefined&quot;){g=window}else if(typeof global!==&quot;undefined&quot;){g=global}else if(typeof self!==&quot;undefined&quot;){g=self}else{g=this}g.chai = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(&quot;Cannot find module &#039;&quot;+o+&quot;&#039;&quot;);throw f.code=&quot;MODULE_NOT_FOUND&quot;,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require(&#039;./lib/chai&#039;);

},{&quot;./lib/chai&quot;:2}],2:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = &#039;3.5.0&#039;;

/*!
 * Assertion Error
 */

exports.AssertionError = require(&#039;assertion-error&#039;);

/*!
 * Utils for plugins (not exported)
 */

var util = require(&#039;./chai/utils&#039;);

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Utility Functions
 */

exports.util = util;

/*!
 * Configuration
 */

var config = require(&#039;./chai/config&#039;);
exports.config = config;

/*!
 * Primary `Assertion` prototype
 */

var assertion = require(&#039;./chai/assertion&#039;);
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = require(&#039;./chai/core/assertions&#039;);
exports.use(core);

/*!
 * Expect interface
 */

var expect = require(&#039;./chai/interface/expect&#039;);
exports.use(expect);

/*!
 * Should interface
 */

var should = require(&#039;./chai/interface/should&#039;);
exports.use(should);

/*!
 * Assert interface
 */

var assert = require(&#039;./chai/interface/assert&#039;);
exports.use(assert);

},{&quot;./chai/assertion&quot;:3,&quot;./chai/config&quot;:4,&quot;./chai/core/assertions&quot;:5,&quot;./chai/interface/assert&quot;:6,&quot;./chai/interface/expect&quot;:7,&quot;./chai/interface/should&quot;:8,&quot;./chai/utils&quot;:22,&quot;assertion-error&quot;:30}],3:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

var config = require(&#039;./config&#039;);

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, &#039;ssfi&#039;, stack || arguments.callee);
    flag(this, &#039;object&#039;, obj);
    flag(this, &#039;message&#039;, msg);
  }

  Object.defineProperty(Assertion, &#039;includeStack&#039;, {
    get: function() {
      console.warn(&#039;Assertion.includeStack is deprecated, use chai.config.includeStack instead.&#039;);
      return config.includeStack;
    },
    set: function(value) {
      console.warn(&#039;Assertion.includeStack is deprecated, use chai.config.includeStack instead.&#039;);
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, &#039;showDiff&#039;, {
    get: function() {
      console.warn(&#039;Assertion.showDiff is deprecated, use chai.config.showDiff instead.&#039;);
      return config.showDiff;
    },
    set: function(value) {
      console.warn(&#039;Assertion.showDiff is deprecated, use chai.config.showDiff instead.&#039;);
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn&#039;t pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, &#039;ssfi&#039;));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, &#039;_obj&#039;,
    { get: function () {
        return flag(this, &#039;object&#039;);
      }
    , set: function (val) {
        flag(this, &#039;object&#039;, val);
      }
  });
};

},{&quot;./config&quot;:4}],4:[function(require,module,exports){
module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

   includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40

};

},{}],5:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */

  [ &#039;to&#039;, &#039;be&#039;, &#039;been&#039;
  , &#039;is&#039;, &#039;and&#039;, &#039;has&#039;, &#039;have&#039;
  , &#039;with&#039;, &#039;that&#039;, &#039;which&#039;, &#039;at&#039;
  , &#039;of&#039;, &#039;same&#039; ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal(&#039;bar&#039;);
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: &#039;baz&#039; }).to.have.property(&#039;foo&#039;)
   *       .and.not.equal(&#039;bar&#039;);
   *
   * @name not
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;not&#039;, function () {
    flag(this, &#039;negate&#039;, true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: &#039;baz&#039; });
   *     expect({ foo: { bar: { baz: &#039;quux&#039; } } })
   *       .to.have.deep.property(&#039;foo.bar.baz&#039;, &#039;quux&#039;);
   *
   * `.deep.property` special characters can be escaped
   * by adding two slashes before the `.` or `[]`.
   *
   *     var deepCss = { &#039;.link&#039;: { &#039;[target]&#039;: 42 }};
   *     expect(deepCss).to.have.deep.property(&#039;\\.link.\\[target\\]&#039;, 42);
   *
   * @name deep
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;deep&#039;, function () {
    flag(this, &#039;deep&#039;, true);
  });

  /**
   * ### .any
   *
   * Sets the `any` flag, (opposite of the `all` flag)
   * later used in the `keys` assertion.
   *
   *     expect(foo).to.have.any.keys(&#039;bar&#039;, &#039;baz&#039;);
   *
   * @name any
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;any&#039;, function () {
    flag(this, &#039;any&#039;, true);
    flag(this, &#039;all&#039;, false)
  });


  /**
   * ### .all
   *
   * Sets the `all` flag (opposite of the `any` flag)
   * later used by the `keys` assertion.
   *
   *     expect(foo).to.have.all.keys(&#039;bar&#039;, &#039;baz&#039;);
   *
   * @name all
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;all&#039;, function () {
    flag(this, &#039;all&#039;, true);
    flag(this, &#039;any&#039;, false);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value&#039;s
   * type.
   *
   *     // typeof
   *     expect(&#039;test&#039;).to.be.a(&#039;string&#039;);
   *     expect({ foo: &#039;bar&#039; }).to.be.an(&#039;object&#039;);
   *     expect(null).to.be.a(&#039;null&#039;);
   *     expect(undefined).to.be.an(&#039;undefined&#039;);
   *     expect(new Error).to.be.an(&#039;error&#039;);
   *     expect(new Promise).to.be.a(&#039;promise&#039;);
   *     expect(new Float32Array()).to.be.a(&#039;float32array&#039;);
   *     expect(Symbol()).to.be.a(&#039;symbol&#039;);
   *
   *     // es6 overrides
   *     expect({[Symbol.toStringTag]:()=&gt;&#039;foo&#039;}).to.be.a(&#039;foo&#039;);
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    type = type.toLowerCase();
    var obj = flag(this, &#039;object&#039;)
      , article = ~[ &#039;a&#039;, &#039;e&#039;, &#039;i&#039;, &#039;o&#039;, &#039;u&#039; ].indexOf(type.charAt(0)) ? &#039;an &#039; : &#039;a &#039;;

    this.assert(
        type === _.type(obj)
      , &#039;expected #{this} to be &#039; + article + type
      , &#039;expected #{this} not to be &#039; + article + type
    );
  }

  Assertion.addChainableMethod(&#039;an&#039;, an);
  Assertion.addChainableMethod(&#039;a&#039;, an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contains` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect(&#039;foobar&#039;).to.contain(&#039;foo&#039;);
   *     expect({ foo: &#039;bar&#039;, hello: &#039;universe&#039; }).to.include.keys(&#039;foo&#039;);
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, &#039;contains&#039;, true);
  }

  function include (val, msg) {
    _.expectTypes(this, [&#039;array&#039;, &#039;object&#039;, &#039;string&#039;]);

    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    var expected = false;

    if (_.type(obj) === &#039;array&#039; &amp;&amp; _.type(val) === &#039;object&#039;) {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === &#039;object&#039;) {
      if (!flag(this, &#039;negate&#039;)) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {};
      for (var k in val) subset[k] = obj[k];
      expected = _.eql(subset, val);
    } else {
      expected = (obj != undefined) &amp;&amp; ~obj.indexOf(val);
    }
    this.assert(
        expected
      , &#039;expected #{this} to include &#039; + _.inspect(val)
      , &#039;expected #{this} to not include &#039; + _.inspect(val));
  }

  Assertion.addChainableMethod(&#039;include&#039;, include, includeChainingBehavior);
  Assertion.addChainableMethod(&#039;contain&#039;, include, includeChainingBehavior);
  Assertion.addChainableMethod(&#039;contains&#039;, include, includeChainingBehavior);
  Assertion.addChainableMethod(&#039;includes&#039;, include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect(&#039;everything&#039;).to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;ok&#039;, function () {
    this.assert(
        flag(this, &#039;object&#039;)
      , &#039;expected #{this} to be truthy&#039;
      , &#039;expected #{this} to be falsy&#039;);
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;true&#039;, function () {
    this.assert(
        true === flag(this, &#039;object&#039;)
      , &#039;expected #{this} to be true&#039;
      , &#039;expected #{this} to be false&#039;
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;false&#039;, function () {
    this.assert(
        false === flag(this, &#039;object&#039;)
      , &#039;expected #{this} to be false&#039;
      , &#039;expected #{this} to be true&#039;
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).to.not.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;null&#039;, function () {
    this.assert(
        null === flag(this, &#039;object&#039;)
      , &#039;expected #{this} to be null&#039;
      , &#039;expected #{this} not to be null&#039;
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;undefined&#039;, function () {
    this.assert(
        undefined === flag(this, &#039;object&#039;)
      , &#039;expected #{this} to be undefined&#039;
      , &#039;expected #{this} not to be undefined&#039;
    );
  });

  /**
   * ### .NaN
   * Asserts that the target is `NaN`.
   *
   *     expect(&#039;foo&#039;).to.be.NaN;
   *     expect(4).not.to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;NaN&#039;, function () {
    this.assert(
        isNaN(flag(this, &#039;object&#039;))
        , &#039;expected #{this} to be NaN&#039;
        , &#039;expected #{this} not to be NaN&#039;
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = &#039;hi&#039;
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;exist&#039;, function () {
    this.assert(
        null != flag(this, &#039;object&#039;)
      , &#039;expected #{this} to exist&#039;
      , &#039;expected #{this} to not exist&#039;
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target&#039;s length is `0`. For arrays and strings, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect(&#039;&#039;).to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;empty&#039;, function () {
    var obj = flag(this, &#039;object&#039;)
      , expected = obj;

    if (Array.isArray(obj) || &#039;string&#039; === typeof object) {
      expected = obj.length;
    } else if (typeof obj === &#039;object&#039;) {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , &#039;expected #{this} to be empty&#039;
      , &#039;expected #{this} not to be empty&#039;
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, &#039;object&#039;)
      , type = Object.prototype.toString.call(obj);
    this.assert(
        &#039;[object Arguments]&#039; === type
      , &#039;expected #{this} to be arguments but got &#039; + type
      , &#039;expected #{this} to not be arguments&#039;
    );
  }

  Assertion.addProperty(&#039;arguments&#039;, checkArguments);
  Assertion.addProperty(&#039;Arguments&#039;, checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect(&#039;hello&#039;).to.equal(&#039;hello&#039;);
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: &#039;bar&#039; }).to.not.equal({ foo: &#039;bar&#039; });
   *     expect({ foo: &#039;bar&#039; }).to.deep.equal({ foo: &#039;bar&#039; });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    if (flag(this, &#039;deep&#039;)) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , &#039;expected #{this} to equal #{exp}&#039;
        , &#039;expected #{this} to not equal #{exp}&#039;
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod(&#039;equal&#039;, assertEqual);
  Assertion.addMethod(&#039;equals&#039;, assertEqual);
  Assertion.addMethod(&#039;eq&#039;, assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: &#039;bar&#039; }).to.eql({ foo: &#039;bar&#039; });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    this.assert(
        _.eql(obj, flag(this, &#039;object&#039;))
      , &#039;expected #{this} to deeply equal #{exp}&#039;
      , &#039;expected #{this} to not deeply equal #{exp}&#039;
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod(&#039;eql&#039;, assertEql);
  Assertion.addMethod(&#039;eqls&#039;, assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#039;foo&#039;).to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    if (flag(this, &#039;doLength&#039;)) {
      new Assertion(obj, msg).to.have.property(&#039;length&#039;);
      var len = obj.length;
      this.assert(
          len &gt; n
        , &#039;expected #{this} to have a length above #{exp} but got #{act}&#039;
        , &#039;expected #{this} to not have a length above #{exp}&#039;
        , n
        , len
      );
    } else {
      this.assert(
          obj &gt; n
        , &#039;expected #{this} to be above &#039; + n
        , &#039;expected #{this} to be at most &#039; + n
      );
    }
  }

  Assertion.addMethod(&#039;above&#039;, assertAbove);
  Assertion.addMethod(&#039;gt&#039;, assertAbove);
  Assertion.addMethod(&#039;greaterThan&#039;, assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#039;foo&#039;).to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    if (flag(this, &#039;doLength&#039;)) {
      new Assertion(obj, msg).to.have.property(&#039;length&#039;);
      var len = obj.length;
      this.assert(
          len &gt;= n
        , &#039;expected #{this} to have a length at least #{exp} but got #{act}&#039;
        , &#039;expected #{this} to have a length below #{exp}&#039;
        , n
        , len
      );
    } else {
      this.assert(
          obj &gt;= n
        , &#039;expected #{this} to be at least &#039; + n
        , &#039;expected #{this} to be below &#039; + n
      );
    }
  }

  Assertion.addMethod(&#039;least&#039;, assertLeast);
  Assertion.addMethod(&#039;gte&#039;, assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#039;foo&#039;).to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    if (flag(this, &#039;doLength&#039;)) {
      new Assertion(obj, msg).to.have.property(&#039;length&#039;);
      var len = obj.length;
      this.assert(
          len &lt; n
        , &#039;expected #{this} to have a length below #{exp} but got #{act}&#039;
        , &#039;expected #{this} to not have a length below #{exp}&#039;
        , n
        , len
      );
    } else {
      this.assert(
          obj &lt; n
        , &#039;expected #{this} to be below &#039; + n
        , &#039;expected #{this} to be at least &#039; + n
      );
    }
  }

  Assertion.addMethod(&#039;below&#039;, assertBelow);
  Assertion.addMethod(&#039;lt&#039;, assertBelow);
  Assertion.addMethod(&#039;lessThan&#039;, assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#039;foo&#039;).to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    if (flag(this, &#039;doLength&#039;)) {
      new Assertion(obj, msg).to.have.property(&#039;length&#039;);
      var len = obj.length;
      this.assert(
          len &lt;= n
        , &#039;expected #{this} to have a length at most #{exp} but got #{act}&#039;
        , &#039;expected #{this} to have a length above #{exp}&#039;
        , n
        , len
      );
    } else {
      this.assert(
          obj &lt;= n
        , &#039;expected #{this} to be at most &#039; + n
        , &#039;expected #{this} to be above &#039; + n
      );
    }
  }

  Assertion.addMethod(&#039;most&#039;, assertMost);
  Assertion.addMethod(&#039;lte&#039;, assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#039;foo&#039;).to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod(&#039;within&#039;, function (start, finish, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;)
      , range = start + &#039;..&#039; + finish;
    if (flag(this, &#039;doLength&#039;)) {
      new Assertion(obj, msg).to.have.property(&#039;length&#039;);
      var len = obj.length;
      this.assert(
          len &gt;= start &amp;&amp; len &lt;= finish
        , &#039;expected #{this} to have a length within &#039; + range
        , &#039;expected #{this} to not have a length within &#039; + range
      );
    } else {
      this.assert(
          obj &gt;= start &amp;&amp; obj &lt;= finish
        , &#039;expected #{this} to be within &#039; + range
        , &#039;expected #{this} to not be within &#039; + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea(&#039;chai&#039;);
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, &#039;object&#039;) instanceof constructor
      , &#039;expected #{this} to be an instance of &#039; + name
      , &#039;expected #{this} to not be an instance of &#039; + name
    );
  };

  Assertion.addMethod(&#039;instanceof&#039;, assertInstanceOf);
  Assertion.addMethod(&#039;instanceOf&#039;, assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: &#039;bar&#039; };
   *     expect(obj).to.have.property(&#039;foo&#039;);
   *     expect(obj).to.have.property(&#039;foo&#039;, &#039;bar&#039;);
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: &#039;matcha&#039; }
   *       , teas: [ &#039;chai&#039;, &#039;matcha&#039;, { tea: &#039;konacha&#039; } ]
   *     };
   *
   *     expect(deepObj).to.have.deep.property(&#039;green.tea&#039;, &#039;matcha&#039;);
   *     expect(deepObj).to.have.deep.property(&#039;teas[1]&#039;, &#039;matcha&#039;);
   *     expect(deepObj).to.have.deep.property(&#039;teas[2].tea&#039;, &#039;konacha&#039;);
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ &#039;chai&#039;, &#039;matcha&#039;, &#039;konacha&#039; ]
   *       , [ { tea: &#039;chai&#039; }
   *         , { tea: &#039;matcha&#039; }
   *         , { tea: &#039;konacha&#039; } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property(&#039;[0][1]&#039;, &#039;matcha&#039;);
   *     expect(arr).to.have.deep.property(&#039;[1][2].tea&#039;, &#039;konacha&#039;);
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property(&#039;foo&#039;)
   *       .that.is.a(&#039;string&#039;);
   *     expect(deepObj).to.have.property(&#039;green&#039;)
   *       .that.is.an(&#039;object&#039;)
   *       .that.deep.equals({ tea: &#039;matcha&#039; });
   *     expect(deepObj).to.have.property(&#039;teas&#039;)
   *       .that.is.an(&#039;array&#039;)
   *       .with.deep.property(&#039;[2]&#039;)
   *         .that.deep.equals({ tea: &#039;konacha&#039; });
   *
   * Note that dots and bracket in `name` must be backslash-escaped when
   * the `deep` flag is set, while they must NOT be escaped when the `deep`
   * flag is not set.
   *
   *     // simple referencing
   *     var css = { &#039;.link[target]&#039;: 42 };
   *     expect(css).to.have.property(&#039;.link[target]&#039;, 42);
   *
   *     // deep referencing
   *     var deepCss = { &#039;.link&#039;: { &#039;[target]&#039;: 42 }};
   *     expect(deepCss).to.have.deep.property(&#039;\\.link.\\[target\\]&#039;, 42);
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod(&#039;property&#039;, function (name, val, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);

    var isDeep = !!flag(this, &#039;deep&#039;)
      , descriptor = isDeep ? &#039;deep property &#039; : &#039;property &#039;
      , negate = flag(this, &#039;negate&#039;)
      , obj = flag(this, &#039;object&#039;)
      , pathInfo = isDeep ? _.getPathInfo(name, obj) : null
      , hasProperty = isDeep
        ? pathInfo.exists
        : _.hasProperty(name, obj)
      , value = isDeep
        ? pathInfo.value
        : obj[name];

    if (negate &amp;&amp; arguments.length &gt; 1) {
      if (undefined === value) {
        msg = (msg != null) ? msg + &#039;: &#039; : &#039;&#039;;
        throw new Error(msg + _.inspect(obj) + &#039; has no &#039; + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          hasProperty
        , &#039;expected #{this} to have a &#039; + descriptor + _.inspect(name)
        , &#039;expected #{this} to not have &#039; + descriptor + _.inspect(name));
    }

    if (arguments.length &gt; 1) {
      this.assert(
          val === value
        , &#039;expected #{this} to have a &#039; + descriptor + _.inspect(name) + &#039; of #{exp}, but got #{act}&#039;
        , &#039;expected #{this} to not have a &#039; + descriptor + _.inspect(name) + &#039; of #{act}&#039;
        , val
        , value
      );
    }

    flag(this, &#039;object&#039;, value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect(&#039;test&#039;).to.have.ownProperty(&#039;length&#039;);
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    this.assert(
        obj.hasOwnProperty(name)
      , &#039;expected #{this} to have own property &#039; + _.inspect(name)
      , &#039;expected #{this} to not have own property &#039; + _.inspect(name)
    );
  }

  Assertion.addMethod(&#039;ownProperty&#039;, assertOwnProperty);
  Assertion.addMethod(&#039;haveOwnProperty&#039;, assertOwnProperty);

  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, message]])
   *
   * Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.
   *
   *     expect(&#039;test&#039;).to.have.ownPropertyDescriptor(&#039;length&#039;);
   *     expect(&#039;test&#039;).to.have.ownPropertyDescriptor(&#039;length&#039;, { enumerable: false, configurable: false, writable: false, value: 4 });
   *     expect(&#039;test&#039;).not.to.have.ownPropertyDescriptor(&#039;length&#039;, { enumerable: false, configurable: false, writable: false, value: 3 });
   *     expect(&#039;test&#039;).ownPropertyDescriptor(&#039;length&#039;).to.have.property(&#039;enumerable&#039;, false);
   *     expect(&#039;test&#039;).ownPropertyDescriptor(&#039;length&#039;).to.have.keys(&#039;value&#039;);
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnPropertyDescriptor (name, descriptor, msg) {
    if (typeof descriptor === &#039;string&#039;) {
      msg = descriptor;
      descriptor = null;
    }
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
    if (actualDescriptor &amp;&amp; descriptor) {
      this.assert(
          _.eql(descriptor, actualDescriptor)
        , &#039;expected the own property descriptor for &#039; + _.inspect(name) + &#039; on #{this} to match &#039; + _.inspect(descriptor) + &#039;, got &#039; + _.inspect(actualDescriptor)
        , &#039;expected the own property descriptor for &#039; + _.inspect(name) + &#039; on #{this} to not match &#039; + _.inspect(descriptor)
        , descriptor
        , actualDescriptor
        , true
      );
    } else {
      this.assert(
          actualDescriptor
        , &#039;expected #{this} to have an own property descriptor for &#039; + _.inspect(name)
        , &#039;expected #{this} to not have an own property descriptor for &#039; + _.inspect(name)
      );
    }
    flag(this, &#039;object&#039;, actualDescriptor);
  }

  Assertion.addMethod(&#039;ownPropertyDescriptor&#039;, assertOwnPropertyDescriptor);
  Assertion.addMethod(&#039;haveOwnPropertyDescriptor&#039;, assertOwnPropertyDescriptor);

  /**
   * ### .length
   *
   * Sets the `doLength` flag later used as a chain precursor to a value
   * comparison for the `length` property.
   *
   *     expect(&#039;foo&#039;).to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect(&#039;foo&#039;).to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect(&#039;foo&#039;).to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * *Deprecation notice:* Using `length` as an assertion will be deprecated
   * in version 2.4.0 and removed in 3.0.0. Code using the old style of
   * asserting for `length` property value using `length(value)` should be
   * switched to use `lengthOf(value)` instead.
   *
   * @name length
   * @namespace BDD
   * @api public
   */

  /**
   * ### .lengthOf(value[, message])
   *
   * Asserts that the target&#039;s `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.lengthOf(3);
   *     expect(&#039;foobar&#039;).to.have.lengthOf(6);
   *
   * @name lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertLengthChain () {
    flag(this, &#039;doLength&#039;, true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    new Assertion(obj, msg).to.have.property(&#039;length&#039;);
    var len = obj.length;

    this.assert(
        len == n
      , &#039;expected #{this} to have a length of #{exp} but got #{act}&#039;
      , &#039;expected #{this} to not have a length of #{act}&#039;
      , n
      , len
    );
  }

  Assertion.addChainableMethod(&#039;length&#039;, assertLength, assertLengthChain);
  Assertion.addMethod(&#039;lengthOf&#039;, assertLength);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect(&#039;foobar&#039;).to.match(/^foo/);
   *
   * @name match
   * @alias matches
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */
  function assertMatch(re, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    this.assert(
        re.exec(obj)
      , &#039;expected #{this} to match &#039; + re
      , &#039;expected #{this} not to match &#039; + re
    );
  }

  Assertion.addMethod(&#039;match&#039;, assertMatch);
  Assertion.addMethod(&#039;matches&#039;, assertMatch);

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect(&#039;foobar&#039;).to.have.string(&#039;bar&#039;);
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod(&#039;string&#039;, function (str, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    new Assertion(obj, msg).is.a(&#039;string&#039;);

    this.assert(
        ~obj.indexOf(str)
      , &#039;expected #{this} to contain &#039; + _.inspect(str)
      , &#039;expected #{this} to not contain &#039; + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target contains any or all of the passed-in keys.
   * Use in combination with `any`, `all`, `contains`, or `have` will affect
   * what will pass.
   *
   * When used in conjunction with `any`, at least one key that is passed
   * in must exist in the target object. This is regardless whether or not
   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`
   * should be used in the assertion. If neither are used, the assertion is
   * defaulted to `all`.
   *
   * When both `all` and `contain` are used, the target object must have at
   * least all of the passed-in keys but may have more keys not listed.
   *
   * When both `all` and `have` are used, the target object must both contain
   * all of the passed-in keys AND the number of keys in the target object must
   * match the number of keys passed in (in other words, a target object must
   * have all and only all of the passed-in keys).
   *
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys(&#039;foo&#039;, &#039;baz&#039;);
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys(&#039;foo&#039;);
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(&#039;bar&#039;, &#039;baz&#039;);
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys([&#039;foo&#039;]);
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({&#039;foo&#039;: 6});
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys([&#039;bar&#039;, &#039;foo&#039;]);
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({&#039;bar&#039;: 6, &#039;foo&#039;: 7});
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys([&#039;bar&#039;, &#039;foo&#039;]);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({&#039;bar&#039;: 6});
   *
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, &#039;object&#039;)
      , str
      , ok = true
      , mixedArgsMsg = &#039;keys must be given single argument of Array|Object|String, or multiple String arguments&#039;;

    switch (_.type(keys)) {
      case &quot;array&quot;:
        if (arguments.length &gt; 1) throw (new Error(mixedArgsMsg));
        break;
      case &quot;object&quot;:
        if (arguments.length &gt; 1) throw (new Error(mixedArgsMsg));
        keys = Object.keys(keys);
        break;
      default:
        keys = Array.prototype.slice.call(arguments);
    }

    if (!keys.length) throw new Error(&#039;keys required&#039;);

    var actual = Object.keys(obj)
      , expected = keys
      , len = keys.length
      , any = flag(this, &#039;any&#039;)
      , all = flag(this, &#039;all&#039;);

    if (!any &amp;&amp; !all) {
      all = true;
    }

    // Has any
    if (any) {
      var intersection = expected.filter(function(key) {
        return ~actual.indexOf(key);
      });
      ok = intersection.length &gt; 0;
    }

    // Has all
    if (all) {
      ok = keys.every(function(key){
        return ~actual.indexOf(key);
      });
      if (!flag(this, &#039;negate&#039;) &amp;&amp; !flag(this, &#039;contains&#039;)) {
        ok = ok &amp;&amp; keys.length == actual.length;
      }
    }

    // Key string
    if (len &gt; 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      if (all) {
        str = keys.join(&#039;, &#039;) + &#039;, and &#039; + last;
      }
      if (any) {
        str = keys.join(&#039;, &#039;) + &#039;, or &#039; + last;
      }
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len &gt; 1 ? &#039;keys &#039; : &#039;key &#039;) + str;

    // Have / include
    str = (flag(this, &#039;contains&#039;) ? &#039;contain &#039; : &#039;have &#039;) + str;

    // Assertion
    this.assert(
        ok
      , &#039;expected #{this} to &#039; + str
      , &#039;expected #{this} to not &#039; + str
      , expected.slice(0).sort()
      , actual.sort()
      , true
    );
  }

  Assertion.addMethod(&#039;keys&#039;, assertKeys);
  Assertion.addMethod(&#039;key&#039;, assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error&#039;s message.
   *
   *     var err = new ReferenceError(&#039;This is a bad function.&#039;);
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw(&#039;good function&#039;);
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    new Assertion(obj, msg).is.a(&#039;function&#039;);

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor &amp;&amp; (constructor instanceof RegExp || &#039;string&#039; === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor &amp;&amp; constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === &#039;function&#039;) {
      name = constructor.prototype.name;
      if (!name || (name === &#039;Error&#039; &amp;&amp; constructor !== Error)) {
        name = constructor.name || (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , &#039;expected #{this} to throw #{exp} but #{act} was thrown&#039;
          , &#039;expected #{this} to not throw #{exp}&#039;
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, &#039;object&#039;, err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , &#039;expected #{this} to throw #{exp} but #{act} was thrown&#039;
          , &#039;expected #{this} to not throw #{exp} but #{act} was thrown&#039;
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, &#039;object&#039;, err);
          return this;
        }
      }

      // next, check message
      var message = &#039;error&#039; === _.type(err) &amp;&amp; &quot;message&quot; in err
        ? err.message
        : &#039;&#039; + err;

      if ((message != null) &amp;&amp; errMsg &amp;&amp; errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , &#039;expected #{this} to throw error matching #{exp} but got #{act}&#039;
          , &#039;expected #{this} to throw error not matching #{exp}&#039;
          , errMsg
          , message
        );

        flag(this, &#039;object&#039;, err);
        return this;
      } else if ((message != null) &amp;&amp; errMsg &amp;&amp; &#039;string&#039; === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , &#039;expected #{this} to throw error including #{exp} but got #{act}&#039;
          , &#039;expected #{this} to throw error not including #{act}&#039;
          , errMsg
          , message
        );

        flag(this, &#039;object&#039;, err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = &#039;&#039;
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? &#039;#{exp}&#039; //_.inspect(desiredError)
          : &#039;an error&#039;;

    if (thrown) {
      actuallyGot = &#039; but #{act} was thrown&#039;
    }

    this.assert(
        thrown === true
      , &#039;expected #{this} to throw &#039; + expectedThrown + actuallyGot
      , &#039;expected #{this} to not throw &#039; + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, &#039;object&#039;, thrownError);
  };

  Assertion.addMethod(&#039;throw&#039;, assertThrows);
  Assertion.addMethod(&#039;throws&#039;, assertThrows);
  Assertion.addMethod(&#039;Throw&#039;, assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo(&#039;bar&#039;);
   *     expect(obj).to.respondTo(&#039;bar&#039;);
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo(&#039;baz&#039;);
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function respondTo (method, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;)
      , itself = flag(this, &#039;itself&#039;)
      , context = (&#039;function&#039; === _.type(obj) &amp;&amp; !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        &#039;function&#039; === typeof context
      , &#039;expected #{this} to respond to &#039; + _.inspect(method)
      , &#039;expected #{this} to not respond to &#039; + _.inspect(method)
    );
  }

  Assertion.addMethod(&#039;respondTo&#039;, respondTo);
  Assertion.addMethod(&#039;respondsTo&#039;, respondTo);

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo(&#039;bar&#039;);
   *     expect(Foo).itself.not.to.respondTo(&#039;baz&#039;);
   *
   * @name itself
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;itself&#039;, function () {
    flag(this, &#039;itself&#039;, true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num &gt; 0; });
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function satisfy (matcher, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);
    var result = matcher(obj);
    this.assert(
        result
      , &#039;expected #{this} to satisfy &#039; + _.objDisplay(matcher)
      , &#039;expected #{this} to not satisfy&#039; + _.objDisplay(matcher)
      , this.negate ? false : true
      , result
    );
  }

  Assertion.addMethod(&#039;satisfy&#039;, satisfy);
  Assertion.addMethod(&#039;satisfies&#039;, satisfy);

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function closeTo(expected, delta, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);

    new Assertion(obj, msg).is.a(&#039;number&#039;);
    if (_.type(expected) !== &#039;number&#039; || _.type(delta) !== &#039;number&#039;) {
      throw new Error(&#039;the arguments to closeTo or approximately must be numbers&#039;);
    }

    this.assert(
        Math.abs(obj - expected) &lt;= delta
      , &#039;expected #{this} to be close to &#039; + expected + &#039; +/- &#039; + delta
      , &#039;expected #{this} not to be close to &#039; + expected + &#039; +/- &#039; + delta
    );
  }

  Assertion.addMethod(&#039;closeTo&#039;, closeTo);
  Assertion.addMethod(&#039;approximately&#039;, closeTo);

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod(&#039;members&#039;, function (subset, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var obj = flag(this, &#039;object&#039;);

    new Assertion(obj).to.be.an(&#039;array&#039;);
    new Assertion(subset).to.be.an(&#039;array&#039;);

    var cmp = flag(this, &#039;deep&#039;) ? _.eql : undefined;

    if (flag(this, &#039;contains&#039;)) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , &#039;expected #{this} to be a superset of #{act}&#039;
        , &#039;expected #{this} to not be a superset of #{act}&#039;
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) &amp;&amp; isSubsetOf(subset, obj, cmp)
        , &#039;expected #{this} to have the same members as #{act}&#039;
        , &#039;expected #{this} to not have the same members as #{act}&#039;
        , obj
        , subset
    );
  });

  /**
   * ### .oneOf(list)
   *
   * Assert that a value appears somewhere in the top level of array `list`.
   *
   *     expect(&#039;a&#039;).to.be.oneOf([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;]);
   *     expect(9).to.not.be.oneOf([&#039;z&#039;]);
   *     expect([3]).to.not.be.oneOf([1, 2, [3]]);
   *
   *     var three = [3];
   *     // for object-types, contents are not compared
   *     expect(three).to.not.be.oneOf([1, 2, [3]]);
   *     // comparing references works
   *     expect(three).to.be.oneOf([1, 2, three]);
   *
   * @name oneOf
   * @param {Array&lt;*&gt;} list
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function oneOf (list, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var expected = flag(this, &#039;object&#039;);
    new Assertion(list).to.be.an(&#039;array&#039;);

    this.assert(
        list.indexOf(expected) &gt; -1
      , &#039;expected #{this} to be one of #{exp}&#039;
      , &#039;expected #{this} to not be one of #{exp}&#039;
      , list
      , expected
    );
  }

  Assertion.addMethod(&#039;oneOf&#039;, oneOf);


  /**
   * ### .change(function)
   *
   * Asserts that a function changes an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 3 };
   *     var noChangeFn = function() { return &#039;foo&#039; + &#039;bar&#039;; }
   *     expect(fn).to.change(obj, &#039;val&#039;);
   *     expect(noChangeFn).to.not.change(obj, &#039;val&#039;)
   *
   * @name change
   * @alias changes
   * @alias Change
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertChanges (object, prop, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var fn = flag(this, &#039;object&#039;);
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a(&#039;function&#039;);

    var initial = object[prop];
    fn();

    this.assert(
      initial !== object[prop]
      , &#039;expected .&#039; + prop + &#039; to change&#039;
      , &#039;expected .&#039; + prop + &#039; to not change&#039;
    );
  }

  Assertion.addChainableMethod(&#039;change&#039;, assertChanges);
  Assertion.addChainableMethod(&#039;changes&#039;, assertChanges);

  /**
   * ### .increase(function)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     expect(fn).to.increase(obj, &#039;val&#039;);
   *
   * @name increase
   * @alias increases
   * @alias Increase
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertIncreases (object, prop, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var fn = flag(this, &#039;object&#039;);
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a(&#039;function&#039;);

    var initial = object[prop];
    fn();

    this.assert(
      object[prop] - initial &gt; 0
      , &#039;expected .&#039; + prop + &#039; to increase&#039;
      , &#039;expected .&#039; + prop + &#039; to not increase&#039;
    );
  }

  Assertion.addChainableMethod(&#039;increase&#039;, assertIncreases);
  Assertion.addChainableMethod(&#039;increases&#039;, assertIncreases);

  /**
   * ### .decrease(function)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     expect(fn).to.decrease(obj, &#039;val&#039;);
   *
   * @name decrease
   * @alias decreases
   * @alias Decrease
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertDecreases (object, prop, msg) {
    if (msg) flag(this, &#039;message&#039;, msg);
    var fn = flag(this, &#039;object&#039;);
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a(&#039;function&#039;);

    var initial = object[prop];
    fn();

    this.assert(
      object[prop] - initial &lt; 0
      , &#039;expected .&#039; + prop + &#039; to decrease&#039;
      , &#039;expected .&#039; + prop + &#039; to not decrease&#039;
    );
  }

  Assertion.addChainableMethod(&#039;decrease&#039;, assertDecreases);
  Assertion.addChainableMethod(&#039;decreases&#039;, assertDecreases);

  /**
   * ### .extensible
   *
   * Asserts that the target is extensible (can have new properties added to
   * it).
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect({}).to.be.extensible;
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;extensible&#039;, function() {
    var obj = flag(this, &#039;object&#039;);

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isExtensible;

    try {
      isExtensible = Object.isExtensible(obj);
    } catch (err) {
      if (err instanceof TypeError) isExtensible = false;
      else throw err;
    }

    this.assert(
      isExtensible
      , &#039;expected #{this} to be extensible&#039;
      , &#039;expected #{this} to not be extensible&#039;
    );
  });

  /**
   * ### .sealed
   *
   * Asserts that the target is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect({}).to.not.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;sealed&#039;, function() {
    var obj = flag(this, &#039;object&#039;);

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isSealed;

    try {
      isSealed = Object.isSealed(obj);
    } catch (err) {
      if (err instanceof TypeError) isSealed = true;
      else throw err;
    }

    this.assert(
      isSealed
      , &#039;expected #{this} to be sealed&#039;
      , &#039;expected #{this} to not be sealed&#039;
    );
  });

  /**
   * ### .frozen
   *
   * Asserts that the target is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect({}).to.not.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty(&#039;frozen&#039;, function() {
    var obj = flag(this, &#039;object&#039;);

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isFrozen;

    try {
      isFrozen = Object.isFrozen(obj);
    } catch (err) {
      if (err instanceof TypeError) isFrozen = true;
      else throw err;
    }

    this.assert(
      isFrozen
      , &#039;expected #{this} to be frozen&#039;
      , &#039;expected #{this} to not be frozen&#039;
    );
  });
};

},{}],6:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert(&#039;foo&#039; !== &#039;bar&#039;, &#039;foo is not bar&#039;);
   *     assert(Array.isArray([]), &#039;empty arrays are arrays&#039;);
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert);
    test.assert(
        express
      , errmsg
      , &#039;[ negation message unavailable ]&#039;
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || &#039;assert.fail()&#039;;
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk(&#039;everything&#039;, &#039;everything is ok&#039;);
   *     assert.isOk(false, &#039;this will fail&#039;);
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isOk = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk(&#039;everything&#039;, &#039;this will fail&#039;);
   *     assert.isNotOk(false, &#039;this will pass&#039;);
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, &#039;3&#039;, &#039;== coerces values to strings&#039;);
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal);

    test.assert(
        exp == flag(test, &#039;object&#039;)
      , &#039;expected #{this} to equal #{exp}&#039;
      , &#039;expected #{this} to not equal #{act}&#039;
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, &#039;these numbers are not equal&#039;);
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual);

    test.assert(
        exp != flag(test, &#039;object&#039;)
      , &#039;expected #{this} to not equal #{exp}&#039;
      , &#039;expected #{this} to equal #{act}&#039;
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, &#039;these booleans are strictly equal&#039;);
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, &#039;3&#039;, &#039;no coercion for strict equality&#039;);
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: &#039;green&#039; }, { tea: &#039;green&#039; });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: &#039;green&#039; }, { tea: &#039;jasmine&#039; });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

   /**
   * ### .isAbove(valueToCheck, valueToBeAbove, [message])
   *
   * Asserts `valueToCheck` is strictly greater than (&gt;) `valueToBeAbove`
   *
   *     assert.isAbove(5, 2, &#039;5 is strictly greater than 2&#039;);
   *
   * @name isAbove
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAbove
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAbove = function (val, abv, msg) {
    new Assertion(val, msg).to.be.above(abv);
  };

   /**
   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
   *
   * Asserts `valueToCheck` is greater than or equal to (&gt;=) `valueToBeAtLeast`
   *
   *     assert.isAtLeast(5, 2, &#039;5 is greater or equal to 2&#039;);
   *     assert.isAtLeast(3, 3, &#039;3 is greater or equal to 3&#039;);
   *
   * @name isAtLeast
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtLeast
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAtLeast = function (val, atlst, msg) {
    new Assertion(val, msg).to.be.least(atlst);
  };

   /**
   * ### .isBelow(valueToCheck, valueToBeBelow, [message])
   *
   * Asserts `valueToCheck` is strictly less than (&lt;) `valueToBeBelow`
   *
   *     assert.isBelow(3, 6, &#039;3 is strictly less than 6&#039;);
   *
   * @name isBelow
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeBelow
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isBelow = function (val, blw, msg) {
    new Assertion(val, msg).to.be.below(blw);
  };

   /**
   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
   *
   * Asserts `valueToCheck` is less than or equal to (&lt;=) `valueToBeAtMost`
   *
   *     assert.isAtMost(3, 6, &#039;3 is less than or equal to 6&#039;);
   *     assert.isAtMost(4, 4, &#039;4 is less than or equal to 4&#039;);
   *
   * @name isAtMost
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtMost
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAtMost = function (val, atmst, msg) {
    new Assertion(val, msg).to.be.most(atmst);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, &#039;the tea has been served&#039;);
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is[&#039;true&#039;];
  };

  /**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that `value` is not true.
   *
   *     var tea = &#039;tasty chai&#039;;
   *     assert.isNotTrue(tea, &#039;great, time for tea!&#039;);
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotTrue = function (val, msg) {
    new Assertion(val, msg).to.not.equal(true);
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, &#039;no tea yet? hmm...&#039;);
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is[&#039;false&#039;];
  };

  /**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that `value` is not false.
   *
   *     var tea = &#039;tasty chai&#039;;
   *     assert.isNotFalse(tea, &#039;great, time for tea!&#039;);
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotFalse = function (val, msg) {
    new Assertion(val, msg).to.not.equal(false);
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, &#039;there was no error&#039;);
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = &#039;tasty chai&#039;;
   *     assert.isNotNull(tea, &#039;great, time for tea!&#039;);
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isNaN
   * Asserts that value is NaN
   *
   *    assert.isNaN(&#039;foo&#039;, &#039;foo is NaN&#039;);
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNaN = function (val, msg) {
    new Assertion(val, msg).to.be.NaN;
  };

  /**
   * ### .isNotNaN
   * Asserts that value is not NaN
   *
   *    assert.isNotNaN(4, &#039;4 is not NaN&#039;);
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */
  assert.isNotNaN = function (val, msg) {
    new Assertion(val, msg).not.to.be.NaN;
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, &#039;no tea defined&#039;);
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = &#039;cup of chai&#039;;
   *     assert.isDefined(tea, &#039;tea has been defined&#039;);
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return &#039;cup of tea&#039;; };
   *     assert.isFunction(serveTea, &#039;great, we can have tea now&#039;);
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a(&#039;function&#039;);
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ &#039;heat&#039;, &#039;pour&#039;, &#039;sip&#039; ];
   *     assert.isNotFunction(serveTea, &#039;great, we have listed the steps&#039;);
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a(&#039;function&#039;);
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object of type &#039;Object&#039; (as revealed by `Object.prototype.toString`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: &#039;Chai&#039;, serve: &#039;with spices&#039; };
   *     assert.isObject(selection, &#039;tea selection is an object&#039;);
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a(&#039;object&#039;);
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object of type &#039;Object&#039; (as revealed by `Object.prototype.toString`).
   *
   *     var selection = &#039;chai&#039;
   *     assert.isNotObject(selection, &#039;tea selection is not an object&#039;);
   *     assert.isNotObject(null, &#039;null is not an object&#039;);
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a(&#039;object&#039;);
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ &#039;green&#039;, &#039;chai&#039;, &#039;oolong&#039; ];
   *     assert.isArray(menu, &#039;what kind of tea do we want?&#039;);
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an(&#039;array&#039;);
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = &#039;green|chai|oolong&#039;;
   *     assert.isNotArray(menu, &#039;what kind of tea do we want?&#039;);
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an(&#039;array&#039;);
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = &#039;chai&#039;;
   *     assert.isString(teaOrder, &#039;order placed&#039;);
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a(&#039;string&#039;);
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, &#039;order placed&#039;);
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a(&#039;string&#039;);
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, &#039;how many cups&#039;);
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a(&#039;number&#039;);
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = &#039;2 cups please&#039;;
   *     assert.isNotNumber(cups, &#039;how many cups&#039;);
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a(&#039;number&#039;);
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, &#039;is the tea ready&#039;);
   *     assert.isBoolean(teaServed, &#039;has tea been served&#039;);
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a(&#039;boolean&#039;);
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = &#039;yep&#039;
   *       , teaServed = &#039;nope&#039;;
   *
   *     assert.isNotBoolean(teaReady, &#039;is the tea ready&#039;);
   *     assert.isNotBoolean(teaServed, &#039;has tea been served&#039;);
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a(&#039;boolean&#039;);
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`&#039;s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: &#039;chai&#039; }, &#039;object&#039;, &#039;we have an object&#039;);
   *     assert.typeOf([&#039;chai&#039;, &#039;jasmine&#039;], &#039;array&#039;, &#039;we have an array&#039;);
   *     assert.typeOf(&#039;tea&#039;, &#039;string&#039;, &#039;we have a string&#039;);
   *     assert.typeOf(/tea/, &#039;regexp&#039;, &#039;we have a regular expression&#039;);
   *     assert.typeOf(null, &#039;null&#039;, &#039;we have a null&#039;);
   *     assert.typeOf(undefined, &#039;undefined&#039;, &#039;we have an undefined&#039;);
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`&#039;s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf(&#039;tea&#039;, &#039;number&#039;, &#039;strings are not numbers&#039;);
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea(&#039;chai&#039;);
   *
   *     assert.instanceOf(chai, Tea, &#039;chai is an instance of tea&#039;);
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String(&#039;chai&#039;);
   *
   *     assert.notInstanceOf(chai, Tea, &#039;chai is not an instance of tea&#039;);
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include(&#039;foobar&#039;, &#039;bar&#039;, &#039;foobar contains string &quot;bar&quot;&#039;);
   *     assert.include([ 1, 2, 3 ], 3, &#039;array contains value&#039;);
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *
   *     assert.notInclude(&#039;foobar&#039;, &#039;baz&#039;, &#039;string not include substring&#039;);
   *     assert.notInclude([ 1, 2, 3 ], 4, &#039;array not include contain value&#039;);
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match(&#039;foobar&#039;, /^foo/, &#039;regexp matches&#039;);
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch(&#039;foobar&#039;, /^foo/, &#039;regexp does not match&#039;);
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: &#039;matcha&#039; }}, &#039;tea&#039;);
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: &#039;matcha&#039; }}, &#039;coffee&#039;);
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: &#039;matcha&#039; }}, &#039;tea.green&#039;);
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: &#039;matcha&#039; }}, &#039;tea.oolong&#039;);
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: &#039;is good&#039; }, &#039;tea&#039;, &#039;is good&#039;);
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: &#039;is good&#039; }, &#039;tea&#039;, &#039;is bad&#039;);
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: &#039;matcha&#039; }}, &#039;tea.green&#039;, &#039;matcha&#039;);
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: &#039;matcha&#039; }}, &#039;tea.green&#039;, &#039;konacha&#039;);
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, &#039;array has length of 3&#039;);
   *     assert.lengthOf(&#039;foobar&#039;, 6, &#039;string has length of 6&#039;);
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throws(fn, &#039;function throws a reference error&#039;);
   *     assert.throws(fn, /function throws a reference error/);
   *     assert.throws(fn, ReferenceError);
   *     assert.throws(fn, ReferenceError, &#039;function throws a reference error&#039;);
   *     assert.throws(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */

  assert.throws = function (fn, errt, errs, msg) {
    if (&#039;string&#039; === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.throw(errt, errs);
    return flag(assertErr, &#039;object&#039;);
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, &#039;function does not throw&#039;);
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if (&#039;string&#039; === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, &#039;&lt;&#039;, 2, &#039;everything is ok&#039;);
   *     assert.operator(1, &#039;&gt;&#039;, 2, &#039;this will fail&#039;);
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    var ok;
    switch(operator) {
      case &#039;==&#039;:
        ok = val == val2;
        break;
      case &#039;===&#039;:
        ok = val === val2;
        break;
      case &#039;&gt;&#039;:
        ok = val &gt; val2;
        break;
      case &#039;&gt;=&#039;:
        ok = val &gt;= val2;
        break;
      case &#039;&lt;&#039;:
        ok = val &lt; val2;
        break;
      case &#039;&lt;=&#039;:
        ok = val &lt;= val2;
        break;
      case &#039;!=&#039;:
        ok = val != val2;
        break;
      case &#039;!==&#039;:
        ok = val !== val2;
        break;
      default:
        throw new Error(&#039;Invalid operator &quot;&#039; + operator + &#039;&quot;&#039;);
    }
    var test = new Assertion(ok, msg);
    test.assert(
        true === flag(test, &#039;object&#039;)
      , &#039;expected &#039; + util.inspect(val) + &#039; to be &#039; + operator + &#039; &#039; + util.inspect(val2)
      , &#039;expected &#039; + util.inspect(val) + &#039; to not be &#039; + operator + &#039; &#039; + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, &#039;numbers are close&#039;);
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.approximately(1.5, 1, 0.5, &#039;numbers are close&#039;);
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.approximately = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.approximately(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], &#039;same members&#039;);
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.
   * Order is not taken into account.
   *
   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], &#039;same deep members&#039;);
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.deep.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], &#039;include members&#039;);
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

  /**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` - using deep equality checking.
   * Order is not taken into account.
   * Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ {a: 1}, {b: 2}, {c: 3} ], [ {b: 2}, {a: 1}, {b: 2} ], &#039;include deep members&#039;);
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.deep.members(subset);
  }

  /**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
   *
   *     assert.oneOf(1, [ 2, 1 ], &#039;Not found in list&#039;);
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array&lt;*&gt;} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.oneOf = function (inList, list, msg) {
    new Assertion(inList, msg).to.be.oneOf(list);
  }

   /**
   * ### .changes(function, object, property)
   *
   * Asserts that a function changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, &#039;val&#039;);
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.changes = function (fn, obj, prop) {
    new Assertion(fn).to.change(obj, prop);
  }

   /**
   * ### .doesNotChange(function, object, property)
   *
   * Asserts that a function does not changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { console.log(&#039;foo&#039;); };
   *     assert.doesNotChange(fn, obj, &#039;val&#039;);
   *
   * @name doesNotChange
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotChange = function (fn, obj, prop) {
    new Assertion(fn).to.not.change(obj, prop);
  }

   /**
   * ### .increases(function, object, property)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, &#039;val&#039;);
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.increases = function (fn, obj, prop) {
    new Assertion(fn).to.increase(obj, prop);
  }

   /**
   * ### .doesNotIncrease(function, object, property)
   *
   * Asserts that a function does not increase object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, &#039;val&#039;);
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotIncrease = function (fn, obj, prop) {
    new Assertion(fn).to.not.increase(obj, prop);
  }

   /**
   * ### .decreases(function, object, property)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, &#039;val&#039;);
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.decreases = function (fn, obj, prop) {
    new Assertion(fn).to.decrease(obj, prop);
  }

   /**
   * ### .doesNotDecrease(function, object, property)
   *
   * Asserts that a function does not decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, &#039;val&#039;);
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotDecrease = function (fn, obj, prop) {
    new Assertion(fn).to.not.decrease(obj, prop);
  }

  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node&#039;s
   * assert class.
   *
   *     var err = new Error(&#039;I am a custom error&#039;);
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */

  assert.ifError = function (val) {
    if (val) {
      throw(val);
    }
  };

  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isExtensible = function (obj, msg) {
    new Assertion(obj, msg).to.be.extensible;
  };

  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freese({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotExtensible = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.extensible;
  };

  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isSealed = function (obj, msg) {
    new Assertion(obj, msg).to.be.sealed;
  };

  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotSealed = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.sealed;
  };

  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isFrozen = function (obj, msg) {
    new Assertion(obj, msg).to.be.frozen;
  };

  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotFrozen = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.frozen;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  (&#039;isOk&#039;, &#039;ok&#039;)
  (&#039;isNotOk&#039;, &#039;notOk&#039;)
  (&#039;throws&#039;, &#039;throw&#039;)
  (&#039;throws&#039;, &#039;Throw&#039;)
  (&#039;isExtensible&#039;, &#039;extensible&#039;)
  (&#039;isNotExtensible&#039;, &#039;notExtensible&#039;)
  (&#039;isSealed&#039;, &#039;sealed&#039;)
  (&#039;isNotSealed&#039;, &#039;notSealed&#039;)
  (&#039;isFrozen&#039;, &#039;frozen&#039;)
  (&#039;isNotFrozen&#039;, &#039;notFrozen&#039;);
};

},{}],7:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Expect
   * @api public
   */

  chai.expect.fail = function (actual, expected, message, operator) {
    message = message || &#039;expect.fail()&#039;;
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, chai.expect.fail);
  };
};

},{}],8:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it&#039;s name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number || this instanceof Boolean ) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require(&#039;chai&#039;).should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, &#039;should&#039;, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, &#039;should&#039;, {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    /**
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace Should
     * @api public
     */

    should.fail = function (actual, expected, message, operator) {
      message = message || &#039;should.fail()&#039;;
      throw new chai.AssertionError(message, {
          actual: actual
        , expected: expected
        , operator: operator
      }, should.fail);
    };

    /**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (`==`) of `actual` and `expected`.
     *
     *     should.equal(3, &#039;3&#039;, &#039;== coerces values to strings&#039;);
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    /**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that `function` will throw an error that is an instance of
     * `constructor`, or alternately that it will throw an error with message
     * matching `regexp`.
     *
     *     should.throw(fn, &#039;function throws a reference error&#039;);
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, &#039;function throws a reference error&#039;);
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    /**
     * ### .exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var foo = &#039;hi&#039;;
     *
     *     should.exist(foo, &#039;foo exists&#039;);
     *
     * @name exist
     * @namespace Should
     * @api public
     */

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    /**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
     *
     *     should.not.equal(3, 4, &#039;these numbers are not equal&#039;);
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    /**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that `function` will _not_ throw an error that is an instance of
     * `constructor`, or alternately that it will not throw an error with message
     * matching `regexp`.
     *
     *     should.not.throw(fn, Error, &#039;function does not throw&#039;);
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    /**
     * ### .not.exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, &#039;bar does not exist&#039;);
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should[&#039;throw&#039;] = should[&#039;Throw&#039;];
    should.not[&#039;throw&#039;] = should.not[&#039;Throw&#039;];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

},{}],9:[function(require,module,exports){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = require(&#039;./transferFlags&#039;);
var flag = require(&#039;./flag&#039;);
var config = require(&#039;../config&#039;);

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
var hasProtoSupport = &#039;__proto__&#039; in Object;

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, &#039;foo&#039;, function (str) {
 *       var obj = utils.flag(this, &#039;object&#039;);
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod(&#039;foo&#039;, fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo(&#039;bar&#039;);
 *     expect(fooStr).to.be.foo.equal(&#039;foo&#039;);
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @namespace Utils
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== &#039;function&#039;) {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function assert() {
          var old_ssfi = flag(this, &#039;ssfi&#039;);
          if (old_ssfi &amp;&amp; config.includeStack === false)
            flag(this, &#039;ssfi&#039;, assert);
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use `__proto__` if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};

},{&quot;../config&quot;:4,&quot;./flag&quot;:13,&quot;./transferFlags&quot;:29}],10:[function(require,module,exports){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

var config = require(&#039;../config&#039;);

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, &#039;foo&#039;, function (str) {
 *       var obj = utils.flag(this, &#039;object&#039;);
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod(&#039;foo&#039;, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo(&#039;bar&#039;);
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @namespace Utils
 * @name addMethod
 * @api public
 */
var flag = require(&#039;./flag&#039;);

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var old_ssfi = flag(this, &#039;ssfi&#039;);
    if (old_ssfi &amp;&amp; config.includeStack === false)
      flag(this, &#039;ssfi&#039;, ctx[name]);
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{&quot;../config&quot;:4,&quot;./flag&quot;:13}],11:[function(require,module,exports){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

var config = require(&#039;../config&#039;);
var flag = require(&#039;./flag&#039;);

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, &#039;foo&#039;, function () {
 *       var obj = utils.flag(this, &#039;object&#039;);
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty(&#039;foo&#039;, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @namespace Utils
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function addProperty() {
        var old_ssfi = flag(this, &#039;ssfi&#039;);
        if (old_ssfi &amp;&amp; config.includeStack === false)
          flag(this, &#039;ssfi&#039;, addProperty);

        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{&quot;../config&quot;:4,&quot;./flag&quot;:13}],12:[function(require,module,exports){
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, [&#039;array&#039;, &#039;object&#039;, &#039;string&#039;]);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */

var AssertionError = require(&#039;assertion-error&#039;);
var flag = require(&#039;./flag&#039;);
var type = require(&#039;type-detect&#039;);

module.exports = function (obj, types) {
  var obj = flag(obj, &#039;object&#039;);
  types = types.map(function (t) { return t.toLowerCase(); });
  types.sort();

  // Transforms [&#039;lorem&#039;, &#039;ipsum&#039;] into &#039;a lirum, or an ipsum&#039;
  var str = types.map(function (t, index) {
    var art = ~[ &#039;a&#039;, &#039;e&#039;, &#039;i&#039;, &#039;o&#039;, &#039;u&#039; ].indexOf(t.charAt(0)) ? &#039;an&#039; : &#039;a&#039;;
    var or = types.length &gt; 1 &amp;&amp; index === types.length - 1 ? &#039;or &#039; : &#039;&#039;;
    return or + art + &#039; &#039; + t;
  }).join(&#039;, &#039;);

  if (!types.some(function (expected) { return type(obj) === expected; })) {
    throw new AssertionError(
      &#039;object tested must be &#039; + str + &#039;, but &#039; + type(obj) + &#039; given&#039;
    );
  }
};

},{&quot;./flag&quot;:13,&quot;assertion-error&quot;:30,&quot;type-detect&quot;:35}],13:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, &#039;foo&#039;, &#039;bar&#039;); // setter
 *     utils.flag(this, &#039;foo&#039;); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

},{}],14:[function(require,module,exports){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */

module.exports = function (obj, args) {
  return args.length &gt; 4 ? args[4] : obj._obj;
};

},{}],15:[function(require,module,exports){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

},{}],16:[function(require,module,exports){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require(&#039;./flag&#039;)
  , getActual = require(&#039;./getActual&#039;)
  , inspect = require(&#039;./inspect&#039;)
  , objDisplay = require(&#039;./objDisplay&#039;);

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, &#039;negate&#039;)
    , val = flag(obj, &#039;object&#039;)
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, &#039;message&#039;);

  if(typeof msg === &quot;function&quot;) msg = msg();
  msg = msg || &#039;&#039;;
  msg = msg
    .replace(/#\{this\}/g, function () { return objDisplay(val); })
    .replace(/#\{act\}/g, function () { return objDisplay(actual); })
    .replace(/#\{exp\}/g, function () { return objDisplay(expected); });

  return flagMsg ? flagMsg + &#039;: &#039; + msg : msg;
};

},{&quot;./flag&quot;:13,&quot;./getActual&quot;:14,&quot;./inspect&quot;:23,&quot;./objDisplay&quot;:24}],17:[function(require,module,exports){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 * @namespace Utils
 * @name getName
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match &amp;&amp; match[1] ? match[1] : &quot;&quot;;
};

},{}],18:[function(require,module,exports){
/*!
 * Chai - getPathInfo utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

var hasProperty = require(&#039;./hasProperty&#039;);

/**
 * ### .getPathInfo(path, object)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */

module.exports = function getPathInfo(path, obj) {
  var parsed = parsePath(path),
      last = parsed[parsed.length - 1];

  var info = {
    parent: parsed.length &gt; 1 ? _getPathValue(parsed, obj, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: _getPathValue(parsed, obj)
  };
  info.exists = hasProperty(info.name, info.parent);

  return info;
};


/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath(&#039;myobject.property.subprop&#039;);
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/([^\\])\[/g, &#039;$1.[&#039;)
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /^\[(\d+)\]$/
      , mArr = re.exec(value);
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value.replace(/\\([.\[\]])/g, &#039;$1&#039;) };
  });
}


/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @param {Number} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj, index) {
  var tmp = obj
    , res;

  index = (index === undefined ? parsed.length : index);

  for (var i = 0, l = index; i &lt; l; i++) {
    var part = parsed[i];
    if (tmp) {
      if (&#039;undefined&#039; !== typeof part.p)
        tmp = tmp[part.p];
      else if (&#039;undefined&#039; !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
}

},{&quot;./hasProperty&quot;:21}],19:[function(require,module,exports){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

var getPathInfo = require(&#039;./getPathInfo&#039;);

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;]
 *           , str: &#039;Hello&#039;
 *         }
 *       , prop2: {
 *             arr: [ { nested: &#039;Universe&#039; } ]
 *           , str: &#039;Hello again!&#039;
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue(&#039;prop1.str&#039;, obj); // Hello
 *     getPathValue(&#039;prop1.att[2]&#039;, obj); // b
 *     getPathValue(&#039;prop2.arr[0].nested&#039;, obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */
module.exports = function(path, obj) {
  var info = getPathInfo(path, obj);
  return info.value;
};

},{&quot;./getPathInfo&quot;:18}],20:[function(require,module,exports){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(object);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

},{}],21:[function(require,module,exports){
/*!
 * Chai - hasProperty utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

var type = require(&#039;type-detect&#039;);

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has
 * named property or numeric array index.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with natives
 * and null/undefined values.
 *
 *     var obj = {
 *         arr: [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;]
 *       , str: &#039;Hello&#039;
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty(&#039;str&#039;, obj);  // true
 *     hasProperty(&#039;constructor&#039;, obj);  // true
 *     hasProperty(&#039;bar&#039;, obj);  // false
 *
 *     hasProperty(&#039;length&#039;, obj.str); // true
 *     hasProperty(1, obj.str);  // true
 *     hasProperty(5, obj.str);  // false
 *
 *     hasProperty(&#039;length&#039;, obj.arr);  // true
 *     hasProperty(2, obj.arr);  // true
 *     hasProperty(3, obj.arr);  // false
 *
 * @param {Objuect} object
 * @param {String|Number} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */

var literals = {
    &#039;number&#039;: Number
  , &#039;string&#039;: String
};

module.exports = function hasProperty(name, obj) {
  var ot = type(obj);

  // Bad Object, obviously no props at all
  if(ot === &#039;null&#039; || ot === &#039;undefined&#039;)
    return false;

  // The `in` operator does not work with certain literals
  // box these before the check
  if(literals[ot] &amp;&amp; typeof obj !== &#039;object&#039;)
    obj = new literals[ot](obj);

  return name in obj;
};

},{&quot;type-detect&quot;:35}],22:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = require(&#039;./test&#039;);

/*!
 * type utility
 */

exports.type = require(&#039;type-detect&#039;);

/*!
 * expectTypes utility
 */
exports.expectTypes = require(&#039;./expectTypes&#039;);

/*!
 * message utility
 */

exports.getMessage = require(&#039;./getMessage&#039;);

/*!
 * actual utility
 */

exports.getActual = require(&#039;./getActual&#039;);

/*!
 * Inspect util
 */

exports.inspect = require(&#039;./inspect&#039;);

/*!
 * Object Display util
 */

exports.objDisplay = require(&#039;./objDisplay&#039;);

/*!
 * Flag utility
 */

exports.flag = require(&#039;./flag&#039;);

/*!
 * Flag transferring utility
 */

exports.transferFlags = require(&#039;./transferFlags&#039;);

/*!
 * Deep equal utility
 */

exports.eql = require(&#039;deep-eql&#039;);

/*!
 * Deep path value
 */

exports.getPathValue = require(&#039;./getPathValue&#039;);

/*!
 * Deep path info
 */

exports.getPathInfo = require(&#039;./getPathInfo&#039;);

/*!
 * Check if a property exists
 */

exports.hasProperty = require(&#039;./hasProperty&#039;);

/*!
 * Function name
 */

exports.getName = require(&#039;./getName&#039;);

/*!
 * add Property
 */

exports.addProperty = require(&#039;./addProperty&#039;);

/*!
 * add Method
 */

exports.addMethod = require(&#039;./addMethod&#039;);

/*!
 * overwrite Property
 */

exports.overwriteProperty = require(&#039;./overwriteProperty&#039;);

/*!
 * overwrite Method
 */

exports.overwriteMethod = require(&#039;./overwriteMethod&#039;);

/*!
 * Add a chainable method
 */

exports.addChainableMethod = require(&#039;./addChainableMethod&#039;);

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require(&#039;./overwriteChainableMethod&#039;);

},{&quot;./addChainableMethod&quot;:9,&quot;./addMethod&quot;:10,&quot;./addProperty&quot;:11,&quot;./expectTypes&quot;:12,&quot;./flag&quot;:13,&quot;./getActual&quot;:14,&quot;./getMessage&quot;:16,&quot;./getName&quot;:17,&quot;./getPathInfo&quot;:18,&quot;./getPathValue&quot;:19,&quot;./hasProperty&quot;:21,&quot;./inspect&quot;:23,&quot;./objDisplay&quot;:24,&quot;./overwriteChainableMethod&quot;:25,&quot;./overwriteMethod&quot;:26,&quot;./overwriteProperty&quot;:27,&quot;./test&quot;:28,&quot;./transferFlags&quot;:29,&quot;deep-eql&quot;:31,&quot;type-detect&quot;:35}],23:[function(require,module,exports){
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = require(&#039;./getName&#039;);
var getProperties = require(&#039;./getProperties&#039;);
var getEnumerableProperties = require(&#039;./getEnumerableProperties&#039;);

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 * @namespace Utils
 * @name inspect
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === &#039;undefined&#039; ? 2 : depth));
}

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === &#039;object&#039;) {
    return object instanceof HTMLElement;
  } else {
    return object &amp;&amp;
      typeof object === &#039;object&#039; &amp;&amp;
      object.nodeType === 1 &amp;&amp;
      typeof object.nodeName === &#039;string&#039;;
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value &amp;&amp; typeof value.inspect === &#039;function&#039; &amp;&amp;
      // Filter out the util module, it&#039;s inspect function is special
      value.inspect !== exports.inspect &amp;&amp;
      // Also filter out any prototype objects using the circular check.
      !(value.constructor &amp;&amp; value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== &#039;string&#039;) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If this is a DOM element, try to get the outer HTML.
  if (isDOMElement(value)) {
    if (&#039;outerHTML&#039; in value) {
      return value.outerHTML;
      // This value does not have an outerHTML attribute,
      //   it could still be an XML element
    } else {
      // Attempt to serialize it
      try {
        if (document.xmlVersion) {
          var xmlSerializer = new XMLSerializer();
          return xmlSerializer.serializeToString(value);
        } else {
          // Firefox 11- do not support outerHTML
          //   It does, however, support innerHTML
          //   Use the following to render the element
          var ns = &quot;http://www.w3.org/1999/xhtml&quot;;
          var container = document.createElementNS(ns, &#039;_&#039;);

          container.appendChild(value.cloneNode(false));
          html = container.innerHTML
            .replace(&#039;&gt;&lt;&#039;, &#039;&gt;&#039; + value.innerHTML + &#039;&lt;&#039;);
          container.innerHTML = &#039;&#039;;
          return html;
        }
      } catch (err) {
        // This could be a non-native DOM implementation,
        //   continue with the normal flow:
        //   printing the element as if it is an object.
      }
    }
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) &amp;&amp; (
      (keys.length === 1 &amp;&amp; keys[0] === &#039;stack&#039;) ||
      (keys.length === 2 &amp;&amp; keys[0] === &#039;description&#039; &amp;&amp; keys[1] === &#039;stack&#039;)
     ))) {
    if (typeof value === &#039;function&#039;) {
      var name = getName(value);
      var nameSuffix = name ? &#039;: &#039; + name : &#039;&#039;;
      return ctx.stylize(&#039;[Function&#039; + nameSuffix + &#039;]&#039;, &#039;special&#039;);
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), &#039;regexp&#039;);
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), &#039;date&#039;);
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = &#039;&#039;, array = false, braces = [&#039;{&#039;, &#039;}&#039;];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = [&#039;[&#039;, &#039;]&#039;];
  }

  // Make functions say that they are functions
  if (typeof value === &#039;function&#039;) {
    var name = getName(value);
    var nameSuffix = name ? &#039;: &#039; + name : &#039;&#039;;
    base = &#039; [Function&#039; + nameSuffix + &#039;]&#039;;
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = &#039; &#039; + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = &#039; &#039; + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 &amp;&amp; (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes &lt; 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), &#039;regexp&#039;);
    } else {
      return ctx.stylize(&#039;[Object]&#039;, &#039;special&#039;);
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case &#039;undefined&#039;:
      return ctx.stylize(&#039;undefined&#039;, &#039;undefined&#039;);

    case &#039;string&#039;:
      var simple = &#039;\&#039;&#039; + JSON.stringify(value).replace(/^&quot;|&quot;$/g, &#039;&#039;)
                                               .replace(/&#039;/g, &quot;\\&#039;&quot;)
                                               .replace(/\\&quot;/g, &#039;&quot;&#039;) + &#039;\&#039;&#039;;
      return ctx.stylize(simple, &#039;string&#039;);

    case &#039;number&#039;:
      if (value === 0 &amp;&amp; (1/value) === -Infinity) {
        return ctx.stylize(&#039;-0&#039;, &#039;number&#039;);
      }
      return ctx.stylize(&#039;&#039; + value, &#039;number&#039;);

    case &#039;boolean&#039;:
      return ctx.stylize(&#039;&#039; + value, &#039;boolean&#039;);
  }
  // For some reason typeof null is &quot;object&quot;, so special case here.
  if (value === null) {
    return ctx.stylize(&#039;null&#039;, &#039;null&#039;);
  }
}


function formatError(value) {
  return &#039;[&#039; + Error.prototype.toString.call(value) + &#039;]&#039;;
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i &lt; l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push(&#039;&#039;);
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize(&#039;[Getter/Setter]&#039;, &#039;special&#039;);
      } else {
        str = ctx.stylize(&#039;[Getter]&#039;, &#039;special&#039;);
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize(&#039;[Setter]&#039;, &#039;special&#039;);
      }
    }
  }
  if (visibleKeys.indexOf(key) &lt; 0) {
    name = &#039;[&#039; + key + &#039;]&#039;;
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) &lt; 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf(&#039;\n&#039;) &gt; -1) {
        if (array) {
          str = str.split(&#039;\n&#039;).map(function(line) {
            return &#039;  &#039; + line;
          }).join(&#039;\n&#039;).substr(2);
        } else {
          str = &#039;\n&#039; + str.split(&#039;\n&#039;).map(function(line) {
            return &#039;   &#039; + line;
          }).join(&#039;\n&#039;);
        }
      }
    } else {
      str = ctx.stylize(&#039;[Circular]&#039;, &#039;special&#039;);
    }
  }
  if (typeof name === &#039;undefined&#039;) {
    if (array &amp;&amp; key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify(&#039;&#039; + key);
    if (name.match(/^&quot;([a-zA-Z_][a-zA-Z_0-9]*)&quot;$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, &#039;name&#039;);
    } else {
      name = name.replace(/&#039;/g, &quot;\\&#039;&quot;)
                 .replace(/\\&quot;/g, &#039;&quot;&#039;)
                 .replace(/(^&quot;|&quot;$)/g, &quot;&#039;&quot;);
      name = ctx.stylize(name, &#039;string&#039;);
    }
  }

  return name + &#039;: &#039; + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf(&#039;\n&#039;) &gt;= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length &gt; 60) {
    return braces[0] +
           (base === &#039;&#039; ? &#039;&#039; : base + &#039;\n &#039;) +
           &#039; &#039; +
           output.join(&#039;,\n  &#039;) +
           &#039; &#039; +
           braces[1];
  }

  return braces[0] + base + &#039; &#039; + output.join(&#039;, &#039;) + &#039; &#039; + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === &#039;object&#039; &amp;&amp; objectToString(ar) === &#039;[object Array]&#039;);
}

function isRegExp(re) {
  return typeof re === &#039;object&#039; &amp;&amp; objectToString(re) === &#039;[object RegExp]&#039;;
}

function isDate(d) {
  return typeof d === &#039;object&#039; &amp;&amp; objectToString(d) === &#039;[object Date]&#039;;
}

function isError(e) {
  return typeof e === &#039;object&#039; &amp;&amp; objectToString(e) === &#039;[object Error]&#039;;
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{&quot;./getEnumerableProperties&quot;:15,&quot;./getName&quot;:17,&quot;./getProperties&quot;:20}],24:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = require(&#039;./inspect&#039;);
var config = require(&#039;../config&#039;);

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @namespace Utils
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold &amp;&amp; str.length &gt;= config.truncateThreshold) {
    if (type === &#039;[object Function]&#039;) {
      return !obj.name || obj.name === &#039;&#039;
        ? &#039;[Function]&#039;
        : &#039;[Function: &#039; + obj.name + &#039;]&#039;;
    } else if (type === &#039;[object Array]&#039;) {
      return &#039;[ Array(&#039; + obj.length + &#039;) ]&#039;;
    } else if (type === &#039;[object Object]&#039;) {
      var keys = Object.keys(obj)
        , kstr = keys.length &gt; 2
          ? keys.splice(0, 2).join(&#039;, &#039;) + &#039;, ...&#039;
          : keys.join(&#039;, &#039;);
      return &#039;{ Object (&#039; + kstr + &#039;) }&#039;;
    } else {
      return str;
    }
  } else {
    return str;
  }
};

},{&quot;../config&quot;:4,&quot;./inspect&quot;:23}],25:[function(require,module,exports){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, &#039;length&#039;,
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod(&#039;foo&#039;, fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @namespace Utils
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{}],26:[function(require,module,exports){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, &#039;equal&#039;, function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, &#039;object&#039;);
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod(&#039;foo&#039;, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal(&#039;bar&#039;);
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @namespace Utils
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method &amp;&amp; &#039;function&#039; === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};

},{}],27:[function(require,module,exports){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, &#039;ok&#039;, function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, &#039;object&#039;);
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal(&#039;bar&#039;);
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty(&#039;foo&#039;, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @namespace Utils
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get &amp;&amp; &#039;function&#039; === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],28:[function(require,module,exports){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require(&#039;./flag&#039;);

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */

module.exports = function (obj, args) {
  var negate = flag(obj, &#039;negate&#039;)
    , expr = args[0];
  return negate ? !expr : expr;
};

},{&quot;./flag&quot;:13}],29:[function(require,module,exports){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== &#039;object&#039; &amp;&amp; flag !== &#039;ssfi&#039; &amp;&amp; flag != &#039;message&#039;)) {
      object.__flags[flag] = flags[flag];
    }
  }
};

},{}],30:[function(require,module,exports){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer &lt;jake@qualiancy.com&gt;
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i &lt; args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude(&#039;name&#039;, &#039;message&#039;, &#039;stack&#039;, &#039;constructor&#039;, &#039;toJSON&#039;)
    , props = extend(_props || {});

  // default values
  this.message = message || &#039;Unspecified AssertionError&#039;;
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || arguments.callee;
  if (ssf &amp;&amp; Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  } else {
    this.stack = new Error().stack;
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = &#039;AssertionError&#039;;

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude(&#039;constructor&#039;, &#039;toJSON&#039;, &#039;stack&#039;)
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack &amp;&amp; this.stack) {
    props.stack = this.stack;
  }

  return props;
};

},{}],31:[function(require,module,exports){
module.exports = require(&#039;./lib/eql&#039;);

},{&quot;./lib/eql&quot;:32}],32:[function(require,module,exports){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = require(&#039;type-detect&#039;);

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = require(&#039;buffer&#039;).Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if (&#039;date&#039; === type(a)) {
    return dateEqual(a, b);
  } else if (&#039;regexp&#039; === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if (&#039;arguments&#039; === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if ((&#039;object&#039; !== type(a) &amp;&amp; &#039;object&#039; !== type(b))
  &amp;&amp; (&#039;array&#039; !== type(a) &amp;&amp; &#039;array&#039; !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a &amp;&amp; b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if (&#039;date&#039; !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if (&#039;regexp&#039; !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if (&#039;arguments&#039; !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i &lt; a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don&#039;t get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null &amp;&amp; a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i &lt; m.length; i++) {
      if ((m[i][0] === a &amp;&amp; m[i][1] === b)
      ||  (m[i][0] === b &amp;&amp; m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i &gt;= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}

},{&quot;buffer&quot;:undefined,&quot;type-detect&quot;:33}],33:[function(require,module,exports){
module.exports = require(&#039;./lib/type&#039;);

},{&quot;./lib/type&quot;:34}],34:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    &#039;[object Array]&#039;: &#039;array&#039;
  , &#039;[object RegExp]&#039;: &#039;regexp&#039;
  , &#039;[object Function]&#039;: &#039;function&#039;
  , &#039;[object Arguments]&#039;: &#039;arguments&#039;
  , &#039;[object Date]&#039;: &#039;date&#039;
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return &#039;null&#039;;
  if (obj === undefined) return &#039;undefined&#039;;
  if (obj === Object(obj)) return &#039;object&#039;;
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if (&#039;string&#039; === lib.of(&#039;hello world&#039;)) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define(&#039;int&#039;, /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define(&#039;bln&#039;, function (obj) {
 *   if (&#039;boolean&#039; === lib.of(obj)) return true;
 *   var blns = [ &#039;yes&#039;, &#039;no&#039;, &#039;true&#039;, &#039;false&#039;, 1, 0 ];
 *   if (&#039;string&#039; === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test(&#039;1&#039;, &#039;int&#039;));
 * assert(lib.test(&#039;yes&#039;, &#039;bln&#039;));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test &amp;&amp; &#039;regexp&#039; === getType(test)) {
    return test.test(obj);
  } else if (test &amp;&amp; &#039;function&#039; === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError(&#039;Type test &quot;&#039; + type + &#039;&quot; not defined or invalid.&#039;);
  }
};

},{}],35:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{&quot;./lib/type&quot;:36,&quot;dup&quot;:33}],36:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */
var objectTypeRegexp = /^\[object (.*)\]$/;

function getType(obj) {
  var type = Object.prototype.toString.call(obj).match(objectTypeRegexp)[1].toLowerCase();
  // Let &quot;new String(&#039;&#039;)&quot; return &#039;object&#039;
  if (typeof Promise === &#039;function&#039; &amp;&amp; obj instanceof Promise) return &#039;promise&#039;;
  // PhantomJS has type &quot;DOMWindow&quot; for null
  if (obj === null) return &#039;null&#039;;
  // PhantomJS has type &quot;DOMWindow&quot; for undefined
  if (obj === undefined) return &#039;undefined&#039;;
  return type;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library() {
  if (!(this instanceof Library)) return new Library();
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if (&#039;string&#039; === lib.of(&#039;hello world&#039;)) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define(&#039;int&#039;, /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define(&#039;bln&#039;, function (obj) {
 *   if (&#039;boolean&#039; === lib.of(obj)) return true;
 *   var blns = [ &#039;yes&#039;, &#039;no&#039;, &#039;true&#039;, &#039;false&#039;, 1, 0 ];
 *   if (&#039;string&#039; === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function(type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test(&#039;1&#039;, &#039;int&#039;));
 * assert(lib.test(&#039;yes&#039;, &#039;bln&#039;));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function(obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test &amp;&amp; &#039;regexp&#039; === getType(test)) {
    return test.test(obj);
  } else if (test &amp;&amp; &#039;function&#039; === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError(&#039;Type test &quot;&#039; + type + &#039;&quot; not defined or invalid.&#039;);
  }
};

},{}]},{},[1])(1)
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
