<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/babylon/lib/plugins/flow.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/babylon/lib/plugins/flow.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.02</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1233</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">135.34</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">15.62</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

exports.__esModule = true;

exports.default = function (instance) {
  // plain function return types: function name(): string {}
  instance.extend(&quot;parseFunctionBody&quot;, function (inner) {
    return function (node, allowExpression) {
      if (this.match(_types.types.colon) &amp;&amp; !allowExpression) {
        // if allowExpression is true then we&#039;re parsing an arrow function and if
        // there&#039;s a return type then it&#039;s been handled elsewhere
        node.returnType = this.flowParseTypeAnnotation();
      }

      return inner.call(this, node, allowExpression);
    };
  });

  // interfaces
  instance.extend(&quot;parseStatement&quot;, function (inner) {
    return function (declaration, topLevel) {
      // strict mode handling of `interface` since it&#039;s a reserved word
      if (this.state.strict &amp;&amp; this.match(_types.types.name) &amp;&amp; this.state.value === &quot;interface&quot;) {
        var node = this.startNode();
        this.next();
        return this.flowParseInterface(node);
      } else {
        return inner.call(this, declaration, topLevel);
      }
    };
  });

  // declares, interfaces and type aliases
  instance.extend(&quot;parseExpressionStatement&quot;, function (inner) {
    return function (node, expr) {
      if (expr.type === &quot;Identifier&quot;) {
        if (expr.name === &quot;declare&quot;) {
          if (this.match(_types.types._class) || this.match(_types.types.name) || this.match(_types.types._function) || this.match(_types.types._var)) {
            return this.flowParseDeclare(node);
          }
        } else if (this.match(_types.types.name)) {
          if (expr.name === &quot;interface&quot;) {
            return this.flowParseInterface(node);
          } else if (expr.name === &quot;type&quot;) {
            return this.flowParseTypeAlias(node);
          }
        }
      }

      return inner.call(this, node, expr);
    };
  });

  // export type
  instance.extend(&quot;shouldParseExportDeclaration&quot;, function (inner) {
    return function () {
      return this.isContextual(&quot;type&quot;) || this.isContextual(&quot;interface&quot;) || inner.call(this);
    };
  });

  instance.extend(&quot;parseConditional&quot;, function (inner) {
    return function (expr, noIn, startPos, startLoc, refNeedsArrowPos) {
      // only do the expensive clone if there is a question mark
      // and if we come from inside parens
      if (refNeedsArrowPos &amp;&amp; this.match(_types.types.question)) {
        var state = this.state.clone();
        try {
          return inner.call(this, expr, noIn, startPos, startLoc);
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
            refNeedsArrowPos.start = err.pos || this.state.start;
            return expr;
          } else {
            throw err;
          }
        }
      }

      return inner.call(this, expr, noIn, startPos, startLoc);
    };
  });

  instance.extend(&quot;parseParenItem&quot;, function (inner) {
    return function (node, startLoc, startPos) {
      node = inner.call(this, node, startLoc, startPos);
      if (this.eat(_types.types.question)) {
        node.optional = true;
      }

      if (this.match(_types.types.colon)) {
        var typeCastNode = this.startNodeAt(startLoc, startPos);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();

        return this.finishNode(typeCastNode, &quot;TypeCastExpression&quot;);
      }

      return node;
    };
  });

  instance.extend(&quot;parseExport&quot;, function (inner) {
    return function (node) {
      node = inner.call(this, node);
      if (node.type === &quot;ExportNamedDeclaration&quot;) {
        node.exportKind = node.exportKind || &quot;value&quot;;
      }
      return node;
    };
  });

  instance.extend(&quot;parseExportDeclaration&quot;, function (inner) {
    return function (node) {
      if (this.isContextual(&quot;type&quot;)) {
        node.exportKind = &quot;type&quot;;

        var declarationNode = this.startNode();
        this.next();

        if (this.match(_types.types.braceL)) {
          // export type { foo, bar };
          node.specifiers = this.parseExportSpecifiers();
          this.parseExportFrom(node);
          return null;
        } else {
          // export type Foo = Bar;
          return this.flowParseTypeAlias(declarationNode);
        }
      } else if (this.isContextual(&quot;interface&quot;)) {
        node.exportKind = &quot;type&quot;;
        var _declarationNode = this.startNode();
        this.next();
        return this.flowParseInterface(_declarationNode);
      } else {
        return inner.call(this, node);
      }
    };
  });

  instance.extend(&quot;parseClassId&quot;, function (inner) {
    return function (node) {
      inner.apply(this, arguments);
      if (this.isRelational(&quot;&lt;&quot;)) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
    };
  });

  // don&#039;t consider `void` to be a keyword as then it&#039;ll use the void token type
  // and set startExpr
  instance.extend(&quot;isKeyword&quot;, function (inner) {
    return function (name) {
      if (this.state.inType &amp;&amp; name === &quot;void&quot;) {
        return false;
      } else {
        return inner.call(this, name);
      }
    };
  });

  // ensure that inside flow types, we bypass the jsx parser plugin
  instance.extend(&quot;readToken&quot;, function (inner) {
    return function (code) {
      if (this.state.inType &amp;&amp; (code === 62 || code === 60)) {
        return this.finishOp(_types.types.relational, 1);
      } else {
        return inner.call(this, code);
      }
    };
  });

  // don&#039;t lex any token as a jsx one inside a flow type
  instance.extend(&quot;jsx_readToken&quot;, function (inner) {
    return function () {
      if (!this.state.inType) return inner.call(this);
    };
  });

  instance.extend(&quot;toAssignable&quot;, function (inner) {
    return function (node, isBinding) {
      if (node.type === &quot;TypeCastExpression&quot;) {
        return inner.call(this, this.typeCastToParameter(node), isBinding);
      } else {
        return inner.call(this, node, isBinding);
      }
    };
  });

  // turn type casts that we found in function parameter head into type annotated params
  instance.extend(&quot;toAssignableList&quot;, function (inner) {
    return function (exprList, isBinding) {
      for (var i = 0; i &lt; exprList.length; i++) {
        var expr = exprList[i];
        if (expr &amp;&amp; expr.type === &quot;TypeCastExpression&quot;) {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }
      return inner.call(this, exprList, isBinding);
    };
  });

  // this is a list of nodes, from something like a call expression, we need to filter the
  // type casts that we&#039;ve found that are illegal in this context
  instance.extend(&quot;toReferencedList&quot;, function () {
    return function (exprList) {
      for (var i = 0; i &lt; exprList.length; i++) {
        var expr = exprList[i];
        if (expr &amp;&amp; expr._exprListItem &amp;&amp; expr.type === &quot;TypeCastExpression&quot;) {
          this.raise(expr.start, &quot;Unexpected type cast&quot;);
        }
      }

      return exprList;
    };
  });

  // parse an item inside a expression list eg. `(NODE, NODE)` where NODE represents
  // the position where this function is called
  instance.extend(&quot;parseExprListItem&quot;, function (inner) {
    return function (allowEmpty, refShorthandDefaultPos) {
      var container = this.startNode();
      var node = inner.call(this, allowEmpty, refShorthandDefaultPos);
      if (this.match(_types.types.colon)) {
        container._exprListItem = true;
        container.expression = node;
        container.typeAnnotation = this.flowParseTypeAnnotation();
        return this.finishNode(container, &quot;TypeCastExpression&quot;);
      } else {
        return node;
      }
    };
  });

  instance.extend(&quot;checkLVal&quot;, function (inner) {
    return function (node) {
      if (node.type !== &quot;TypeCastExpression&quot;) {
        return inner.apply(this, arguments);
      }
    };
  });

  // parse class property type annotations
  instance.extend(&quot;parseClassProperty&quot;, function (inner) {
    return function (node) {
      if (this.match(_types.types.colon)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return inner.call(this, node);
    };
  });

  // determine whether or not we&#039;re currently in the position where a class property would appear
  instance.extend(&quot;isClassProperty&quot;, function (inner) {
    return function () {
      return this.match(_types.types.colon) || inner.call(this);
    };
  });

  // parse type parameters for class methods
  instance.extend(&quot;parseClassMethod&quot;, function () {
    return function (classBody, method, isGenerator, isAsync) {
      if (this.isRelational(&quot;&lt;&quot;)) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      this.parseMethod(method, isGenerator, isAsync);
      classBody.body.push(this.finishNode(method, &quot;ClassMethod&quot;));
    };
  });

  // parse a the super class type parameters and implements
  instance.extend(&quot;parseClassSuper&quot;, function (inner) {
    return function (node, isStatement) {
      inner.call(this, node, isStatement);
      if (node.superClass &amp;&amp; this.isRelational(&quot;&lt;&quot;)) {
        node.superTypeParameters = this.flowParseTypeParameterInstantiation();
      }
      if (this.isContextual(&quot;implements&quot;)) {
        this.next();
        var implemented = node.implements = [];
        do {
          var _node = this.startNode();
          _node.id = this.parseIdentifier();
          if (this.isRelational(&quot;&lt;&quot;)) {
            _node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            _node.typeParameters = null;
          }
          implemented.push(this.finishNode(_node, &quot;ClassImplements&quot;));
        } while (this.eat(_types.types.comma));
      }
    };
  });

  // parse type parameters for object method shorthand
  instance.extend(&quot;parseObjPropValue&quot;, function (inner) {
    return function (prop) {
      var typeParameters = void 0;

      // method shorthand
      if (this.isRelational(&quot;&lt;&quot;)) {
        typeParameters = this.flowParseTypeParameterDeclaration();
        if (!this.match(_types.types.parenL)) this.unexpected();
      }

      inner.apply(this, arguments);

      // add typeParameters if we found them
      if (typeParameters) {
        (prop.value || prop).typeParameters = typeParameters;
      }
    };
  });

  instance.extend(&quot;parseAssignableListItemTypes&quot;, function () {
    return function (param) {
      if (this.eat(_types.types.question)) {
        param.optional = true;
      }
      if (this.match(_types.types.colon)) {
        param.typeAnnotation = this.flowParseTypeAnnotation();
      }
      this.finishNode(param, param.type);
      return param;
    };
  });

  instance.extend(&quot;parseMaybeDefault&quot;, function (inner) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key &lt; _len; _key++) {
        args[_key] = arguments[_key];
      }

      var node = inner.apply(this, args);

      if (node.type === &quot;AssignmentPattern&quot; &amp;&amp; node.typeAnnotation &amp;&amp; node.right.start &lt; node.typeAnnotation.start) {
        this.raise(node.typeAnnotation.start, &quot;Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`&quot;);
      }

      return node;
    };
  });

  // parse typeof and type imports
  instance.extend(&quot;parseImportSpecifiers&quot;, function (inner) {
    return function (node) {
      node.importKind = &quot;value&quot;;

      var kind = null;
      if (this.match(_types.types._typeof)) {
        kind = &quot;typeof&quot;;
      } else if (this.isContextual(&quot;type&quot;)) {
        kind = &quot;type&quot;;
      }
      if (kind) {
        var lh = this.lookahead();
        if (lh.type === _types.types.name &amp;&amp; lh.value !== &quot;from&quot; || lh.type === _types.types.braceL || lh.type === _types.types.star) {
          this.next();
          node.importKind = kind;
        }
      }

      inner.call(this, node);
    };
  });

  // parse function type parameters - function foo&lt;T&gt;() {}
  instance.extend(&quot;parseFunctionParams&quot;, function (inner) {
    return function (node) {
      if (this.isRelational(&quot;&lt;&quot;)) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      inner.call(this, node);
    };
  });

  // parse flow type annotations on variable declarator heads - let foo: string = bar
  instance.extend(&quot;parseVarHead&quot;, function (inner) {
    return function (decl) {
      inner.call(this, decl);
      if (this.match(_types.types.colon)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
        this.finishNode(decl.id, decl.id.type);
      }
    };
  });

  // parse the return type of an async arrow function - let foo = (async (): number =&gt; {});
  instance.extend(&quot;parseAsyncArrowFromCallExpression&quot;, function (inner) {
    return function (node, call) {
      if (this.match(_types.types.colon)) {
        node.returnType = this.flowParseTypeAnnotation();
      }

      return inner.call(this, node, call);
    };
  });

  // todo description
  instance.extend(&quot;shouldParseAsyncArrow&quot;, function (inner) {
    return function () {
      return this.match(_types.types.colon) || inner.call(this);
    };
  });

  // We need to support type parameter declarations for arrow functions. This
  // is tricky. There are three situations we need to handle
  //
  // 1. This is either JSX or an arrow function. We&#039;ll try JSX first. If that
  //    fails, we&#039;ll try an arrow function. If that fails, we&#039;ll throw the JSX
  //    error.
  // 2. This is an arrow function. We&#039;ll parse the type parameter declaration,
  //    parse the rest, make sure the rest is an arrow function, and go from
  //    there
  // 3. This is neither. Just call the inner function
  instance.extend(&quot;parseMaybeAssign&quot;, function (inner) {
    return function () {
      var jsxError = null;

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 &lt; _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (_types.types.jsxTagStart &amp;&amp; this.match(_types.types.jsxTagStart)) {
        var state = this.state.clone();
        try {
          return inner.apply(this, args);
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
            jsxError = err;
          } else {
            throw err;
          }
        }
      }

      // Need to push something onto the context to stop
      // the JSX plugin from messing with the tokens
      this.state.context.push(_context.types.parenExpression);
      if (jsxError != null || this.isRelational(&quot;&lt;&quot;)) {
        var arrowExpression = void 0;
        var typeParameters = void 0;
        try {
          typeParameters = this.flowParseTypeParameterDeclaration();

          arrowExpression = inner.apply(this, args);
          arrowExpression.typeParameters = typeParameters;
          arrowExpression.start = typeParameters.start;
          arrowExpression.loc.start = typeParameters.loc.start;
        } catch (err) {
          throw jsxError || err;
        }

        if (arrowExpression.type === &quot;ArrowFunctionExpression&quot;) {
          return arrowExpression;
        } else if (jsxError != null) {
          throw jsxError;
        } else {
          this.raise(typeParameters.start, &quot;Expected an arrow function after this type parameter declaration&quot;);
        }
      }
      this.state.context.pop();

      return inner.apply(this, args);
    };
  });

  // handle return types for arrow functions
  instance.extend(&quot;parseArrow&quot;, function (inner) {
    return function (node) {
      if (this.match(_types.types.colon)) {
        var state = this.state.clone();
        try {
          var returnType = this.flowParseTypeAnnotation();
          if (this.canInsertSemicolon()) this.unexpected();
          if (!this.match(_types.types.arrow)) this.unexpected();
          // assign after it is clear it is an arrow
          node.returnType = returnType;
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
          } else {
            throw err;
          }
        }
      }

      return inner.call(this, node);
    };
  });

  instance.extend(&quot;shouldParseArrow&quot;, function (inner) {
    return function () {
      return this.match(_types.types.colon) || inner.call(this);
    };
  });

  instance.extend(&quot;isClassMutatorStarter&quot;, function (inner) {
    return function () {
      if (this.isRelational(&quot;&lt;&quot;)) {
        return true;
      } else {
        return inner.call(this);
      }
    };
  });
};

var _types = require(&quot;../tokenizer/types&quot;);

var _context = require(&quot;../tokenizer/context&quot;);

var _parser = require(&quot;../parser&quot;);

var _parser2 = _interopRequireDefault(_parser);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

var pp = _parser2.default.prototype; /* eslint indent: 0 */
/* eslint max-len: 0 */

pp.flowParseTypeInitialiser = function (tok, allowLeadingPipeOrAnd) {
  var oldInType = this.state.inType;
  this.state.inType = true;
  this.expect(tok || _types.types.colon);
  if (allowLeadingPipeOrAnd) {
    if (this.match(_types.types.bitwiseAND) || this.match(_types.types.bitwiseOR)) {
      this.next();
    }
  }
  var type = this.flowParseType();
  this.state.inType = oldInType;
  return type;
};

pp.flowParseDeclareClass = function (node) {
  this.next();
  this.flowParseInterfaceish(node, true);
  return this.finishNode(node, &quot;DeclareClass&quot;);
};

pp.flowParseDeclareFunction = function (node) {
  this.next();

  var id = node.id = this.parseIdentifier();

  var typeNode = this.startNode();
  var typeContainer = this.startNode();

  if (this.isRelational(&quot;&lt;&quot;)) {
    typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    typeNode.typeParameters = null;
  }

  this.expect(_types.types.parenL);
  var tmp = this.flowParseFunctionTypeParams();
  typeNode.params = tmp.params;
  typeNode.rest = tmp.rest;
  this.expect(_types.types.parenR);
  typeNode.returnType = this.flowParseTypeInitialiser();

  typeContainer.typeAnnotation = this.finishNode(typeNode, &quot;FunctionTypeAnnotation&quot;);
  id.typeAnnotation = this.finishNode(typeContainer, &quot;TypeAnnotation&quot;);

  this.finishNode(id, id.type);

  this.semicolon();

  return this.finishNode(node, &quot;DeclareFunction&quot;);
};

pp.flowParseDeclare = function (node) {
  if (this.match(_types.types._class)) {
    return this.flowParseDeclareClass(node);
  } else if (this.match(_types.types._function)) {
    return this.flowParseDeclareFunction(node);
  } else if (this.match(_types.types._var)) {
    return this.flowParseDeclareVariable(node);
  } else if (this.isContextual(&quot;module&quot;)) {
    if (this.lookahead().type === _types.types.dot) {
      return this.flowParseDeclareModuleExports(node);
    } else {
      return this.flowParseDeclareModule(node);
    }
  } else if (this.isContextual(&quot;type&quot;)) {
    return this.flowParseDeclareTypeAlias(node);
  } else if (this.isContextual(&quot;interface&quot;)) {
    return this.flowParseDeclareInterface(node);
  } else {
    this.unexpected();
  }
};

pp.flowParseDeclareVariable = function (node) {
  this.next();
  node.id = this.flowParseTypeAnnotatableIdentifier();
  this.semicolon();
  return this.finishNode(node, &quot;DeclareVariable&quot;);
};

pp.flowParseDeclareModule = function (node) {
  this.next();

  if (this.match(_types.types.string)) {
    node.id = this.parseExprAtom();
  } else {
    node.id = this.parseIdentifier();
  }

  var bodyNode = node.body = this.startNode();
  var body = bodyNode.body = [];
  this.expect(_types.types.braceL);
  while (!this.match(_types.types.braceR)) {
    var node2 = this.startNode();

    this.expectContextual(&quot;declare&quot;, &quot;Unexpected token. Only declares are allowed inside declare module&quot;);

    body.push(this.flowParseDeclare(node2));
  }
  this.expect(_types.types.braceR);

  this.finishNode(bodyNode, &quot;BlockStatement&quot;);
  return this.finishNode(node, &quot;DeclareModule&quot;);
};

pp.flowParseDeclareModuleExports = function (node) {
  this.expectContextual(&quot;module&quot;);
  this.expect(_types.types.dot);
  this.expectContextual(&quot;exports&quot;);
  node.typeAnnotation = this.flowParseTypeAnnotation();
  return this.finishNode(node, &quot;DeclareModuleExports&quot;);
};

pp.flowParseDeclareTypeAlias = function (node) {
  this.next();
  this.flowParseTypeAlias(node);
  return this.finishNode(node, &quot;DeclareTypeAlias&quot;);
};

pp.flowParseDeclareInterface = function (node) {
  this.next();
  this.flowParseInterfaceish(node);
  return this.finishNode(node, &quot;DeclareInterface&quot;);
};

// Interfaces

pp.flowParseInterfaceish = function (node, allowStatic) {
  node.id = this.parseIdentifier();

  if (this.isRelational(&quot;&lt;&quot;)) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    node.typeParameters = null;
  }

  node.extends = [];
  node.mixins = [];

  if (this.eat(_types.types._extends)) {
    do {
      node.extends.push(this.flowParseInterfaceExtends());
    } while (this.eat(_types.types.comma));
  }

  if (this.isContextual(&quot;mixins&quot;)) {
    this.next();
    do {
      node.mixins.push(this.flowParseInterfaceExtends());
    } while (this.eat(_types.types.comma));
  }

  node.body = this.flowParseObjectType(allowStatic);
};

pp.flowParseInterfaceExtends = function () {
  var node = this.startNode();

  node.id = this.flowParseQualifiedTypeIdentifier();
  if (this.isRelational(&quot;&lt;&quot;)) {
    node.typeParameters = this.flowParseTypeParameterInstantiation();
  } else {
    node.typeParameters = null;
  }

  return this.finishNode(node, &quot;InterfaceExtends&quot;);
};

pp.flowParseInterface = function (node) {
  this.flowParseInterfaceish(node, false);
  return this.finishNode(node, &quot;InterfaceDeclaration&quot;);
};

// Type aliases

pp.flowParseTypeAlias = function (node) {
  node.id = this.parseIdentifier();

  if (this.isRelational(&quot;&lt;&quot;)) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    node.typeParameters = null;
  }

  node.right = this.flowParseTypeInitialiser(_types.types.eq,
  /*allowLeadingPipeOrAnd*/true);
  this.semicolon();

  return this.finishNode(node, &quot;TypeAlias&quot;);
};

// Type annotations

pp.flowParseTypeParameter = function () {
  var node = this.startNode();

  var variance = void 0;
  if (this.match(_types.types.plusMin)) {
    if (this.state.value === &quot;+&quot;) {
      variance = &quot;plus&quot;;
    } else if (this.state.value === &quot;-&quot;) {
      variance = &quot;minus&quot;;
    }
    this.eat(_types.types.plusMin);
  }

  var ident = this.flowParseTypeAnnotatableIdentifier(false, false);
  node.name = ident.name;
  node.variance = variance;
  node.bound = ident.typeAnnotation;

  if (this.match(_types.types.eq)) {
    this.eat(_types.types.eq);
    node.default = this.flowParseType();
  }

  return this.finishNode(node, &quot;TypeParameter&quot;);
};

pp.flowParseTypeParameterDeclaration = function () {
  var oldInType = this.state.inType;
  var node = this.startNode();
  node.params = [];

  this.state.inType = true;

  if (this.isRelational(&quot;&lt;&quot;) || this.match(_types.types.jsxTagStart)) {
    this.next();
  } else {
    this.unexpected();
  }

  do {
    node.params.push(this.flowParseTypeParameter());
    if (!this.isRelational(&quot;&gt;&quot;)) {
      this.expect(_types.types.comma);
    }
  } while (!this.isRelational(&quot;&gt;&quot;));
  this.expectRelational(&quot;&gt;&quot;);

  this.state.inType = oldInType;

  return this.finishNode(node, &quot;TypeParameterDeclaration&quot;);
};

pp.flowParseTypeParameterInstantiation = function () {
  var node = this.startNode(),
      oldInType = this.state.inType;
  node.params = [];

  this.state.inType = true;

  this.expectRelational(&quot;&lt;&quot;);
  while (!this.isRelational(&quot;&gt;&quot;)) {
    node.params.push(this.flowParseType());
    if (!this.isRelational(&quot;&gt;&quot;)) {
      this.expect(_types.types.comma);
    }
  }
  this.expectRelational(&quot;&gt;&quot;);

  this.state.inType = oldInType;

  return this.finishNode(node, &quot;TypeParameterInstantiation&quot;);
};

pp.flowParseObjectPropertyKey = function () {
  return this.match(_types.types.num) || this.match(_types.types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
};

pp.flowParseObjectTypeIndexer = function (node, isStatic) {
  node.static = isStatic;

  this.expect(_types.types.bracketL);
  node.id = this.flowParseObjectPropertyKey();
  node.key = this.flowParseTypeInitialiser();
  this.expect(_types.types.bracketR);
  node.value = this.flowParseTypeInitialiser();

  this.flowObjectTypeSemicolon();
  return this.finishNode(node, &quot;ObjectTypeIndexer&quot;);
};

pp.flowParseObjectTypeMethodish = function (node) {
  node.params = [];
  node.rest = null;
  node.typeParameters = null;

  if (this.isRelational(&quot;&lt;&quot;)) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  }

  this.expect(_types.types.parenL);
  while (this.match(_types.types.name)) {
    node.params.push(this.flowParseFunctionTypeParam());
    if (!this.match(_types.types.parenR)) {
      this.expect(_types.types.comma);
    }
  }

  if (this.eat(_types.types.ellipsis)) {
    node.rest = this.flowParseFunctionTypeParam();
  }
  this.expect(_types.types.parenR);
  node.returnType = this.flowParseTypeInitialiser();

  return this.finishNode(node, &quot;FunctionTypeAnnotation&quot;);
};

pp.flowParseObjectTypeMethod = function (startPos, startLoc, isStatic, key) {
  var node = this.startNodeAt(startPos, startLoc);
  node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(startPos, startLoc));
  node.static = isStatic;
  node.key = key;
  node.optional = false;
  this.flowObjectTypeSemicolon();
  return this.finishNode(node, &quot;ObjectTypeProperty&quot;);
};

pp.flowParseObjectTypeCallProperty = function (node, isStatic) {
  var valueNode = this.startNode();
  node.static = isStatic;
  node.value = this.flowParseObjectTypeMethodish(valueNode);
  this.flowObjectTypeSemicolon();
  return this.finishNode(node, &quot;ObjectTypeCallProperty&quot;);
};

pp.flowParseObjectType = function (allowStatic, allowExact) {
  var nodeStart = this.startNode();
  var node = void 0;
  var propertyKey = void 0;
  var isStatic = void 0;

  nodeStart.callProperties = [];
  nodeStart.properties = [];
  nodeStart.indexers = [];

  var endDelim = void 0;
  var exact = void 0;
  if (allowExact &amp;&amp; this.match(_types.types.braceBarL)) {
    this.expect(_types.types.braceBarL);
    endDelim = _types.types.braceBarR;
    exact = true;
  } else {
    this.expect(_types.types.braceL);
    endDelim = _types.types.braceR;
    exact = false;
  }

  nodeStart.exact = exact;

  while (!this.match(endDelim)) {
    var optional = false;
    var startPos = this.state.start,
        startLoc = this.state.startLoc;
    node = this.startNode();
    if (allowStatic &amp;&amp; this.isContextual(&quot;static&quot;)) {
      this.next();
      isStatic = true;
    }

    if (this.match(_types.types.bracketL)) {
      nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic));
    } else if (this.match(_types.types.parenL) || this.isRelational(&quot;&lt;&quot;)) {
      nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, allowStatic));
    } else {
      if (isStatic &amp;&amp; this.match(_types.types.colon)) {
        propertyKey = this.parseIdentifier();
      } else {
        propertyKey = this.flowParseObjectPropertyKey();
      }
      if (this.isRelational(&quot;&lt;&quot;) || this.match(_types.types.parenL)) {
        // This is a method property
        nodeStart.properties.push(this.flowParseObjectTypeMethod(startPos, startLoc, isStatic, propertyKey));
      } else {
        if (this.eat(_types.types.question)) {
          optional = true;
        }
        node.key = propertyKey;
        node.value = this.flowParseTypeInitialiser();
        node.optional = optional;
        node.static = isStatic;
        this.flowObjectTypeSemicolon();
        nodeStart.properties.push(this.finishNode(node, &quot;ObjectTypeProperty&quot;));
      }
    }
  }

  this.expect(endDelim);

  return this.finishNode(nodeStart, &quot;ObjectTypeAnnotation&quot;);
};

pp.flowObjectTypeSemicolon = function () {
  if (!this.eat(_types.types.semi) &amp;&amp; !this.eat(_types.types.comma) &amp;&amp; !this.match(_types.types.braceR) &amp;&amp; !this.match(_types.types.braceBarR)) {
    this.unexpected();
  }
};

pp.flowParseQualifiedTypeIdentifier = function (startPos, startLoc, id) {
  startPos = startPos || this.state.start;
  startLoc = startLoc || this.state.startLoc;
  var node = id || this.parseIdentifier();

  while (this.eat(_types.types.dot)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.qualification = node;
    node2.id = this.parseIdentifier();
    node = this.finishNode(node2, &quot;QualifiedTypeIdentifier&quot;);
  }

  return node;
};

pp.flowParseGenericType = function (startPos, startLoc, id) {
  var node = this.startNodeAt(startPos, startLoc);

  node.typeParameters = null;
  node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

  if (this.isRelational(&quot;&lt;&quot;)) {
    node.typeParameters = this.flowParseTypeParameterInstantiation();
  }

  return this.finishNode(node, &quot;GenericTypeAnnotation&quot;);
};

pp.flowParseTypeofType = function () {
  var node = this.startNode();
  this.expect(_types.types._typeof);
  node.argument = this.flowParsePrimaryType();
  return this.finishNode(node, &quot;TypeofTypeAnnotation&quot;);
};

pp.flowParseTupleType = function () {
  var node = this.startNode();
  node.types = [];
  this.expect(_types.types.bracketL);
  // We allow trailing commas
  while (this.state.pos &lt; this.input.length &amp;&amp; !this.match(_types.types.bracketR)) {
    node.types.push(this.flowParseType());
    if (this.match(_types.types.bracketR)) break;
    this.expect(_types.types.comma);
  }
  this.expect(_types.types.bracketR);
  return this.finishNode(node, &quot;TupleTypeAnnotation&quot;);
};

pp.flowParseFunctionTypeParam = function () {
  var optional = false;
  var node = this.startNode();
  node.name = this.parseIdentifier();
  if (this.eat(_types.types.question)) {
    optional = true;
  }
  node.optional = optional;
  node.typeAnnotation = this.flowParseTypeInitialiser();
  return this.finishNode(node, &quot;FunctionTypeParam&quot;);
};

pp.flowParseFunctionTypeParams = function () {
  var ret = { params: [], rest: null };
  while (this.match(_types.types.name)) {
    ret.params.push(this.flowParseFunctionTypeParam());
    if (!this.match(_types.types.parenR)) {
      this.expect(_types.types.comma);
    }
  }
  if (this.eat(_types.types.ellipsis)) {
    ret.rest = this.flowParseFunctionTypeParam();
  }
  return ret;
};

pp.flowIdentToTypeAnnotation = function (startPos, startLoc, node, id) {
  switch (id.name) {
    case &quot;any&quot;:
      return this.finishNode(node, &quot;AnyTypeAnnotation&quot;);

    case &quot;void&quot;:
      return this.finishNode(node, &quot;VoidTypeAnnotation&quot;);

    case &quot;bool&quot;:
    case &quot;boolean&quot;:
      return this.finishNode(node, &quot;BooleanTypeAnnotation&quot;);

    case &quot;mixed&quot;:
      return this.finishNode(node, &quot;MixedTypeAnnotation&quot;);

    case &quot;number&quot;:
      return this.finishNode(node, &quot;NumberTypeAnnotation&quot;);

    case &quot;string&quot;:
      return this.finishNode(node, &quot;StringTypeAnnotation&quot;);

    default:
      return this.flowParseGenericType(startPos, startLoc, id);
  }
};

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they&#039;re the
// primitives with which other types are constructed.
pp.flowParsePrimaryType = function () {
  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  var node = this.startNode();
  var tmp = void 0;
  var type = void 0;
  var isGroupedType = false;

  switch (this.state.type) {
    case _types.types.name:
      return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

    case _types.types.braceL:
      return this.flowParseObjectType(false, false);

    case _types.types.braceBarL:
      return this.flowParseObjectType(false, true);

    case _types.types.bracketL:
      return this.flowParseTupleType();

    case _types.types.relational:
      if (this.state.value === &quot;&lt;&quot;) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
        this.expect(_types.types.parenL);
        tmp = this.flowParseFunctionTypeParams();
        node.params = tmp.params;
        node.rest = tmp.rest;
        this.expect(_types.types.parenR);

        this.expect(_types.types.arrow);

        node.returnType = this.flowParseType();

        return this.finishNode(node, &quot;FunctionTypeAnnotation&quot;);
      }
      break;

    case _types.types.parenL:
      this.next();

      // Check to see if this is actually a grouped type
      if (!this.match(_types.types.parenR) &amp;&amp; !this.match(_types.types.ellipsis)) {
        if (this.match(_types.types.name)) {
          var token = this.lookahead().type;
          isGroupedType = token !== _types.types.question &amp;&amp; token !== _types.types.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        type = this.flowParseType();
        this.expect(_types.types.parenR);
        return type;
      }

      tmp = this.flowParseFunctionTypeParams();
      node.params = tmp.params;
      node.rest = tmp.rest;

      this.expect(_types.types.parenR);

      this.expect(_types.types.arrow);

      node.returnType = this.flowParseType();
      node.typeParameters = null;

      return this.finishNode(node, &quot;FunctionTypeAnnotation&quot;);

    case _types.types.string:
      node.value = this.state.value;
      this.addExtra(node, &quot;rawValue&quot;, node.value);
      this.addExtra(node, &quot;raw&quot;, this.input.slice(this.state.start, this.state.end));
      this.next();
      return this.finishNode(node, &quot;StringLiteralTypeAnnotation&quot;);

    case _types.types._true:case _types.types._false:
      node.value = this.match(_types.types._true);
      this.next();
      return this.finishNode(node, &quot;BooleanLiteralTypeAnnotation&quot;);

    case _types.types.plusMin:
      if (this.state.value === &quot;-&quot;) {
        this.next();
        if (!this.match(_types.types.num)) this.unexpected();

        node.value = -this.state.value;
        this.addExtra(node, &quot;rawValue&quot;, node.value);
        this.addExtra(node, &quot;raw&quot;, this.input.slice(this.state.start, this.state.end));
        this.next();
        return this.finishNode(node, &quot;NumericLiteralTypeAnnotation&quot;);
      }

    case _types.types.num:
      node.value = this.state.value;
      this.addExtra(node, &quot;rawValue&quot;, node.value);
      this.addExtra(node, &quot;raw&quot;, this.input.slice(this.state.start, this.state.end));
      this.next();
      return this.finishNode(node, &quot;NumericLiteralTypeAnnotation&quot;);

    case _types.types._null:
      node.value = this.match(_types.types._null);
      this.next();
      return this.finishNode(node, &quot;NullLiteralTypeAnnotation&quot;);

    case _types.types._this:
      node.value = this.match(_types.types._this);
      this.next();
      return this.finishNode(node, &quot;ThisTypeAnnotation&quot;);

    case _types.types.star:
      this.next();
      return this.finishNode(node, &quot;ExistentialTypeParam&quot;);

    default:
      if (this.state.type.keyword === &quot;typeof&quot;) {
        return this.flowParseTypeofType();
      }
  }

  this.unexpected();
};

pp.flowParsePostfixType = function () {
  var node = this.startNode();
  var type = node.elementType = this.flowParsePrimaryType();
  if (this.match(_types.types.bracketL)) {
    this.expect(_types.types.bracketL);
    this.expect(_types.types.bracketR);
    return this.finishNode(node, &quot;ArrayTypeAnnotation&quot;);
  } else {
    return type;
  }
};

pp.flowParsePrefixType = function () {
  var node = this.startNode();
  if (this.eat(_types.types.question)) {
    node.typeAnnotation = this.flowParsePrefixType();
    return this.finishNode(node, &quot;NullableTypeAnnotation&quot;);
  } else {
    return this.flowParsePostfixType();
  }
};

pp.flowParseIntersectionType = function () {
  var node = this.startNode();
  var type = this.flowParsePrefixType();
  node.types = [type];
  while (this.eat(_types.types.bitwiseAND)) {
    node.types.push(this.flowParsePrefixType());
  }
  return node.types.length === 1 ? type : this.finishNode(node, &quot;IntersectionTypeAnnotation&quot;);
};

pp.flowParseUnionType = function () {
  var node = this.startNode();
  var type = this.flowParseIntersectionType();
  node.types = [type];
  while (this.eat(_types.types.bitwiseOR)) {
    node.types.push(this.flowParseIntersectionType());
  }
  return node.types.length === 1 ? type : this.finishNode(node, &quot;UnionTypeAnnotation&quot;);
};

pp.flowParseType = function () {
  var oldInType = this.state.inType;
  this.state.inType = true;
  var type = this.flowParseUnionType();
  this.state.inType = oldInType;
  return type;
};

pp.flowParseTypeAnnotation = function () {
  var node = this.startNode();
  node.typeAnnotation = this.flowParseTypeInitialiser();
  return this.finishNode(node, &quot;TypeAnnotation&quot;);
};

pp.flowParseTypeAnnotatableIdentifier = function (requireTypeAnnotation, canBeOptionalParam) {

  var ident = this.parseIdentifier();
  var isOptionalParam = false;

  if (canBeOptionalParam &amp;&amp; this.eat(_types.types.question)) {
    this.expect(_types.types.question);
    isOptionalParam = true;
  }

  if (requireTypeAnnotation || this.match(_types.types.colon)) {
    ident.typeAnnotation = this.flowParseTypeAnnotation();
    this.finishNode(ident, ident.type);
  }

  if (isOptionalParam) {
    ident.optional = true;
    this.finishNode(ident, ident.type);
  }

  return ident;
};

pp.typeCastToParameter = function (node) {
  node.expression.typeAnnotation = node.typeAnnotation;

  return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
