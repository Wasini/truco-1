<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint/lib/config.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint/lib/config.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.54</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">340</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">47.07</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.00</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Responsible for loading config files
 * @author Seth McLaughlin
 */

&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

var path = require(&quot;path&quot;),
    ConfigOps = require(&quot;./config/config-ops&quot;),
    ConfigFile = require(&quot;./config/config-file&quot;),
    Plugins = require(&quot;./config/plugins&quot;),
    FileFinder = require(&quot;./file-finder&quot;),
    debug = require(&quot;debug&quot;),
    userHome = require(&quot;user-home&quot;),
    isResolvable = require(&quot;is-resolvable&quot;),
    pathIsInside = require(&quot;path-is-inside&quot;);

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

var PERSONAL_CONFIG_DIR = userHome || null;

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

debug = debug(&quot;eslint:config&quot;);

/**
 * Check if item is an javascript object
 * @param {*} item object to check for
 * @returns {boolean} True if its an object
 * @private
 */
function isObject(item) {
    return typeof item === &quot;object&quot; &amp;&amp; !Array.isArray(item) &amp;&amp; item !== null;
}

/**
 * Load and parse a JSON config object from a file.
 * @param {string|Object} configToLoad the path to the JSON config file or the config object itself.
 * @returns {Object} the parsed config object (empty object if there was a parse error)
 * @private
 */
function loadConfig(configToLoad) {
    var config = {},
        filePath = &quot;&quot;;

    if (configToLoad) {

        if (isObject(configToLoad)) {
            config = configToLoad;

            if (config.extends) {
                config = ConfigFile.applyExtends(config, filePath);
            }
        } else {
            filePath = configToLoad;
            config = ConfigFile.load(filePath);
        }

    }

    return config;
}

/**
 * Get personal config object from ~/.eslintrc.
 * @returns {Object} the personal config object (null if there is no personal config)
 * @private
 */
function getPersonalConfig() {
    var config,
        filename;

    if (PERSONAL_CONFIG_DIR) {
        filename = ConfigFile.getFilenameForDirectory(PERSONAL_CONFIG_DIR);

        if (filename) {
            debug(&quot;Using personal config&quot;);
            config = loadConfig(filename);
        }
    }

    return config || null;
}

/**
 * Determine if rules were explicitly passed in as options.
 * @param {Object} options The options used to create our configuration.
 * @returns {boolean} True if rules were passed in as options, false otherwise.
 */
function hasRules(options) {
    return options.rules &amp;&amp; Object.keys(options.rules).length &gt; 0;
}

/**
 * Get a local config object.
 * @param {Object} thisConfig A Config object.
 * @param {string} directory The directory to start looking in for a local config file.
 * @returns {Object} The local config object, or an empty object if there is no local config.
 */
function getLocalConfig(thisConfig, directory) {
    var found,
        i,
        localConfig,
        localConfigFile,
        config = {},
        localConfigFiles = thisConfig.findLocalConfigFiles(directory),
        numFiles = localConfigFiles.length,
        rootPath,
        projectConfigPath = ConfigFile.getFilenameForDirectory(thisConfig.options.cwd),
        personalConfig;

    for (i = 0; i &lt; numFiles; i++) {

        localConfigFile = localConfigFiles[i];

        // Don&#039;t consider the personal config file in the home directory,
        // except if the home directory is the same as the current working directory
        if (path.dirname(localConfigFile) === PERSONAL_CONFIG_DIR &amp;&amp; localConfigFile !== projectConfigPath) {
            continue;
        }

        // If root flag is set, don&#039;t consider file if it is above root
        if (rootPath &amp;&amp; !pathIsInside(path.dirname(localConfigFile), rootPath)) {
            continue;
        }

        debug(&quot;Loading &quot; + localConfigFile);
        localConfig = loadConfig(localConfigFile);

        // Don&#039;t consider a local config file found if the config is null
        if (!localConfig) {
            continue;
        }

        // Check for root flag
        if (localConfig.root === true) {
            rootPath = path.dirname(localConfigFile);
        }

        found = true;
        debug(&quot;Using &quot; + localConfigFile);
        config = ConfigOps.merge(localConfig, config);
    }

    if (!found &amp;&amp; !thisConfig.useSpecificConfig) {

        /*
         * - Is there a personal config in the user&#039;s home directory? If so,
         *   merge that with the passed-in config.
         * - Otherwise, if no rules were manually passed in, throw and error.
         * - Note: This function is not called if useEslintrc is false.
         */
        personalConfig = getPersonalConfig();

        if (personalConfig) {
            config = ConfigOps.merge(config, personalConfig);
        } else if (!hasRules(thisConfig.options)) {

            // No config file, no manual configuration, and no rules, so error.
            var noConfigError = new Error(&quot;No ESLint configuration found.&quot;);

            noConfigError.messageTemplate = &quot;no-config-found&quot;;
            noConfigError.messageData = {
                directory: directory,
                filesExamined: localConfigFiles
            };

            throw noConfigError;
        }
    }

    return config;
}

//------------------------------------------------------------------------------
// API
//------------------------------------------------------------------------------

/**
 * Config
 * @constructor
 * @class Config
 * @param {Object} options Options to be passed in
 */
function Config(options) {
    var useConfig;

    options = options || {};

    this.ignore = options.ignore;
    this.ignorePath = options.ignorePath;
    this.cache = {};
    this.parser = options.parser;
    this.parserOptions = options.parserOptions || {};

    this.baseConfig = options.baseConfig ? loadConfig(options.baseConfig) : { rules: {} };

    this.useEslintrc = (options.useEslintrc !== false);

    this.env = (options.envs || []).reduce(function(envs, name) {
        envs[name] = true;
        return envs;
    }, {});

    /*
     * Handle declared globals.
     * For global variable foo, handle &quot;foo:false&quot; and &quot;foo:true&quot; to set
     * whether global is writable.
     * If user declares &quot;foo&quot;, convert to &quot;foo:false&quot;.
     */
    this.globals = (options.globals || []).reduce(function(globals, def) {
        var parts = def.split(&quot;:&quot;);

        globals[parts[0]] = (parts.length &gt; 1 &amp;&amp; parts[1] === &quot;true&quot;);

        return globals;
    }, {});

    useConfig = options.configFile;
    this.options = options;

    if (useConfig) {
        debug(&quot;Using command line config &quot; + useConfig);
        if (isResolvable(useConfig) || isResolvable(&quot;eslint-config-&quot; + useConfig) || useConfig.charAt(0) === &quot;@&quot;) {
            this.useSpecificConfig = loadConfig(useConfig);
        } else {
            this.useSpecificConfig = loadConfig(path.resolve(this.options.cwd, useConfig));
        }
    }
}

/**
 * Build a config object merging the base config (conf/eslint.json), the
 * environments config (conf/environments.js) and eventually the user config.
 * @param {string} filePath a file in whose directory we start looking for a local config
 * @returns {Object} config object
 */
Config.prototype.getConfig = function(filePath) {
    var config,
        userConfig,
        directory = filePath ? path.dirname(filePath) : this.options.cwd;

    debug(&quot;Constructing config for &quot; + (filePath ? filePath : &quot;text&quot;));

    config = this.cache[directory];

    if (config) {
        debug(&quot;Using config from cache&quot;);
        return config;
    }

    // Step 1: Determine user-specified config from .eslintrc.* and package.json files
    if (this.useEslintrc) {
        debug(&quot;Using .eslintrc and package.json files&quot;);
        userConfig = getLocalConfig(this, directory);
    } else {
        debug(&quot;Not using .eslintrc or package.json files&quot;);
        userConfig = {};
    }

    // Step 2: Create a copy of the baseConfig
    config = ConfigOps.merge({}, this.baseConfig);

    // Step 3: Merge in the user-specified configuration from .eslintrc and package.json
    config = ConfigOps.merge(config, userConfig);

    // Step 4: Merge in command line config file
    if (this.useSpecificConfig) {
        debug(&quot;Merging command line config file&quot;);

        config = ConfigOps.merge(config, this.useSpecificConfig);
    }

    // Step 5: Merge in command line environments
    debug(&quot;Merging command line environment settings&quot;);
    config = ConfigOps.merge(config, { env: this.env });

    // Step 6: Merge in command line rules
    if (this.options.rules) {
        debug(&quot;Merging command line rules&quot;);
        config = ConfigOps.merge(config, { rules: this.options.rules });
    }

    // Step 7: Merge in command line globals
    config = ConfigOps.merge(config, { globals: this.globals });

    // Only override parser if it is passed explicitly through the command line or if it&#039;s not
    // defined yet (because the final object will at least have the parser key)
    if (this.parser || !config.parser) {
        config = ConfigOps.merge(config, {
            parser: this.parser
        });
    }

    if (this.parserOptions) {
        config = ConfigOps.merge(config, {
            parserOptions: this.parserOptions
        });
    }

    // Step 8: Merge in command line plugins
    if (this.options.plugins) {
        debug(&quot;Merging command line plugins&quot;);
        Plugins.loadAll(this.options.plugins);
        config = ConfigOps.merge(config, { plugins: this.options.plugins });
    }

    // Step 9: Apply environments to the config if present
    if (config.env) {
        config = ConfigOps.applyEnvironments(config);
    }

    this.cache[directory] = config;

    return config;
};

/**
 * Find local config files from directory and parent directories.
 * @param {string} directory The directory to start searching from.
 * @returns {string[]} The paths of local config files found.
 */
Config.prototype.findLocalConfigFiles = function(directory) {

    if (!this.localConfigFinder) {
        this.localConfigFinder = new FileFinder(ConfigFile.CONFIG_FILES, this.options.cwd);
    }

    return this.localConfigFinder.findAllInDirectoryAndParents(directory);
};

module.exports = Config;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
