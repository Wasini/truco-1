<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/bson/alternate_parsers/faster_bson.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/bson/alternate_parsers/faster_bson.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">53.13</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">429</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">188.72</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.94</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/// reduced to ~ 410 LOCs (parser only 300 vs. 1400+) with (some, needed) BSON classes &quot;inlined&quot;.
/// Compare ~ 4,300 (22KB vs. 157KB) in browser build at: https://github.com/mongodb/js-bson/blob/master/browser_build/bson.js

module.exports.calculateObjectSize = calculateObjectSize;

function calculateObjectSize(object) {
    var totalLength = (4 + 1);      /// handles the obj.length prefix + terminating &#039;0&#039; ?!
    for(var key in object) {        /// looks like it handles arrays under the same for...in loop!?
      totalLength += calculateElement(key, object[key])
    }
    return totalLength;
}

function calculateElement(name, value) {
    var len = 1;                                /// always starting with 1 for the data type byte!
    if (name) len += Buffer.byteLength(name, &#039;utf8&#039;) + 1;   /// cstring: name + &#039;0&#039; termination

    if (value === undefined || value === null) return len;  /// just the type byte plus name cstring
    switch( value.constructor ) {      /// removed all checks &#039;isBuffer&#039; if Node.js Buffer class is present!?

        case ObjectID:          /// we want these sorted from most common case to least common/deprecated;
            return len + 12;
        case String:
            return len + 4 + Buffer.byteLength(value, &#039;utf8&#039;) +1; ///
        case Number:
            if (Math.floor(value) === value) {  /// case: integer; pos.# more common, &#039;&amp;&amp;&#039; stops if 1st fails!
                if ( value &lt;= 2147483647 &amp;&amp; value &gt;= -2147483647 ) // 32 bit
                    return len + 4;
                else return len + 8;    /// covers Long-ish JS integers as Longs!
            } else return len + 8;      /// 8+1 --- covers Double &amp; std. float
        case Boolean:
            return len + 1;

        case Array:
        case Object:
            return len + calculateObjectSize(value);

        case Buffer:   ///  replaces the entire Binary class!
            return len + 4 + value.length + 1;

        case Regex:  /// these are handled as strings by serializeFast() later, hence &#039;gim&#039; opts = 3 + 1 chars
            return len + Buffer.byteLength(value.source, &#039;utf8&#039;) + 1
                + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) +1;
        case Date:
        case Long:
        case Timestamp:
        case Double:
            return len + 8;

        case MinKey:
        case MaxKey:
            return len;     /// these two return the type byte and name cstring only!
    }
    return 0;
}

module.exports.serializeFast = serializeFast;
module.exports.serialize = function(object, checkKeys, asBuffer, serializeFunctions, index) {
  var buffer = new Buffer(calculateObjectSize(object));
  return serializeFast(object, checkKeys, buffer, 0);
}

function serializeFast(object, checkKeys, buffer, i) {   /// set checkKeys = false in query(..., options object to save performance IFF you&#039;re certain your keys are safe/system-set!
    var size = buffer.length;
    buffer[i++] = size &amp; 0xff; buffer[i++] = (size &gt;&gt; 8) &amp; 0xff;   /// these get overwritten later!
    buffer[i++] = (size &gt;&gt; 16) &amp; 0xff; buffer[i++] = (size &gt;&gt; 24) &amp; 0xff;

    if (object.constructor === Array) {     /// any need to checkKeys here?!? since we&#039;re doing for rather than for...in, should be safe from extra (non-numeric) keys added to the array?!
        for(var j = 0; j &lt; object.length; j++) {
            i = packElement(j.toString(), object[j], checkKeys, buffer, i);
        }
    } else {   /// checkKeys is needed if any suspicion of end-user key tampering/&quot;injection&quot; (a la SQL)
        for(var key in object) {    /// mostly there should never be direct access to them!?
            if (checkKeys &amp;&amp; (key.indexOf(&#039;\x00&#039;) &gt;= 0 || key === &#039;$where&#039;) ) {  /// = &quot;no script&quot;?!; could add back key.indexOf(&#039;$&#039;) or maybe check for &#039;eval&#039;?!
/// took out: || key.indexOf(&#039;.&#039;) &gt;= 0...  Don&#039;t we allow dot notation queries?!
                console.log(&#039;checkKeys error: &#039;);
                return new Error(&#039;Illegal object key!&#039;);
            }
            i = packElement(key, object[key], checkKeys, buffer, i);  /// checkKeys pass needed for recursion!
        }
    }
    buffer[i++] = 0;   /// write terminating zero; !we do NOT -1 the index increase here as original does!
    return i;
}

function packElement(name, value, checkKeys, buffer, i) {    /// serializeFunctions removed! checkKeys needed for Array &amp; Object cases pass through (calling serializeFast recursively!)
    if (value === undefined || value === null){
        buffer[i++] = 10;                                       /// = BSON.BSON_DATA_NULL;
        i += buffer.write(name, i, &#039;utf8&#039;); buffer[i++] = 0;    /// buffer.write(...) returns bytesWritten!
        return i;
    }
    switch(value.constructor) {

    case ObjectID:
        buffer[i++] = 7;   /// = BSON.BSON_DATA_OID;
        i += buffer.write(name, i, &#039;utf8&#039;);     buffer[i++] = 0;
///     i += buffer.write(value.id, i, &#039;binary&#039;);  ///  OLD: writes a String to a Buffer; &#039;binary&#039; deprecated!!
        value.id.copy(buffer, i);  /// NEW ObjectID version has this.id = Buffer at the ready!
        return i += 12;

    case String:
        buffer[i++] = 2;    ///  = BSON.BSON_DATA_STRING;
        i += buffer.write(name, i, &#039;utf8&#039;);     buffer[i++] = 0;

        var size = Buffer.byteLength(value) + 1;  /// includes the terminating &#039;0&#039;!?
        buffer[i++] = size &amp; 0xff; buffer[i++] = (size &gt;&gt; 8) &amp; 0xff;
        buffer[i++] = (size &gt;&gt; 16) &amp; 0xff; buffer[i++] = (size &gt;&gt; 24) &amp; 0xff;

        i += buffer.write(value, i, &#039;utf8&#039;);    buffer[i++] = 0;
        return i;

    case Number:
        if ( ~~(value) === value) {     /// double-Tilde is equiv. to Math.floor(value)
            if ( value &lt;= 2147483647 &amp;&amp; value &gt;= -2147483647){ /// = BSON.BSON_INT32_MAX / MIN asf.
                buffer[i++] = 16;   /// = BSON.BSON_DATA_INT;
                i += buffer.write(name, i, &#039;utf8&#039;); buffer[i++] = 0;
                buffer[i++] = value &amp; 0xff; buffer[i++] = (value &gt;&gt; 8) &amp; 0xff;
                buffer[i++] = (value &gt;&gt; 16) &amp; 0xff; buffer[i++] = (value &gt;&gt; 24) &amp; 0xff;

// Else large-ish JS int!? to Long!?
            } else {  /// if (value &lt;= BSON.JS_INT_MAX &amp;&amp; value &gt;= BSON.JS_INT_MIN){ /// 9007199254740992 asf.
                buffer[i++] = 18;   /// = BSON.BSON_DATA_LONG;
                i += buffer.write(name, i, &#039;utf8&#039;); buffer[i++] = 0;
                var lowBits = ( value % 4294967296 ) | 0, highBits = ( value / 4294967296 ) | 0;

                buffer[i++] = lowBits &amp; 0xff;           buffer[i++] = (lowBits &gt;&gt; 8) &amp; 0xff;
                buffer[i++] = (lowBits &gt;&gt; 16) &amp; 0xff;   buffer[i++] = (lowBits &gt;&gt; 24) &amp; 0xff;
                buffer[i++] = highBits &amp; 0xff;          buffer[i++] = (highBits &gt;&gt; 8) &amp; 0xff;
                buffer[i++] = (highBits &gt;&gt; 16) &amp; 0xff;  buffer[i++] = (highBits &gt;&gt; 24) &amp; 0xff;
            }
        } else {    /// we have a float / Double
            buffer[i++] = 1;    /// = BSON.BSON_DATA_NUMBER;
            i += buffer.write(name, i, &#039;utf8&#039;); buffer[i++] = 0;
/// OLD:    writeIEEE754(buffer, value, i, &#039;little&#039;, 52, 8);
            buffer.writeDoubleLE(value, i);     i += 8;
        }
        return i;

    case Boolean:
        buffer[i++] = 8;    /// = BSON.BSON_DATA_BOOLEAN;
        i += buffer.write(name, i, &#039;utf8&#039;); buffer[i++] = 0;
        buffer[i++] = value ? 1 : 0;
        return i;

    case Array:
    case Object:
        buffer[i++] = value.constructor === Array ? 4 : 3; /// = BSON.BSON_DATA_ARRAY / _OBJECT;
        i += buffer.write(name, i, &#039;utf8&#039;); buffer[i++] = 0;

	    var endIndex = serializeFast(value, checkKeys, buffer, i); /// + 4); no longer needed b/c serializeFast writes a temp 4 bytes for length
        var size = endIndex - i;
        buffer[i++] = size &amp; 0xff;          buffer[i++] = (size &gt;&gt; 8) &amp; 0xff;
        buffer[i++] = (size &gt;&gt; 16) &amp; 0xff;  buffer[i++] = (size &gt;&gt; 24) &amp; 0xff;
        return endIndex;

    /// case Binary:        /// is basically identical unless special/deprecated options!
    case Buffer:            /// solves ALL of our Binary needs without the BSON.Binary class!?
        buffer[i++] = 5;    /// = BSON.BSON_DATA_BINARY;
        i += buffer.write(name, i, &#039;utf8&#039;); buffer[i++] = 0;
        var size = value.length;
        buffer[i++] = size &amp; 0xff;          buffer[i++] = (size &gt;&gt; 8) &amp; 0xff;
        buffer[i++] = (size &gt;&gt; 16) &amp; 0xff;  buffer[i++] = (size &gt;&gt; 24) &amp; 0xff;

        buffer[i++] = 0;        /// write BSON.BSON_BINARY_SUBTYPE_DEFAULT;
        value.copy(buffer, i);  ///, 0, size); &lt;&lt; defaults to sourceStart=0, sourceEnd=sourceBuffer.length);
        i += size;
        return i;

    case RegExp:
        buffer[i++] = 11;   /// = BSON.BSON_DATA_REGEXP;
        i += buffer.write(name, i, &#039;utf8&#039;);         buffer[i++] = 0;
        i += buffer.write(value.source, i, &#039;utf8&#039;); buffer[i++] = 0x00;

        if (value.global) buffer[i++] = 0x73;        // s = &#039;g&#039; for JS Regex!
        if (value.ignoreCase) buffer[i++] = 0x69;    // i
        if (value.multiline) buffer[i++] = 0x6d;     // m
        buffer[i++] = 0x00;
        return i;

    case Date:
        buffer[i++] = 9;    /// = BSON.BSON_DATA_DATE;
        i += buffer.write(name, i, &#039;utf8&#039;); buffer[i++] = 0;
        var millis = value.getTime();
        var lowBits = ( millis % 4294967296 ) | 0, highBits = ( millis / 4294967296 ) | 0;

        buffer[i++] = lowBits &amp; 0xff;           buffer[i++] = (lowBits &gt;&gt; 8) &amp; 0xff;
        buffer[i++] = (lowBits &gt;&gt; 16) &amp; 0xff;   buffer[i++] = (lowBits &gt;&gt; 24) &amp; 0xff;
        buffer[i++] = highBits &amp; 0xff;          buffer[i++] = (highBits &gt;&gt; 8) &amp; 0xff;
        buffer[i++] = (highBits &gt;&gt; 16) &amp; 0xff;  buffer[i++] = (highBits &gt;&gt; 24) &amp; 0xff;
        return i;

    case Long:
    case Timestamp:
        buffer[i++] = value.constructor === Long ? 18 : 17; /// = BSON.BSON_DATA_LONG / _TIMESTAMP
        i += buffer.write(name, i, &#039;utf8&#039;); buffer[i++] = 0;
        var lowBits = value.getLowBits(), highBits = value.getHighBits();

        buffer[i++] = lowBits &amp; 0xff;           buffer[i++] = (lowBits &gt;&gt; 8) &amp; 0xff;
        buffer[i++] = (lowBits &gt;&gt; 16) &amp; 0xff;   buffer[i++] = (lowBits &gt;&gt; 24) &amp; 0xff;
        buffer[i++] = highBits &amp; 0xff;          buffer[i++] = (highBits &gt;&gt; 8) &amp; 0xff;
        buffer[i++] = (highBits &gt;&gt; 16) &amp; 0xff;  buffer[i++] = (highBits &gt;&gt; 24) &amp; 0xff;
        return i;

    case Double:
        buffer[i++] = 1;    /// = BSON.BSON_DATA_NUMBER;
        i += buffer.write(name, i, &#039;utf8&#039;); buffer[i++] = 0;
/// OLD: writeIEEE754(buffer, value, i, &#039;little&#039;, 52, 8);    i += 8;
        buffer.writeDoubleLE(value, i);     i += 8;
        return i

    case MinKey:    /// = BSON.BSON_DATA_MINKEY;
        buffer[i++] = 127; i += buffer.write(name, i, &#039;utf8&#039;); buffer[i++] = 0;
        return i;
    case MaxKey:    /// = BSON.BSON_DATA_MAXKEY;
        buffer[i++] = 255; i += buffer.write(name, i, &#039;utf8&#039;); buffer[i++] = 0;
        return i;

    } /// end of switch
    return i;   /// ?! If no value to serialize
}


module.exports.deserializeFast = deserializeFast;

function deserializeFast(buffer, i, isArray){   //// , options, isArray) {       //// no more options!
    if (buffer.length &lt; 5) return new Error(&#039;Corrupt bson message &lt; 5 bytes long&#039;); /// from &#039;throw&#039;
    var elementType, tempindex = 0, name;
    var string, low, high;              /// = lowBits / highBits
                                        /// using &#039;i&#039; as the index to keep the lines shorter:
    i || ( i = 0 );  /// for parseResponse it&#039;s 0; set to running index in deserialize(object/array) recursion
    var object = isArray ? [] : {};         /// needed for type ARRAY recursion later!
    var size = buffer[i++] | buffer[i++] &lt;&lt; 8 | buffer[i++] &lt;&lt; 16 | buffer[i++] &lt;&lt; 24;
    if(size &lt; 5 || size &gt; buffer.length) return new Error(&#039;Corrupt BSON message&#039;);
/// &#039;size&#039; var was not used by anything after this, so we can reuse it

    while(true) {                           // While we have more left data left keep parsing
        elementType = buffer[i++];          // Read the type
        if (elementType === 0) break;       // If we get a zero it&#039;s the last byte, exit

        tempindex = i;  /// inlined readCStyleString &amp; removed extra i&lt;buffer.length check slowing EACH loop!
        while( buffer[tempindex] !== 0x00 ) tempindex++;  /// read ahead w/out changing main &#039;i&#039; index
        if (tempindex &gt;= buffer.length) return new Error(&#039;Corrupt BSON document: illegal CString&#039;)
        name = buffer.toString(&#039;utf8&#039;, i, tempindex);
        i = tempindex + 1;               /// Update index position to after the string + &#039;0&#039; termination

        switch(elementType) {

        case 7:     /// = BSON.BSON_DATA_OID:
            var buf = new Buffer(12);
            buffer.copy(buf, 0, i, i += 12 );   /// copy 12 bytes from the current &#039;i&#039; offset into fresh Buffer
            object[name] = new ObjectID(buf);   ///... &amp; attach to the new ObjectID instance
            break;

        case 2:     /// = BSON.BSON_DATA_STRING:
            size = buffer[i++] | buffer[i++] &lt;&lt;8 | buffer[i++] &lt;&lt;16 | buffer[i++] &lt;&lt;24;
            object[name] = buffer.toString(&#039;utf8&#039;, i, i += size -1 );
            i++;        break;          /// need to get the &#039;0&#039; index &quot;tick-forward&quot; back!

        case 16:    /// = BSON.BSON_DATA_INT:        // Decode the 32bit value
            object[name] = buffer[i++] | buffer[i++] &lt;&lt; 8 | buffer[i++] &lt;&lt; 16 | buffer[i++] &lt;&lt; 24;    break;

        case 1:     /// = BSON.BSON_DATA_NUMBER:     // Decode the double value
            object[name] = buffer.readDoubleLE(i);   /// slightly faster depending on dec.points; a LOT cleaner
            /// OLD: object[name] = readIEEE754(buffer, i, &#039;little&#039;, 52, 8);
            i += 8;     break;

        case 8:     /// = BSON.BSON_DATA_BOOLEAN:
            object[name] = buffer[i++] == 1;    break;

        case 6:     /// = BSON.BSON_DATA_UNDEFINED:     /// deprecated
        case 10:    /// = BSON.BSON_DATA_NULL:
            object[name] = null;     break;

        case 4:     /// = BSON.BSON_DATA_ARRAY
            size = buffer[i] | buffer[i+1] &lt;&lt;8 | buffer[i+2] &lt;&lt;16 | buffer[i+3] &lt;&lt;24;  /// NO &#039;i&#039; increment since the size bytes are reread during the recursion!
            object[name] = deserializeFast(buffer, i, true );  /// pass current index &amp; set isArray = true
            i += size;      break;
        case 3:     /// = BSON.BSON_DATA_OBJECT:
            size = buffer[i] | buffer[i+1] &lt;&lt;8 | buffer[i+2] &lt;&lt;16 | buffer[i+3] &lt;&lt;24;
            object[name] = deserializeFast(buffer, i, false );          /// isArray = false =&gt; Object
            i += size;      break;

        case 5:     /// = BSON.BSON_DATA_BINARY:             // Decode the size of the binary blob
            size = buffer[i++] | buffer[i++] &lt;&lt; 8 | buffer[i++] &lt;&lt; 16 | buffer[i++] &lt;&lt; 24;
            buffer[i++];             /// Skip, as we assume always default subtype, i.e. 0!
            object[name] = buffer.slice(i, i += size);  /// creates a new Buffer &quot;slice&quot; view of the same memory!
            break;

        case 9:     /// = BSON.BSON_DATA_DATE:      /// SEE notes below on the Date type vs. other options...
            low  = buffer[i++] | buffer[i++] &lt;&lt; 8 | buffer[i++] &lt;&lt; 16 | buffer[i++] &lt;&lt; 24;
            high = buffer[i++] | buffer[i++] &lt;&lt; 8 | buffer[i++] &lt;&lt; 16 | buffer[i++] &lt;&lt; 24;
            object[name] = new Date( high * 4294967296 + (low &lt; 0 ? low + 4294967296 : low) );  break;

        case 18:    /// = BSON.BSON_DATA_LONG:  /// usage should be somewhat rare beyond parseResponse() -&gt; cursorId, where it is handled inline, NOT as part of deserializeFast(returnedObjects); get lowBits, highBits:
            low  = buffer[i++] | buffer[i++] &lt;&lt; 8 | buffer[i++] &lt;&lt; 16 | buffer[i++] &lt;&lt; 24;
            high = buffer[i++] | buffer[i++] &lt;&lt; 8 | buffer[i++] &lt;&lt; 16 | buffer[i++] &lt;&lt; 24;

            size = high * 4294967296 + (low &lt; 0 ? low + 4294967296 : low);      /// from long.toNumber()
            if (size &lt; JS_INT_MAX &amp;&amp; size &gt; JS_INT_MIN) object[name] = size;    /// positive # more likely!
            else object[name] = new Long(low, high);    break;

        case 127:   /// = BSON.BSON_DATA_MIN_KEY:   /// do we EVER actually get these BACK from MongoDB server?!
            object[name] = new MinKey();     break;
        case 255:   /// = BSON.BSON_DATA_MAX_KEY:
            object[name] = new MaxKey();     break;

        case 17:    /// = BSON.BSON_DATA_TIMESTAMP:   /// somewhat obscure internal BSON type; MongoDB uses it for (pseudo) high-res time timestamp (past millisecs precision is just a counter!) in the Oplog ts: field, etc.
            low  = buffer[i++] | buffer[i++] &lt;&lt; 8 | buffer[i++] &lt;&lt; 16 | buffer[i++] &lt;&lt; 24;
            high = buffer[i++] | buffer[i++] &lt;&lt; 8 | buffer[i++] &lt;&lt; 16 | buffer[i++] &lt;&lt; 24;
            object[name] = new Timestamp(low, high);     break;

///        case 11:    /// = RegExp is skipped; we should NEVER be getting any from the MongoDB server!?
        }   /// end of switch(elementType)
    }   /// end of while(1)
    return object;  // Return the finalized object
}


function MinKey() { this._bsontype = &#039;MinKey&#039;; }  /// these are merely placeholders/stubs to signify the type!?

function MaxKey() { this._bsontype = &#039;MaxKey&#039;; }

function Long(low, high) {
    this._bsontype = &#039;Long&#039;;
    this.low_ = low | 0;    this.high_ = high | 0;          /// force into 32 signed bits.
}
Long.prototype.getLowBits = function(){ return this.low_; }
Long.prototype.getHighBits = function(){ return this.high_; }

Long.prototype.toNumber = function(){
    return this.high_ * 4294967296 + (this.low_ &lt; 0 ? this.low_ + 4294967296 : this.low_);
}
Long.fromNumber = function(num){
    return new Long(num % 4294967296, num / 4294967296);    /// |0 is forced in the constructor!
}
function Double(value) {
    this._bsontype = &#039;Double&#039;;
    this.value = value;
}
function Timestamp(low, high) {
    this._bsontype = &#039;Timestamp&#039;;
    this.low_ = low | 0;    this.high_ = high | 0;          /// force into 32 signed bits.
}
Timestamp.prototype.getLowBits = function(){ return this.low_; }
Timestamp.prototype.getHighBits = function(){ return this.high_; }

///////////////////////////////  ObjectID /////////////////////////////////
/// machine &amp; proc IDs stored as 1 string, b/c Buffer shouldn&#039;t be held for long periods (could use SlowBuffer?!)

var MACHINE = parseInt(Math.random() * 0xFFFFFF, 10);
var PROCESS = process.pid % 0xFFFF;
var MACHINE_AND_PROC = encodeIntBE(MACHINE, 3) + encodeIntBE(PROCESS, 2); /// keep as ONE string, ready to go.

function encodeIntBE(data, bytes){  /// encode the bytes to a string
    var result = &#039;&#039;;
    if (bytes &gt;= 4){ result += String.fromCharCode(Math.floor(data / 0x1000000)); data %= 0x1000000; }
    if (bytes &gt;= 3){ result += String.fromCharCode(Math.floor(data / 0x10000)); data %= 0x10000; }
    if (bytes &gt;= 2){ result += String.fromCharCode(Math.floor(data / 0x100)); data %= 0x100; }
    result += String.fromCharCode(Math.floor(data));
    return result;
}
var _counter = ~~(Math.random() * 0xFFFFFF);    /// double-tilde is equivalent to Math.floor()
var checkForHex = new RegExp(&#039;^[0-9a-fA-F]{24}$&#039;);

function ObjectID(id) {
    this._bsontype = &#039;ObjectID&#039;;
    if (!id){  this.id = createFromScratch();     /// base case, DONE.
    } else {
        if (id.constructor === Buffer){
            this.id = id;  /// case of
        } else if (id.constructor === String) {
            if ( id.length === 24 &amp;&amp; checkForHex.test(id) ) {
                this.id = new Buffer(id, &#039;hex&#039;);
            } else {
                this.id = new Error(&#039;Illegal/faulty Hexadecimal string supplied!&#039;);     /// changed from &#039;throw&#039;
            }
        } else if (id.constructor === Number) {
            this.id = createFromTime(id);    /// this is what should be the only interface for this!?
        }
    }
}
function createFromScratch() {
    var buf = new Buffer(12), i = 0;
    var ts = ~~(Date.now()/1000);    /// 4 bytes timestamp in seconds, BigEndian notation!
    buf[i++] = (ts &gt;&gt; 24) &amp; 0xFF;    buf[i++] = (ts &gt;&gt; 16) &amp; 0xFF;
    buf[i++] = (ts &gt;&gt; 8) &amp; 0xFF;     buf[i++] = (ts) &amp; 0xFF;

    buf.write(MACHINE_AND_PROC, i, 5, &#039;utf8&#039;);  i += 5;  /// write 3 bytes + 2 bytes MACHINE_ID and PROCESS_ID
    _counter = ++_counter % 0xFFFFFF;       /// 3 bytes internal _counter for subsecond resolution; BigEndian
    buf[i++] = (_counter &gt;&gt; 16) &amp; 0xFF;
    buf[i++] = (_counter &gt;&gt; 8) &amp; 0xFF;
    buf[i++] = (_counter) &amp; 0xFF;
    return buf;
}
function createFromTime(ts) {
    ts || ( ts = ~~(Date.now()/1000) );     /// 4 bytes timestamp in seconds only
    var buf = new Buffer(12), i = 0;
    buf[i++] = (ts &gt;&gt; 24) &amp; 0xFF;    buf[i++] = (ts &gt;&gt; 16) &amp; 0xFF;
    buf[i++] = (ts &gt;&gt; 8) &amp; 0xFF;     buf[i++] = (ts) &amp; 0xFF;

    for (;i &lt; 12; ++i) buf[i] = 0x00;       /// indeces 4 through 11 (8 bytes) get filled up with nulls
    return buf;
}
ObjectID.prototype.toHexString = function toHexString() {
    return this.id.toString(&#039;hex&#039;);
}
ObjectID.prototype.getTimestamp = function getTimestamp() {
    return this.id.readUIntBE(0, 4);
}
ObjectID.prototype.getTimestampDate = function getTimestampDate() {
    var ts = new Date();
    ts.setTime(this.id.readUIntBE(0, 4) * 1000);
    return ts;
}
ObjectID.createPk = function createPk () {  ///?override if a PrivateKey factory w/ unique factors is warranted?!
  return new ObjectID();
}
ObjectID.prototype.toJSON = function toJSON() {
    return &quot;ObjectID(&#039;&quot; +this.id.toString(&#039;hex&#039;)+ &quot;&#039;)&quot;;
}

/// module.exports.BSON = BSON;         /// not needed anymore!? exports.Binary = Binary;
module.exports.ObjectID = ObjectID;
module.exports.MinKey = MinKey;
module.exports.MaxKey = MaxKey;
module.exports.Long = Long;    /// ?! we really don&#039;t want to do the complicated Long math anywhere for now!?

//module.exports.Double = Double;
//module.exports.Timestamp = Timestamp;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
