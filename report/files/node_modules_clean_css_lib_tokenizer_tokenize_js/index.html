<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/clean-css/lib/tokenizer/tokenize.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/clean-css/lib/tokenizer/tokenize.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">48.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">264</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">73.89</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.04</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var extractProperties = require(&#039;./extract-properties&#039;);
var extractSelectors = require(&#039;./extract-selectors&#039;);
var track = require(&#039;../source-maps/track&#039;);
var split = require(&#039;../utils/split&#039;);

var path = require(&#039;path&#039;);

var flatBlock = /(@(font\-face|page|\-ms\-viewport|\-o\-viewport|viewport|counter\-style)|\\@.+?)/;

function tokenize(data, outerContext) {
  var chunks = split(normalize(data), &#039;}&#039;, true, &#039;{&#039;, &#039;}&#039;);
  if (chunks.length === 0)
    return [];

  var context = {
    chunk: chunks.shift(),
    chunks: chunks,
    column: 0,
    cursor: 0,
    line: 1,
    mode: &#039;top&#039;,
    resolvePath: outerContext.options.explicitTarget ?
      relativePathResolver(outerContext.options.root, outerContext.options.target) :
      null,
    source: undefined,
    sourceMap: outerContext.options.sourceMap,
    sourceMapInlineSources: outerContext.options.sourceMapInlineSources,
    sourceMapTracker: outerContext.inputSourceMapTracker,
    sourceReader: outerContext.sourceReader,
    sourceTracker: outerContext.sourceTracker,
    state: [],
    track: outerContext.options.sourceMap ?
      function (data, snapshotMetadata, fallbacks) { return [[track(data, context, snapshotMetadata, fallbacks)]]; } :
      function () { return []; },
    warnings: outerContext.warnings
  };

  return intoTokens(context);
}

function normalize(data) {
  return data.replace(/\r\n/g, &#039;\n&#039;);
}

function relativePathResolver(root, target) {
  var rebaseTo = path.relative(root, target);

  return function (relativeTo, sourcePath) {
    return relativeTo != sourcePath ?
      path.normalize(path.join(path.relative(rebaseTo, path.dirname(relativeTo)), sourcePath)) :
      sourcePath;
  };
}

function whatsNext(context) {
  var mode = context.mode;
  var chunk = context.chunk;
  var closest;

  if (chunk.length == context.cursor) {
    if (context.chunks.length === 0)
      return null;

    context.chunk = chunk = context.chunks.shift();
    context.cursor = 0;
  }

  if (mode == &#039;body&#039;) {
    if (chunk[context.cursor] == &#039;}&#039;)
      return [context.cursor, &#039;bodyEnd&#039;];

    if (chunk.indexOf(&#039;}&#039;, context.cursor) == -1)
      return null;

    closest = context.cursor + split(chunk.substring(context.cursor - 1), &#039;}&#039;, true, &#039;{&#039;, &#039;}&#039;)[0].length - 2;
    return [closest, &#039;bodyEnd&#039;];
  }

  var nextSpecial = chunk.indexOf(&#039;@&#039;, context.cursor);
  var nextEscape = chunk.indexOf(&#039;__ESCAPED_&#039;, context.cursor);
  var nextBodyStart = chunk.indexOf(&#039;{&#039;, context.cursor);
  var nextBodyEnd = chunk.indexOf(&#039;}&#039;, context.cursor);

  if (nextEscape &gt; -1 &amp;&amp; /\S/.test(chunk.substring(context.cursor, nextEscape)))
    nextEscape = -1;

  closest = nextSpecial;
  if (closest == -1 || (nextEscape &gt; -1 &amp;&amp; nextEscape &lt; closest))
    closest = nextEscape;
  if (closest == -1 || (nextBodyStart &gt; -1 &amp;&amp; nextBodyStart &lt; closest))
    closest = nextBodyStart;
  if (closest == -1 || (nextBodyEnd &gt; -1 &amp;&amp; nextBodyEnd &lt; closest))
    closest = nextBodyEnd;

  if (closest == -1)
    return;
  if (nextEscape === closest)
    return [closest, &#039;escape&#039;];
  if (nextBodyStart === closest)
    return [closest, &#039;bodyStart&#039;];
  if (nextBodyEnd === closest)
    return [closest, &#039;bodyEnd&#039;];
  if (nextSpecial === closest)
    return [closest, &#039;special&#039;];
}

function intoTokens(context) {
  var chunk = context.chunk;
  var tokenized = [];
  var newToken;
  var value;

  while (true) {
    var next = whatsNext(context);
    if (!next) {
      var whatsLeft = context.chunk.substring(context.cursor);
      if (whatsLeft.trim().length &gt; 0) {
        if (context.mode == &#039;body&#039;) {
          context.warnings.push(&#039;Missing \&#039;}\&#039; after \&#039;&#039; + whatsLeft + &#039;\&#039;. Ignoring.&#039;);
        } else {
          tokenized.push([&#039;text&#039;, [whatsLeft]]);
        }
        context.cursor += whatsLeft.length;
      }
      break;
    }

    var nextSpecial = next[0];
    var what = next[1];
    var nextEnd;
    var oldMode;

    chunk = context.chunk;

    if (context.cursor != nextSpecial &amp;&amp; what != &#039;bodyEnd&#039;) {
      var spacing = chunk.substring(context.cursor, nextSpecial);
      var leadingWhitespace = /^\s+/.exec(spacing);

      if (leadingWhitespace) {
        context.cursor += leadingWhitespace[0].length;
        context.track(leadingWhitespace[0]);
      }
    }

    if (what == &#039;special&#039;) {
      var firstOpenBraceAt = chunk.indexOf(&#039;{&#039;, nextSpecial);
      var firstSemicolonAt = chunk.indexOf(&#039;;&#039;, nextSpecial);
      var isSingle = firstSemicolonAt &gt; -1 &amp;&amp; (firstOpenBraceAt == -1 || firstSemicolonAt &lt; firstOpenBraceAt);
      var isBroken = firstOpenBraceAt == -1 &amp;&amp; firstSemicolonAt == -1;
      if (isBroken) {
        context.warnings.push(&#039;Broken declaration: \&#039;&#039; + chunk.substring(context.cursor) +  &#039;\&#039;.&#039;);
        context.cursor = chunk.length;
      } else if (isSingle) {
        nextEnd = chunk.indexOf(&#039;;&#039;, nextSpecial + 1);
        value = chunk.substring(context.cursor, nextEnd + 1);

        tokenized.push([
          &#039;at-rule&#039;,
          [value].concat(context.track(value, true))
        ]);

        context.track(&#039;;&#039;);
        context.cursor = nextEnd + 1;
      } else {
        nextEnd = chunk.indexOf(&#039;{&#039;, nextSpecial + 1);
        value = chunk.substring(context.cursor, nextEnd);

        var trimmedValue = value.trim();
        var isFlat = flatBlock.test(trimmedValue);
        oldMode = context.mode;
        context.cursor = nextEnd + 1;
        context.mode = isFlat ? &#039;body&#039; : &#039;block&#039;;

        newToken = [
          isFlat ? &#039;flat-block&#039; : &#039;block&#039;
        ];

        newToken.push([trimmedValue].concat(context.track(value, true)));
        context.track(&#039;{&#039;);
        newToken.push(intoTokens(context));

        if (typeof newToken[2] == &#039;string&#039;)
          newToken[2] = extractProperties(newToken[2], [[trimmedValue]], context);

        context.mode = oldMode;
        context.track(&#039;}&#039;);

        tokenized.push(newToken);
      }
    } else if (what == &#039;escape&#039;) {
      nextEnd = chunk.indexOf(&#039;__&#039;, nextSpecial + 1);
      var escaped = chunk.substring(context.cursor, nextEnd + 2);
      var isStartSourceMarker = !!context.sourceTracker.nextStart(escaped);
      var isEndSourceMarker = !!context.sourceTracker.nextEnd(escaped);

      if (isStartSourceMarker) {
        context.track(escaped);
        context.state.push({
          source: context.source,
          line: context.line,
          column: context.column
        });
        context.source = context.sourceTracker.nextStart(escaped).filename;
        context.line = 1;
        context.column = 0;
      } else if (isEndSourceMarker) {
        var oldState = context.state.pop();
        context.source = oldState.source;
        context.line = oldState.line;
        context.column = oldState.column;
        context.track(escaped);
      } else {
        if (escaped.indexOf(&#039;__ESCAPED_COMMENT_SPECIAL&#039;) === 0)
          tokenized.push([&#039;text&#039;, [escaped]]);

        context.track(escaped);
      }

      context.cursor = nextEnd + 2;
    } else if (what == &#039;bodyStart&#039;) {
      var selectors = extractSelectors(chunk.substring(context.cursor, nextSpecial), context);

      oldMode = context.mode;
      context.cursor = nextSpecial + 1;
      context.mode = &#039;body&#039;;

      var body = extractProperties(intoTokens(context), selectors, context);

      context.track(&#039;{&#039;);
      context.mode = oldMode;

      tokenized.push([
        &#039;selector&#039;,
        selectors,
        body
      ]);
    } else if (what == &#039;bodyEnd&#039;) {
      // extra closing brace at the top level can be safely ignored
      if (context.mode == &#039;top&#039;) {
        var at = context.cursor;
        var warning = chunk[context.cursor] == &#039;}&#039; ?
          &#039;Unexpected \&#039;}\&#039; in \&#039;&#039; + chunk.substring(at - 20, at + 20) + &#039;\&#039;. Ignoring.&#039; :
          &#039;Unexpected content: \&#039;&#039; + chunk.substring(at, nextSpecial + 1) + &#039;\&#039;. Ignoring.&#039;;

        context.warnings.push(warning);
        context.cursor = nextSpecial + 1;
        continue;
      }

      if (context.mode == &#039;block&#039;)
        context.track(chunk.substring(context.cursor, nextSpecial));
      if (context.mode != &#039;block&#039;)
        tokenized = chunk.substring(context.cursor, nextSpecial);

      context.cursor = nextSpecial + 1;

      break;
    }
  }

  return tokenized;
}

module.exports = tokenize;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
